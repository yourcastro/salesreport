{"ast":null,"code":"define([\"./core\", \"./data/var/dataPriv\", \"./deferred\", \"./callbacks\"], function (jQuery, dataPriv) {\n  \"use strict\";\n\n  jQuery.extend({\n    queue: function (elem, type, data) {\n      var queue;\n\n      if (elem) {\n        type = (type || \"fx\") + \"queue\";\n        queue = dataPriv.get(elem, type); // Speed up dequeue by getting out quickly if this is just a lookup\n\n        if (data) {\n          if (!queue || Array.isArray(data)) {\n            queue = dataPriv.access(elem, type, jQuery.makeArray(data));\n          } else {\n            queue.push(data);\n          }\n        }\n\n        return queue || [];\n      }\n    },\n    dequeue: function (elem, type) {\n      type = type || \"fx\";\n\n      var queue = jQuery.queue(elem, type),\n          startLength = queue.length,\n          fn = queue.shift(),\n          hooks = jQuery._queueHooks(elem, type),\n          next = function () {\n        jQuery.dequeue(elem, type);\n      }; // If the fx queue is dequeued, always remove the progress sentinel\n\n\n      if (fn === \"inprogress\") {\n        fn = queue.shift();\n        startLength--;\n      }\n\n      if (fn) {\n        // Add a progress sentinel to prevent the fx queue from being\n        // automatically dequeued\n        if (type === \"fx\") {\n          queue.unshift(\"inprogress\");\n        } // Clear up the last queue stop function\n\n\n        delete hooks.stop;\n        fn.call(elem, next, hooks);\n      }\n\n      if (!startLength && hooks) {\n        hooks.empty.fire();\n      }\n    },\n    // Not public - generate a queueHooks object, or return the current one\n    _queueHooks: function (elem, type) {\n      var key = type + \"queueHooks\";\n      return dataPriv.get(elem, key) || dataPriv.access(elem, key, {\n        empty: jQuery.Callbacks(\"once memory\").add(function () {\n          dataPriv.remove(elem, [type + \"queue\", key]);\n        })\n      });\n    }\n  });\n  jQuery.fn.extend({\n    queue: function (type, data) {\n      var setter = 2;\n\n      if (typeof type !== \"string\") {\n        data = type;\n        type = \"fx\";\n        setter--;\n      }\n\n      if (arguments.length < setter) {\n        return jQuery.queue(this[0], type);\n      }\n\n      return data === undefined ? this : this.each(function () {\n        var queue = jQuery.queue(this, type, data); // Ensure a hooks for this queue\n\n        jQuery._queueHooks(this, type);\n\n        if (type === \"fx\" && queue[0] !== \"inprogress\") {\n          jQuery.dequeue(this, type);\n        }\n      });\n    },\n    dequeue: function (type) {\n      return this.each(function () {\n        jQuery.dequeue(this, type);\n      });\n    },\n    clearQueue: function (type) {\n      return this.queue(type || \"fx\", []);\n    },\n    // Get a promise resolved when queues of a certain type\n    // are emptied (fx is the type by default)\n    promise: function (type, obj) {\n      var tmp,\n          count = 1,\n          defer = jQuery.Deferred(),\n          elements = this,\n          i = this.length,\n          resolve = function () {\n        if (! --count) {\n          defer.resolveWith(elements, [elements]);\n        }\n      };\n\n      if (typeof type !== \"string\") {\n        obj = type;\n        type = undefined;\n      }\n\n      type = type || \"fx\";\n\n      while (i--) {\n        tmp = dataPriv.get(elements[i], type + \"queueHooks\");\n\n        if (tmp && tmp.empty) {\n          count++;\n          tmp.empty.add(resolve);\n        }\n      }\n\n      resolve();\n      return defer.promise(obj);\n    }\n  });\n  return jQuery;\n});","map":{"version":3,"sources":["D:/Castro/Development/hr-management-portal/hr-management-portal/node_modules/jquery/src/queue.js"],"names":["define","jQuery","dataPriv","extend","queue","elem","type","data","get","Array","isArray","access","makeArray","push","dequeue","startLength","length","fn","shift","hooks","_queueHooks","next","unshift","stop","call","empty","fire","key","Callbacks","add","remove","setter","arguments","undefined","each","clearQueue","promise","obj","tmp","count","defer","Deferred","elements","i","resolve","resolveWith"],"mappings":"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","sourcesContent":["define( [\n\t\"./core\",\n\t\"./data/var/dataPriv\",\n\t\"./deferred\",\n\t\"./callbacks\"\n], function( jQuery, dataPriv ) {\n\n\"use strict\";\n\njQuery.extend( {\n\tqueue: function( elem, type, data ) {\n\t\tvar queue;\n\n\t\tif ( elem ) {\n\t\t\ttype = ( type || \"fx\" ) + \"queue\";\n\t\t\tqueue = dataPriv.get( elem, type );\n\n\t\t\t// Speed up dequeue by getting out quickly if this is just a lookup\n\t\t\tif ( data ) {\n\t\t\t\tif ( !queue || Array.isArray( data ) ) {\n\t\t\t\t\tqueue = dataPriv.access( elem, type, jQuery.makeArray( data ) );\n\t\t\t\t} else {\n\t\t\t\t\tqueue.push( data );\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn queue || [];\n\t\t}\n\t},\n\n\tdequeue: function( elem, type ) {\n\t\ttype = type || \"fx\";\n\n\t\tvar queue = jQuery.queue( elem, type ),\n\t\t\tstartLength = queue.length,\n\t\t\tfn = queue.shift(),\n\t\t\thooks = jQuery._queueHooks( elem, type ),\n\t\t\tnext = function() {\n\t\t\t\tjQuery.dequeue( elem, type );\n\t\t\t};\n\n\t\t// If the fx queue is dequeued, always remove the progress sentinel\n\t\tif ( fn === \"inprogress\" ) {\n\t\t\tfn = queue.shift();\n\t\t\tstartLength--;\n\t\t}\n\n\t\tif ( fn ) {\n\n\t\t\t// Add a progress sentinel to prevent the fx queue from being\n\t\t\t// automatically dequeued\n\t\t\tif ( type === \"fx\" ) {\n\t\t\t\tqueue.unshift( \"inprogress\" );\n\t\t\t}\n\n\t\t\t// Clear up the last queue stop function\n\t\t\tdelete hooks.stop;\n\t\t\tfn.call( elem, next, hooks );\n\t\t}\n\n\t\tif ( !startLength && hooks ) {\n\t\t\thooks.empty.fire();\n\t\t}\n\t},\n\n\t// Not public - generate a queueHooks object, or return the current one\n\t_queueHooks: function( elem, type ) {\n\t\tvar key = type + \"queueHooks\";\n\t\treturn dataPriv.get( elem, key ) || dataPriv.access( elem, key, {\n\t\t\tempty: jQuery.Callbacks( \"once memory\" ).add( function() {\n\t\t\t\tdataPriv.remove( elem, [ type + \"queue\", key ] );\n\t\t\t} )\n\t\t} );\n\t}\n} );\n\njQuery.fn.extend( {\n\tqueue: function( type, data ) {\n\t\tvar setter = 2;\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tdata = type;\n\t\t\ttype = \"fx\";\n\t\t\tsetter--;\n\t\t}\n\n\t\tif ( arguments.length < setter ) {\n\t\t\treturn jQuery.queue( this[ 0 ], type );\n\t\t}\n\n\t\treturn data === undefined ?\n\t\t\tthis :\n\t\t\tthis.each( function() {\n\t\t\t\tvar queue = jQuery.queue( this, type, data );\n\n\t\t\t\t// Ensure a hooks for this queue\n\t\t\t\tjQuery._queueHooks( this, type );\n\n\t\t\t\tif ( type === \"fx\" && queue[ 0 ] !== \"inprogress\" ) {\n\t\t\t\t\tjQuery.dequeue( this, type );\n\t\t\t\t}\n\t\t\t} );\n\t},\n\tdequeue: function( type ) {\n\t\treturn this.each( function() {\n\t\t\tjQuery.dequeue( this, type );\n\t\t} );\n\t},\n\tclearQueue: function( type ) {\n\t\treturn this.queue( type || \"fx\", [] );\n\t},\n\n\t// Get a promise resolved when queues of a certain type\n\t// are emptied (fx is the type by default)\n\tpromise: function( type, obj ) {\n\t\tvar tmp,\n\t\t\tcount = 1,\n\t\t\tdefer = jQuery.Deferred(),\n\t\t\telements = this,\n\t\t\ti = this.length,\n\t\t\tresolve = function() {\n\t\t\t\tif ( !( --count ) ) {\n\t\t\t\t\tdefer.resolveWith( elements, [ elements ] );\n\t\t\t\t}\n\t\t\t};\n\n\t\tif ( typeof type !== \"string\" ) {\n\t\t\tobj = type;\n\t\t\ttype = undefined;\n\t\t}\n\t\ttype = type || \"fx\";\n\n\t\twhile ( i-- ) {\n\t\t\ttmp = dataPriv.get( elements[ i ], type + \"queueHooks\" );\n\t\t\tif ( tmp && tmp.empty ) {\n\t\t\t\tcount++;\n\t\t\t\ttmp.empty.add( resolve );\n\t\t\t}\n\t\t}\n\t\tresolve();\n\t\treturn defer.promise( obj );\n\t}\n} );\n\nreturn jQuery;\n} );\n"]},"metadata":{},"sourceType":"script"}