{"ast":null,"code":"define([\"./core\", \"./core/toType\", \"./var/isFunction\", \"./var/rnothtmlwhite\"], function (jQuery, toType, isFunction, rnothtmlwhite) {\n  \"use strict\"; // Convert String-formatted options into Object-formatted ones\n\n  function createOptions(options) {\n    var object = {};\n    jQuery.each(options.match(rnothtmlwhite) || [], function (_, flag) {\n      object[flag] = true;\n    });\n    return object;\n  }\n  /*\n   * Create a callback list using the following parameters:\n   *\n   *\toptions: an optional list of space-separated options that will change how\n   *\t\t\tthe callback list behaves or a more traditional option object\n   *\n   * By default a callback list will act like an event callback list and can be\n   * \"fired\" multiple times.\n   *\n   * Possible options:\n   *\n   *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n   *\n   *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n   *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n   *\t\t\t\t\tvalues (like a Deferred)\n   *\n   *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n   *\n   *\tstopOnFalse:\tinterrupt callings when a callback returns false\n   *\n   */\n\n\n  jQuery.Callbacks = function (options) {\n    // Convert options from String-formatted to Object-formatted if needed\n    // (we check in cache first)\n    options = typeof options === \"string\" ? createOptions(options) : jQuery.extend({}, options);\n\n    var // Flag to know if list is currently firing\n    firing,\n        // Last fire value for non-forgettable lists\n    memory,\n        // Flag to know if list was already fired\n    fired,\n        // Flag to prevent firing\n    locked,\n        // Actual callback list\n    list = [],\n        // Queue of execution data for repeatable lists\n    queue = [],\n        // Index of currently firing callback (modified by add/remove as needed)\n    firingIndex = -1,\n        // Fire callbacks\n    fire = function () {\n      // Enforce single-firing\n      locked = locked || options.once; // Execute callbacks for all pending executions,\n      // respecting firingIndex overrides and runtime changes\n\n      fired = firing = true;\n\n      for (; queue.length; firingIndex = -1) {\n        memory = queue.shift();\n\n        while (++firingIndex < list.length) {\n          // Run callback and check for early termination\n          if (list[firingIndex].apply(memory[0], memory[1]) === false && options.stopOnFalse) {\n            // Jump to end and forget the data so .add doesn't re-fire\n            firingIndex = list.length;\n            memory = false;\n          }\n        }\n      } // Forget the data if we're done with it\n\n\n      if (!options.memory) {\n        memory = false;\n      }\n\n      firing = false; // Clean up if we're done firing for good\n\n      if (locked) {\n        // Keep an empty list if we have data for future add calls\n        if (memory) {\n          list = []; // Otherwise, this object is spent\n        } else {\n          list = \"\";\n        }\n      }\n    },\n        // Actual Callbacks object\n    self = {\n      // Add a callback or a collection of callbacks to the list\n      add: function () {\n        if (list) {\n          // If we have memory from a past run, we should fire after adding\n          if (memory && !firing) {\n            firingIndex = list.length - 1;\n            queue.push(memory);\n          }\n\n          (function add(args) {\n            jQuery.each(args, function (_, arg) {\n              if (isFunction(arg)) {\n                if (!options.unique || !self.has(arg)) {\n                  list.push(arg);\n                }\n              } else if (arg && arg.length && toType(arg) !== \"string\") {\n                // Inspect recursively\n                add(arg);\n              }\n            });\n          })(arguments);\n\n          if (memory && !firing) {\n            fire();\n          }\n        }\n\n        return this;\n      },\n      // Remove a callback from the list\n      remove: function () {\n        jQuery.each(arguments, function (_, arg) {\n          var index;\n\n          while ((index = jQuery.inArray(arg, list, index)) > -1) {\n            list.splice(index, 1); // Handle firing indexes\n\n            if (index <= firingIndex) {\n              firingIndex--;\n            }\n          }\n        });\n        return this;\n      },\n      // Check if a given callback is in the list.\n      // If no argument is given, return whether or not list has callbacks attached.\n      has: function (fn) {\n        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0;\n      },\n      // Remove all callbacks from the list\n      empty: function () {\n        if (list) {\n          list = [];\n        }\n\n        return this;\n      },\n      // Disable .fire and .add\n      // Abort any current/pending executions\n      // Clear all callbacks and values\n      disable: function () {\n        locked = queue = [];\n        list = memory = \"\";\n        return this;\n      },\n      disabled: function () {\n        return !list;\n      },\n      // Disable .fire\n      // Also disable .add unless we have memory (since it would have no effect)\n      // Abort any pending executions\n      lock: function () {\n        locked = queue = [];\n\n        if (!memory && !firing) {\n          list = memory = \"\";\n        }\n\n        return this;\n      },\n      locked: function () {\n        return !!locked;\n      },\n      // Call all callbacks with the given context and arguments\n      fireWith: function (context, args) {\n        if (!locked) {\n          args = args || [];\n          args = [context, args.slice ? args.slice() : args];\n          queue.push(args);\n\n          if (!firing) {\n            fire();\n          }\n        }\n\n        return this;\n      },\n      // Call all the callbacks with the given arguments\n      fire: function () {\n        self.fireWith(this, arguments);\n        return this;\n      },\n      // To know if the callbacks have already been called at least once\n      fired: function () {\n        return !!fired;\n      }\n    };\n\n    return self;\n  };\n\n  return jQuery;\n});","map":{"version":3,"sources":["D:/Castro/Development/hr-management-portal/hr-management-portal/node_modules/jquery/src/callbacks.js"],"names":["define","jQuery","toType","isFunction","rnothtmlwhite","createOptions","options","object","each","match","_","flag","Callbacks","extend","firing","memory","fired","locked","list","queue","firingIndex","fire","once","length","shift","apply","stopOnFalse","self","add","push","args","arg","unique","has","arguments","remove","index","inArray","splice","fn","empty","disable","disabled","lock","fireWith","context","slice"],"mappings":"AAAAA,MAAM,CAAE,CACP,QADO,EAEP,eAFO,EAGP,kBAHO,EAIP,qBAJO,CAAF,EAKH,UAAUC,MAAV,EAAkBC,MAAlB,EAA0BC,UAA1B,EAAsCC,aAAtC,EAAsD;AAEzD,eAFyD,CAIzD;;AACA,WAASC,aAAT,CAAwBC,OAAxB,EAAkC;AACjC,QAAIC,MAAM,GAAG,EAAb;AACAN,IAAAA,MAAM,CAACO,IAAP,CAAaF,OAAO,CAACG,KAAR,CAAeL,aAAf,KAAkC,EAA/C,EAAmD,UAAUM,CAAV,EAAaC,IAAb,EAAoB;AACtEJ,MAAAA,MAAM,CAAEI,IAAF,CAAN,GAAiB,IAAjB;AACA,KAFD;AAGA,WAAOJ,MAAP;AACA;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAN,EAAAA,MAAM,CAACW,SAAP,GAAmB,UAAUN,OAAV,EAAoB;AAEtC;AACA;AACAA,IAAAA,OAAO,GAAG,OAAOA,OAAP,KAAmB,QAAnB,GACTD,aAAa,CAAEC,OAAF,CADJ,GAETL,MAAM,CAACY,MAAP,CAAe,EAAf,EAAmBP,OAAnB,CAFD;;AAIA,QAAI;AACHQ,IAAAA,MADD;AAAA,QAGC;AACAC,IAAAA,MAJD;AAAA,QAMC;AACAC,IAAAA,KAPD;AAAA,QASC;AACAC,IAAAA,MAVD;AAAA,QAYC;AACAC,IAAAA,IAAI,GAAG,EAbR;AAAA,QAeC;AACAC,IAAAA,KAAK,GAAG,EAhBT;AAAA,QAkBC;AACAC,IAAAA,WAAW,GAAG,CAAC,CAnBhB;AAAA,QAqBC;AACAC,IAAAA,IAAI,GAAG,YAAW;AAEjB;AACAJ,MAAAA,MAAM,GAAGA,MAAM,IAAIX,OAAO,CAACgB,IAA3B,CAHiB,CAKjB;AACA;;AACAN,MAAAA,KAAK,GAAGF,MAAM,GAAG,IAAjB;;AACA,aAAQK,KAAK,CAACI,MAAd,EAAsBH,WAAW,GAAG,CAAC,CAArC,EAAyC;AACxCL,QAAAA,MAAM,GAAGI,KAAK,CAACK,KAAN,EAAT;;AACA,eAAQ,EAAEJ,WAAF,GAAgBF,IAAI,CAACK,MAA7B,EAAsC;AAErC;AACA,cAAKL,IAAI,CAAEE,WAAF,CAAJ,CAAoBK,KAApB,CAA2BV,MAAM,CAAE,CAAF,CAAjC,EAAwCA,MAAM,CAAE,CAAF,CAA9C,MAA0D,KAA1D,IACJT,OAAO,CAACoB,WADT,EACuB;AAEtB;AACAN,YAAAA,WAAW,GAAGF,IAAI,CAACK,MAAnB;AACAR,YAAAA,MAAM,GAAG,KAAT;AACA;AACD;AACD,OArBgB,CAuBjB;;;AACA,UAAK,CAACT,OAAO,CAACS,MAAd,EAAuB;AACtBA,QAAAA,MAAM,GAAG,KAAT;AACA;;AAEDD,MAAAA,MAAM,GAAG,KAAT,CA5BiB,CA8BjB;;AACA,UAAKG,MAAL,EAAc;AAEb;AACA,YAAKF,MAAL,EAAc;AACbG,UAAAA,IAAI,GAAG,EAAP,CADa,CAGd;AACC,SAJD,MAIO;AACNA,UAAAA,IAAI,GAAG,EAAP;AACA;AACD;AACD,KAhEF;AAAA,QAkEC;AACAS,IAAAA,IAAI,GAAG;AAEN;AACAC,MAAAA,GAAG,EAAE,YAAW;AACf,YAAKV,IAAL,EAAY;AAEX;AACA,cAAKH,MAAM,IAAI,CAACD,MAAhB,EAAyB;AACxBM,YAAAA,WAAW,GAAGF,IAAI,CAACK,MAAL,GAAc,CAA5B;AACAJ,YAAAA,KAAK,CAACU,IAAN,CAAYd,MAAZ;AACA;;AAED,WAAE,SAASa,GAAT,CAAcE,IAAd,EAAqB;AACtB7B,YAAAA,MAAM,CAACO,IAAP,CAAasB,IAAb,EAAmB,UAAUpB,CAAV,EAAaqB,GAAb,EAAmB;AACrC,kBAAK5B,UAAU,CAAE4B,GAAF,CAAf,EAAyB;AACxB,oBAAK,CAACzB,OAAO,CAAC0B,MAAT,IAAmB,CAACL,IAAI,CAACM,GAAL,CAAUF,GAAV,CAAzB,EAA2C;AAC1Cb,kBAAAA,IAAI,CAACW,IAAL,CAAWE,GAAX;AACA;AACD,eAJD,MAIO,IAAKA,GAAG,IAAIA,GAAG,CAACR,MAAX,IAAqBrB,MAAM,CAAE6B,GAAF,CAAN,KAAkB,QAA5C,EAAuD;AAE7D;AACAH,gBAAAA,GAAG,CAAEG,GAAF,CAAH;AACA;AACD,aAVD;AAWA,WAZD,EAYKG,SAZL;;AAcA,cAAKnB,MAAM,IAAI,CAACD,MAAhB,EAAyB;AACxBO,YAAAA,IAAI;AACJ;AACD;;AACD,eAAO,IAAP;AACA,OA/BK;AAiCN;AACAc,MAAAA,MAAM,EAAE,YAAW;AAClBlC,QAAAA,MAAM,CAACO,IAAP,CAAa0B,SAAb,EAAwB,UAAUxB,CAAV,EAAaqB,GAAb,EAAmB;AAC1C,cAAIK,KAAJ;;AACA,iBAAQ,CAAEA,KAAK,GAAGnC,MAAM,CAACoC,OAAP,CAAgBN,GAAhB,EAAqBb,IAArB,EAA2BkB,KAA3B,CAAV,IAAiD,CAAC,CAA1D,EAA8D;AAC7DlB,YAAAA,IAAI,CAACoB,MAAL,CAAaF,KAAb,EAAoB,CAApB,EAD6D,CAG7D;;AACA,gBAAKA,KAAK,IAAIhB,WAAd,EAA4B;AAC3BA,cAAAA,WAAW;AACX;AACD;AACD,SAVD;AAWA,eAAO,IAAP;AACA,OA/CK;AAiDN;AACA;AACAa,MAAAA,GAAG,EAAE,UAAUM,EAAV,EAAe;AACnB,eAAOA,EAAE,GACRtC,MAAM,CAACoC,OAAP,CAAgBE,EAAhB,EAAoBrB,IAApB,IAA6B,CAAC,CADtB,GAERA,IAAI,CAACK,MAAL,GAAc,CAFf;AAGA,OAvDK;AAyDN;AACAiB,MAAAA,KAAK,EAAE,YAAW;AACjB,YAAKtB,IAAL,EAAY;AACXA,UAAAA,IAAI,GAAG,EAAP;AACA;;AACD,eAAO,IAAP;AACA,OA/DK;AAiEN;AACA;AACA;AACAuB,MAAAA,OAAO,EAAE,YAAW;AACnBxB,QAAAA,MAAM,GAAGE,KAAK,GAAG,EAAjB;AACAD,QAAAA,IAAI,GAAGH,MAAM,GAAG,EAAhB;AACA,eAAO,IAAP;AACA,OAxEK;AAyEN2B,MAAAA,QAAQ,EAAE,YAAW;AACpB,eAAO,CAACxB,IAAR;AACA,OA3EK;AA6EN;AACA;AACA;AACAyB,MAAAA,IAAI,EAAE,YAAW;AAChB1B,QAAAA,MAAM,GAAGE,KAAK,GAAG,EAAjB;;AACA,YAAK,CAACJ,MAAD,IAAW,CAACD,MAAjB,EAA0B;AACzBI,UAAAA,IAAI,GAAGH,MAAM,GAAG,EAAhB;AACA;;AACD,eAAO,IAAP;AACA,OAtFK;AAuFNE,MAAAA,MAAM,EAAE,YAAW;AAClB,eAAO,CAAC,CAACA,MAAT;AACA,OAzFK;AA2FN;AACA2B,MAAAA,QAAQ,EAAE,UAAUC,OAAV,EAAmBf,IAAnB,EAA0B;AACnC,YAAK,CAACb,MAAN,EAAe;AACda,UAAAA,IAAI,GAAGA,IAAI,IAAI,EAAf;AACAA,UAAAA,IAAI,GAAG,CAAEe,OAAF,EAAWf,IAAI,CAACgB,KAAL,GAAahB,IAAI,CAACgB,KAAL,EAAb,GAA4BhB,IAAvC,CAAP;AACAX,UAAAA,KAAK,CAACU,IAAN,CAAYC,IAAZ;;AACA,cAAK,CAAChB,MAAN,EAAe;AACdO,YAAAA,IAAI;AACJ;AACD;;AACD,eAAO,IAAP;AACA,OAtGK;AAwGN;AACAA,MAAAA,IAAI,EAAE,YAAW;AAChBM,QAAAA,IAAI,CAACiB,QAAL,CAAe,IAAf,EAAqBV,SAArB;AACA,eAAO,IAAP;AACA,OA5GK;AA8GN;AACAlB,MAAAA,KAAK,EAAE,YAAW;AACjB,eAAO,CAAC,CAACA,KAAT;AACA;AAjHK,KAnER;;AAuLA,WAAOW,IAAP;AACA,GAhMD;;AAkMA,SAAO1B,MAAP;AACC,CA3OK,CAAN","sourcesContent":["define( [\n\t\"./core\",\n\t\"./core/toType\",\n\t\"./var/isFunction\",\n\t\"./var/rnothtmlwhite\"\n], function( jQuery, toType, isFunction, rnothtmlwhite ) {\n\n\"use strict\";\n\n// Convert String-formatted options into Object-formatted ones\nfunction createOptions( options ) {\n\tvar object = {};\n\tjQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t} );\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\tcreateOptions( options ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Flag to know if list is currently firing\n\t\tfiring,\n\n\t\t// Last fire value for non-forgettable lists\n\t\tmemory,\n\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\n\t\t// Flag to prevent firing\n\t\tlocked,\n\n\t\t// Actual callback list\n\t\tlist = [],\n\n\t\t// Queue of execution data for repeatable lists\n\t\tqueue = [],\n\n\t\t// Index of currently firing callback (modified by add/remove as needed)\n\t\tfiringIndex = -1,\n\n\t\t// Fire callbacks\n\t\tfire = function() {\n\n\t\t\t// Enforce single-firing\n\t\t\tlocked = locked || options.once;\n\n\t\t\t// Execute callbacks for all pending executions,\n\t\t\t// respecting firingIndex overrides and runtime changes\n\t\t\tfired = firing = true;\n\t\t\tfor ( ; queue.length; firingIndex = -1 ) {\n\t\t\t\tmemory = queue.shift();\n\t\t\t\twhile ( ++firingIndex < list.length ) {\n\n\t\t\t\t\t// Run callback and check for early termination\n\t\t\t\t\tif ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&\n\t\t\t\t\t\toptions.stopOnFalse ) {\n\n\t\t\t\t\t\t// Jump to end and forget the data so .add doesn't re-fire\n\t\t\t\t\t\tfiringIndex = list.length;\n\t\t\t\t\t\tmemory = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Forget the data if we're done with it\n\t\t\tif ( !options.memory ) {\n\t\t\t\tmemory = false;\n\t\t\t}\n\n\t\t\tfiring = false;\n\n\t\t\t// Clean up if we're done firing for good\n\t\t\tif ( locked ) {\n\n\t\t\t\t// Keep an empty list if we have data for future add calls\n\t\t\t\tif ( memory ) {\n\t\t\t\t\tlist = [];\n\n\t\t\t\t// Otherwise, this object is spent\n\t\t\t\t} else {\n\t\t\t\t\tlist = \"\";\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\n\t\t// Actual Callbacks object\n\t\tself = {\n\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\n\t\t\t\t\t// If we have memory from a past run, we should fire after adding\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfiringIndex = list.length - 1;\n\t\t\t\t\t\tqueue.push( memory );\n\t\t\t\t\t}\n\n\t\t\t\t\t( function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tif ( isFunction( arg ) ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && toType( arg ) !== \"string\" ) {\n\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} );\n\t\t\t\t\t} )( arguments );\n\n\t\t\t\t\tif ( memory && !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\tvar index;\n\t\t\t\t\twhile ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\tlist.splice( index, 1 );\n\n\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Check if a given callback is in the list.\n\t\t\t// If no argument is given, return whether or not list has callbacks attached.\n\t\t\thas: function( fn ) {\n\t\t\t\treturn fn ?\n\t\t\t\t\tjQuery.inArray( fn, list ) > -1 :\n\t\t\t\t\tlist.length > 0;\n\t\t\t},\n\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Disable .fire and .add\n\t\t\t// Abort any current/pending executions\n\t\t\t// Clear all callbacks and values\n\t\t\tdisable: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tlist = memory = \"\";\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\n\t\t\t// Disable .fire\n\t\t\t// Also disable .add unless we have memory (since it would have no effect)\n\t\t\t// Abort any pending executions\n\t\t\tlock: function() {\n\t\t\t\tlocked = queue = [];\n\t\t\t\tif ( !memory && !firing ) {\n\t\t\t\t\tlist = memory = \"\";\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tlocked: function() {\n\t\t\t\treturn !!locked;\n\t\t\t},\n\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\tif ( !locked ) {\n\t\t\t\t\targs = args || [];\n\t\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\t\tqueue.push( args );\n\t\t\t\t\tif ( !firing ) {\n\t\t\t\t\t\tfire();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\nreturn jQuery;\n} );\n"]},"metadata":{},"sourceType":"script"}