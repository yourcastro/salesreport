{"ast":null,"code":"/**\n * @hidden\n *\n * Render the svg <path> element.\n *\n * @param points (array) Represents the points coordinates as an array of tuples.\n * @param command (function) The command that is used (bezierCommand, lineCommand).\n *      @param point (array) [x,y] Represents the current point coordinates.\n *      @param i (integer) Represents the index of 'point' in the array 'a'.\n *      @param a (array) Represents the complete array of points coordinates.\n *      @output (string) a svg path command.\n * @output (string) a Svg <path> element\n */\nexport var svgPath = function (points, command) {\n  if (points.length === 0) {\n    return '';\n  } // build the d attributes by looping over the points\n\n\n  var d = points.reduce(function (acc, point, i, a) {\n    return i === 0 ? // if first point\n    \"M \" + point[0] + \",\" + point[1] : // else\n    acc + \" \" + command(point, i, a);\n  }, '');\n  return \"<path d=\\\"\" + d + \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"1\\\"/>\";\n};\n/**\n * @hidden\n *\n * Returns the properties of a line.\n *\n * @param pointA (array) [x,y] Represents the start point coordinates.\n * @param pointB (array) [x,y] Represents the end point coordinates.\n * @output (object) { length: (integer), angle: (integer) }\n */\n\nexport var line = function (pointA, pointB) {\n  var lengthX = pointB[0] - pointA[0];\n  var lengthY = pointB[1] - pointA[1];\n  return {\n    length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n    angle: Math.atan2(lengthY, lengthX)\n  };\n};\n/**\n * @hidden\n *\n * Create a function to calculate the position of the control point.\n *\n * @param lineCalc (function) Represents the line function.\n *      @param pointA (array) [x,y] Represents the start point coordinates.\n *      @param pointB (array) [x,y] Represents the end point coordinates.\n *      @output (object) { length: (integer), angle: (integer) }\n * @output (function) closure.\n *      @param current (array) [x, y] Represents the current point coordinates.\n *      @param previous (array) [x, y] Represents the previous point coordinates.\n *      @param next (array) [x, y] ]Represents the next point coordinates.\n *      @param reverse (boolean, optional) Sets the direction.\n *      @output (array) [x, y] coordinates of a control point.\n */\n\nexport var controlPoint = function (lineCalc) {\n  return function (current, previous, next, reverse) {\n    // when 'current' is the first or last point of the array\n    // 'previous' and 'next' are undefined \n    // replace with 'current'\n    var p = previous || current;\n    var n = next || current;\n    var smooth = 0.1; // properties of the line between previous and next \n\n    var l = lineCalc(p, n); // If is end-control-point, add PI to the angle to go backward\n\n    var angle = l.angle + (reverse ? Math.PI : 0);\n    var length = l.length * smooth; // The control point position is relative to the current point\n\n    var x = current[0] + Math.cos(angle) * length;\n    var y = current[1] + Math.sin(angle) * length;\n    return [x, y];\n  };\n};\n/**\n * @hidden\n *\n * Create a function to calculate a bezier curve command.\n *\n * @param controlPointCalc (function) Represents the controlPoint function.\n *      @param current (array) [x, y] Represents the current point coordinates.\n *      @param previous (array) [x, y] Represents the previous point coordinates.\n *      @param next (array) [x, y] ]Represents the next point coordinates.\n *      @param reverse (boolean, optional) Sets the direction.\n *      @output (array) [x, y] coordinates of a control point.\n * @output (function) closure.\n *      @param point (array) [x,y] Represents the current point coordinates.\n *      @param i (integer) Represents the index of 'point' in the array 'a'.\n *      @param a (array) Represents the complete array of points coordinates.\n *      @output (string) 'C x2,y2 x1,y1 x,y' Cubic bezier command.\n */\n\nexport var bezierCommand = function (controlPointCalc) {\n  return function (point, i, a) {\n    // start control point\n    var _a = controlPointCalc(a[i - 1], a[i - 2], point),\n        cpsX = _a[0],\n        cpsY = _a[1]; // end control point\n\n\n    var _b = controlPointCalc(point, a[i - 1], a[i + 1], true),\n        cpeX = _b[0],\n        cpeY = _b[1];\n\n    return \"C \" + cpsX + \",\" + cpsY + \" \" + cpeX + \",\" + cpeY + \" \" + point[0] + \",\" + point[1];\n  };\n};","map":{"version":3,"sources":["../../../../src/colors/utils/svg-calc.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @hidden\n *\n * Render the svg <path> element.\n *\n * @param points (array) Represents the points coordinates as an array of tuples.\n * @param command (function) The command that is used (bezierCommand, lineCommand).\n *      @param point (array) [x,y] Represents the current point coordinates.\n *      @param i (integer) Represents the index of 'point' in the array 'a'.\n *      @param a (array) Represents the complete array of points coordinates.\n *      @output (string) a svg path command.\n * @output (string) a Svg <path> element\n */\nexport var svgPath = function (points, command) {\n    if (points.length === 0) {\n        return '';\n    }\n    // build the d attributes by looping over the points\n    var d = points.reduce(function (acc, point, i, a) {\n        return i === 0 ?\n            // if first point\n            \"M \" + point[0] + \",\" + point[1] :\n            // else\n            acc + \" \" + command(point, i, a);\n    }, '');\n    return \"<path d=\\\"\" + d + \"\\\" fill=\\\"none\\\" stroke=\\\"white\\\" stroke-width=\\\"1\\\"/>\";\n};\n/**\n * @hidden\n *\n * Returns the properties of a line.\n *\n * @param pointA (array) [x,y] Represents the start point coordinates.\n * @param pointB (array) [x,y] Represents the end point coordinates.\n * @output (object) { length: (integer), angle: (integer) }\n */\nexport var line = function (pointA, pointB) {\n    var lengthX = pointB[0] - pointA[0];\n    var lengthY = pointB[1] - pointA[1];\n    return {\n        length: Math.sqrt(Math.pow(lengthX, 2) + Math.pow(lengthY, 2)),\n        angle: Math.atan2(lengthY, lengthX)\n    };\n};\n/**\n * @hidden\n *\n * Create a function to calculate the position of the control point.\n *\n * @param lineCalc (function) Represents the line function.\n *      @param pointA (array) [x,y] Represents the start point coordinates.\n *      @param pointB (array) [x,y] Represents the end point coordinates.\n *      @output (object) { length: (integer), angle: (integer) }\n * @output (function) closure.\n *      @param current (array) [x, y] Represents the current point coordinates.\n *      @param previous (array) [x, y] Represents the previous point coordinates.\n *      @param next (array) [x, y] ]Represents the next point coordinates.\n *      @param reverse (boolean, optional) Sets the direction.\n *      @output (array) [x, y] coordinates of a control point.\n */\nexport var controlPoint = function (lineCalc) {\n    return function (current, previous, next, reverse) {\n        // when 'current' is the first or last point of the array\n        // 'previous' and 'next' are undefined \n        // replace with 'current'\n        var p = previous || current;\n        var n = next || current;\n        var smooth = 0.1;\n        // properties of the line between previous and next \n        var l = lineCalc(p, n);\n        // If is end-control-point, add PI to the angle to go backward\n        var angle = l.angle + (reverse ? Math.PI : 0);\n        var length = l.length * smooth;\n        // The control point position is relative to the current point\n        var x = current[0] + Math.cos(angle) * length;\n        var y = current[1] + Math.sin(angle) * length;\n        return [x, y];\n    };\n};\n/**\n * @hidden\n *\n * Create a function to calculate a bezier curve command.\n *\n * @param controlPointCalc (function) Represents the controlPoint function.\n *      @param current (array) [x, y] Represents the current point coordinates.\n *      @param previous (array) [x, y] Represents the previous point coordinates.\n *      @param next (array) [x, y] ]Represents the next point coordinates.\n *      @param reverse (boolean, optional) Sets the direction.\n *      @output (array) [x, y] coordinates of a control point.\n * @output (function) closure.\n *      @param point (array) [x,y] Represents the current point coordinates.\n *      @param i (integer) Represents the index of 'point' in the array 'a'.\n *      @param a (array) Represents the complete array of points coordinates.\n *      @output (string) 'C x2,y2 x1,y1 x,y' Cubic bezier command.\n */\nexport var bezierCommand = function (controlPointCalc) { return function (point, i, a) {\n    // start control point\n    var _a = controlPointCalc(a[i - 1], a[i - 2], point), cpsX = _a[0], cpsY = _a[1];\n    // end control point\n    var _b = controlPointCalc(point, a[i - 1], a[i + 1], true), cpeX = _b[0], cpeY = _b[1];\n    return \"C \" + cpsX + \",\" + cpsY + \" \" + cpeX + \",\" + cpeY + \" \" + point[0] + \",\" + point[1];\n}; };\n//# sourceMappingURL=svg-calc.js.map"]},"metadata":{},"sourceType":"module"}