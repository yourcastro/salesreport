{"ast":null,"code":"/* eslint-disable no-multi-spaces, key-spacing, indent, camelcase, space-before-blocks, eqeqeq, brace-style */\n\n/* eslint-disable space-infix-ops, space-before-function-paren, array-bracket-spacing, object-curly-spacing */\n\n/* eslint-disable no-nested-ternary, max-params, default-case, no-else-return, no-empty, yoda */\n\n/* eslint-disable no-param-reassign, no-var, block-scoped-var */\nimport * as geo from \"../geometry\";\nimport * as PDF from \"../pdf\";\nimport { arabicToRoman, createPromise, measureText, mergeSort } from '../util';\nimport { parseColor as utils_parseColor, support, template as compileTemplate } from \"../common\";\nimport { Path, Text, Group, Image, Circle, LinearGradient } from \"../drawing\";\nimport { encodeBase64 } from \"../util\";\nvar browser = support.browser || {};\n/*\n\n  XXX: to test:\n\n  - cloneNodes function:\n    - drawing document containing canvas with page breaking\n    - drawing document with named radio <input>-s (should not clear selection)\n    - IE9/IE10 don't support el.dataset; do they copy user data?\n\n  - repeating table headers/footers on page breaking\n\n  - forceBreak, keepTogether\n\n  - avoidLinks\n\n */\n\n/* -----[ local vars ]----- */\n\nfunction slice(thing) {\n  return Array.prototype.slice.call(thing);\n}\n\nvar KENDO_PSEUDO_ELEMENT = \"KENDO-PSEUDO-ELEMENT\";\nvar IMAGE_CACHE = {};\nvar nodeInfo = {};\nnodeInfo._root = nodeInfo;\n/* -----[ Custom Text node to speed up rendering in PDF ]----- */\n\nvar inBrowser = typeof window !== 'undefined';\nvar microsoft = inBrowser ? browser.msie || browser.edge : false;\n\nvar TextRect = function (Text) {\n  function TextRect(str, rect, options) {\n    Text.call(this, str, rect.getOrigin(), options);\n    this._pdfRect = rect;\n  }\n\n  if (Text) TextRect.__proto__ = Text;\n  TextRect.prototype = Object.create(Text && Text.prototype);\n  TextRect.prototype.constructor = TextRect;\n\n  TextRect.prototype.rect = function rect() {\n    // this is the crux of it: we can avoid a call to\n    // measure(), which is what the base class does, since we\n    // already know the rect.  measure() is s-l-o-w.\n    return this._pdfRect;\n  };\n\n  TextRect.prototype.rawBBox = function rawBBox() {\n    // also let's avoid creating a new rectangle.\n    return this._pdfRect;\n  };\n\n  return TextRect;\n}(Text);\n\nfunction addClass(el, cls) {\n  if (el.classList) {\n    el.classList.add(cls);\n  } else {\n    el.className += \" \" + cls;\n  }\n}\n\nfunction removeClass(el, cls) {\n  if (el.classList) {\n    el.classList.remove(cls);\n  } else {\n    el.className = el.className.split(/\\s+/).reduce(function (a, word) {\n      if (word != cls) {\n        a.push(word);\n      }\n\n      return a;\n    }, []).join(\" \");\n  }\n}\n\nfunction setCSS(el, styles) {\n  Object.keys(styles).forEach(function (key) {\n    el.style[key] = styles[key];\n  });\n}\n\nvar matches = typeof Element !== \"undefined\" && Element.prototype && function (p) {\n  if (p.matches) {\n    return function (el, selector) {\n      return el.matches(selector);\n    };\n  }\n\n  if (p.webkitMatchesSelector) {\n    return function (el, selector) {\n      return el.webkitMatchesSelector(selector);\n    };\n  }\n\n  if (p.mozMatchesSelector) {\n    return function (el, selector) {\n      return el.mozMatchesSelector(selector);\n    };\n  }\n\n  if (p.msMatchesSelector) {\n    return function (el, selector) {\n      return el.msMatchesSelector(selector);\n    };\n  }\n\n  return function (s) {\n    return [].indexOf.call(document.querySelectorAll(s), this) !== -1;\n  };\n}(Element.prototype);\n\nfunction closest(el, selector) {\n  if (el.closest) {\n    return el.closest(selector);\n  } // IE: stringifying rather than simply comparing with `document`,\n  // which is not iframe-proof and fails in editor export â€”\n  // https://github.com/telerik/kendo/issues/6721\n\n\n  while (el && !/^\\[object (?:HTML)?Document\\]$/.test(String(el))) {\n    if (el.nodeType == 1\n    /* Element */\n    && matches(el, selector)) {\n      return el;\n    }\n\n    el = el.parentNode;\n  }\n} // clone nodes ourselves, so that we redraw <canvas> (DOM or\n// jQuery clone will not)\n\n\nvar cloneNodes = function ($) {\n  if ($) {\n    // if we have Kendo and jQuery, use this version as it will\n    // maintain proper links between cloned element and Kendo\n    // widgets (i.e. it clones jQuery data(), which isn't the same\n    // as element's data attributes).\n    // https://github.com/telerik/kendo-ui-core/issues/2750\n    return function cloneNodes(el) {\n      var clone = el.cloneNode(false);\n\n      if (el.nodeType == 1\n      /* Element */\n      ) {\n          var $el = $(el),\n              $clone = $(clone),\n              i;\n          var data = $el.data();\n\n          for (i in data) {\n            $clone.data(i, data[i]);\n          }\n\n          if (/^canvas$/i.test(el.tagName)) {\n            clone.getContext(\"2d\").drawImage(el, 0, 0);\n          } else if (/^(?:input|select|textarea|option)$/i.test(el.tagName)) {\n            // drop the name attributes so that we don't affect the selection of the\n            // original nodes (i.e. checked status of radio buttons) when we insert our copy\n            // into the DOM.  https://github.com/telerik/kendo/issues/5409\n            clone.removeAttribute(\"id\");\n            clone.removeAttribute(\"name\");\n\n            if (!/^textarea$/i.test(el.tagName)) {\n              clone.value = el.value;\n            }\n\n            clone.checked = el.checked;\n            clone.selected = el.selected;\n          }\n\n          for (i = el.firstChild; i; i = i.nextSibling) {\n            clone.appendChild(cloneNodes(i));\n          }\n        }\n\n      return clone;\n    };\n  } else {\n    // the no-jQuery version\n    return function cloneNodes(el) {\n      var clone = function dive(node) {\n        var clone = node.cloneNode(false);\n\n        if (node._kendoExportVisual) {\n          clone._kendoExportVisual = node._kendoExportVisual;\n        }\n\n        for (var i = node.firstChild; i; i = i.nextSibling) {\n          clone.appendChild(dive(i));\n        }\n\n        return clone;\n      }(el); // re-draw canvases - https://github.com/telerik/kendo/issues/4872\n\n\n      var canvases = el.querySelectorAll(\"canvas\");\n\n      if (canvases.length) {\n        slice(clone.querySelectorAll(\"canvas\")).forEach(function (canvas, i) {\n          canvas.getContext(\"2d\").drawImage(canvases[i], 0, 0);\n        });\n      } // remove \"name\" attributes from <input> elements -\n      // https://github.com/telerik/kendo/issues/5409\n\n\n      var orig = el.querySelectorAll(\"input, select, textarea, option\");\n      slice(clone.querySelectorAll(\"input, select, textarea, option\")).forEach(function (el, i) {\n        el.removeAttribute(\"id\");\n        el.removeAttribute(\"name\");\n\n        if (!/^textarea$/i.test(el.tagName)) {\n          el.value = orig[i].value;\n        }\n\n        el.checked = orig[i].checked;\n        el.selected = orig[i].selected;\n      });\n      return clone;\n    };\n  }\n}(typeof window !== \"undefined\" && window.kendo && window.kendo.jQuery);\n\nfunction getXY(thing) {\n  if (typeof thing == \"number\") {\n    return {\n      x: thing,\n      y: thing\n    };\n  }\n\n  if (Array.isArray(thing)) {\n    return {\n      x: thing[0],\n      y: thing[1]\n    };\n  }\n\n  return {\n    x: thing.x,\n    y: thing.y\n  };\n}\n\nfunction drawDOM(element, options) {\n  if (!options) {\n    options = {};\n  }\n\n  var promise = createPromise();\n\n  if (!element) {\n    return promise.reject(\"No element to export\");\n  }\n\n  if (typeof window.getComputedStyle != \"function\") {\n    throw new Error(\"window.getComputedStyle is missing.  You are using an unsupported browser, or running in IE8 compatibility mode.  Drawing HTML is supported in Chrome, Firefox, Safari and IE9+.\");\n  }\n\n  PDF.defineFont(getFontFaces(element.ownerDocument));\n  var scale = getXY(options.scale || 1);\n\n  function doOne(element) {\n    var group = new Group(); // translate to start of page\n\n    var pos = element.getBoundingClientRect();\n    setTransform(group, [scale.x, 0, 0, scale.y, -pos.left * scale.x, -pos.top * scale.y]);\n    nodeInfo._clipbox = false;\n    nodeInfo._matrix = geo.Matrix.unit();\n    nodeInfo._stackingContext = {\n      element: element,\n      group: group\n    };\n\n    if (options.avoidLinks === true) {\n      nodeInfo._avoidLinks = \"a\";\n    } else {\n      nodeInfo._avoidLinks = options.avoidLinks;\n    }\n\n    addClass(element, \"k-pdf-export\");\n    renderElement(element, group);\n    removeClass(element, \"k-pdf-export\");\n    return group;\n  }\n\n  cacheImages([element], function () {\n    var forceBreak = options && options.forcePageBreak;\n    var hasPaperSize = options && options.paperSize && options.paperSize != \"auto\";\n    var paperOptions = PDF.getPaperOptions(function (key, def) {\n      if (key == \"paperSize\") {\n        // PDF.getPaperOptions croaks on \"auto\", just pass dummy A4 as we might\n        // still be interested in margins.\n        return hasPaperSize ? options[key] : \"A4\";\n      }\n\n      return key in options ? options[key] : def;\n    });\n    var pageWidth = hasPaperSize && paperOptions.paperSize[0];\n    var pageHeight = hasPaperSize && paperOptions.paperSize[1];\n    var margin = options.margin && paperOptions.margin;\n    var hasMargin = Boolean(margin);\n\n    if (forceBreak || pageHeight) {\n      if (!margin) {\n        margin = {\n          left: 0,\n          top: 0,\n          right: 0,\n          bottom: 0\n        };\n      } // we want paper size and margin to be unaffected by\n      // scaling in the output, so we have to reverse-scale\n      // before our calculations begin.\n\n\n      if (pageWidth) {\n        pageWidth /= scale.x;\n      }\n\n      if (pageHeight) {\n        pageHeight /= scale.y;\n      }\n\n      margin.left /= scale.x;\n      margin.right /= scale.x;\n      margin.top /= scale.y;\n      margin.bottom /= scale.y;\n      var group = new Group({\n        pdf: {\n          multiPage: true,\n          paperSize: hasPaperSize ? paperOptions.paperSize : \"auto\",\n          _ignoreMargin: hasMargin // HACK!  see exportPDF in pdf/drawing.js\n\n        }\n      });\n      handlePageBreaks(function (x) {\n        if (options.progress) {\n          var canceled = false,\n              pageNum = 0;\n\n          (function next() {\n            if (pageNum < x.pages.length) {\n              var page = doOne(x.pages[pageNum]);\n              group.append(page);\n              options.progress({\n                page: page,\n                pageNum: ++pageNum,\n                totalPages: x.pages.length,\n                cancel: function () {\n                  canceled = true;\n                }\n              });\n\n              if (!canceled) {\n                setTimeout(next);\n              } else {\n                // XXX: should we also fail() the deferred object?\n                x.container.parentNode.removeChild(x.container);\n              }\n            } else {\n              x.container.parentNode.removeChild(x.container);\n              promise.resolve(group);\n            }\n          })();\n        } else {\n          x.pages.forEach(function (page) {\n            group.append(doOne(page));\n          });\n          x.container.parentNode.removeChild(x.container);\n          promise.resolve(group);\n        }\n      }, element, forceBreak, pageWidth ? pageWidth - margin.left - margin.right : null, pageHeight ? pageHeight - margin.top - margin.bottom : null, margin, options);\n    } else {\n      promise.resolve(doOne(element));\n    }\n  });\n\n  function makeTemplate(template) {\n    if (template != null) {\n      if (typeof template == \"string\") {\n        template = compileTemplate(template.replace(/^\\s+|\\s+$/g, \"\"));\n      }\n\n      if (typeof template == \"function\") {\n        return function (data) {\n          var el = template(data);\n\n          if (el && typeof el == \"string\") {\n            var div = document.createElement(\"div\");\n            div.innerHTML = el;\n            el = div.firstElementChild;\n          }\n\n          return el;\n        };\n      } // assumed DOM element\n\n\n      return function () {\n        return template.cloneNode(true);\n      };\n    }\n  }\n\n  function handlePageBreaks(callback, element, forceBreak, pageWidth, pageHeight, margin, options) {\n    var template = makeTemplate(options.template);\n    var doc = element.ownerDocument;\n    var pages = [];\n    var copy = options._destructive ? element : cloneNodes(element);\n    var container = doc.createElement(\"KENDO-PDF-DOCUMENT\");\n    var adjust = 0; // make sure <tfoot> elements are at the end (Grid widget\n    // places TFOOT before TBODY, tricking our algorithm to\n    // insert a page break right after the header).\n    // https://github.com/telerik/kendo/issues/4699\n\n    slice(copy.querySelectorAll(\"tfoot\")).forEach(function (tfoot) {\n      tfoot.parentNode.appendChild(tfoot);\n    }); // remember the index of each LI from an ordered list.\n    // we'll use it to reconstruct the proper numbering.\n\n    slice(copy.querySelectorAll(\"ol\")).forEach(function (ol) {\n      slice(ol.children).forEach(function (li, index) {\n        li.setAttribute(\"kendo-split-index\", index);\n      });\n    });\n    setCSS(container, {\n      display: \"block\",\n      position: \"absolute\",\n      boxSizing: \"content-box\",\n      left: \"-10000px\",\n      top: \"-10000px\"\n    });\n\n    if (pageWidth) {\n      // subtle: if we don't set the width *and* margins here, the layout in this\n      // container will be different from the one in our final page elements, and we'll\n      // split at the wrong places.\n      setCSS(container, {\n        width: pageWidth + \"px\",\n        paddingLeft: margin.left + \"px\",\n        paddingRight: margin.right + \"px\"\n      }); // when the first element has a margin-top (i.e. a <h1>) the page will be\n      // inadvertently enlarged by that number (the browser will report the container's\n      // bounding box top to start at the element's top, rather than including its\n      // margin).  Adding overflow: hidden seems to fix it.\n      //\n      // to understand the difference, try the following snippets in your browser:\n      //\n      // 1. <div style=\"background: yellow\">\n      //      <h1 style=\"margin: 3em\">Foo</h1>\n      //    </div>\n      //\n      // 2. <div style=\"background: yellow; overflow: hidden\">\n      //      <h1 style=\"margin: 3em\">Foo</h1>\n      //    </div>\n      //\n      // this detail is not important when automatic page breaking is not requested, hence\n      // doing it only if pageWidth is defined.\n\n      setCSS(copy, {\n        overflow: \"hidden\"\n      });\n    }\n\n    element.parentNode.insertBefore(container, element);\n    container.appendChild(copy); // With cache disabled, images will still have height zero until their `complete` attribute\n    // is true.  `whenImagesAreActuallyLoaded` will wait for it.\n\n    if (options.beforePageBreak) {\n      whenImagesAreActuallyLoaded([container], function () {\n        options.beforePageBreak(container, doPageBreak);\n      });\n    } else {\n      whenImagesAreActuallyLoaded([container], doPageBreak);\n    }\n\n    function doPageBreak() {\n      if (forceBreak != \"-\" || pageHeight) {\n        splitElement(copy);\n      }\n\n      {\n        var page = makePage();\n        copy.parentNode.insertBefore(page, copy);\n        page.appendChild(copy);\n      }\n\n      if (template) {\n        pages.forEach(function (page, i) {\n          var el = template({\n            element: page,\n            pageNum: i + 1,\n            totalPages: pages.length\n          });\n\n          if (el) {\n            page.appendChild(el);\n          }\n        });\n      }\n\n      cacheImages(pages, callback.bind(null, {\n        pages: pages,\n        container: container\n      }));\n    }\n\n    function keepTogether(el) {\n      if (options.keepTogether && matches(el, options.keepTogether) && el.offsetHeight <= pageHeight - adjust) {\n        return true;\n      }\n\n      var tag = el.tagName;\n\n      if (/^h[1-6]$/i.test(tag) && el.offsetHeight >= pageHeight - adjust) {\n        return false;\n      }\n\n      return el.getAttribute(\"data-kendo-chart\") || /^(?:img|tr|thead|th|tfoot|iframe|svg|object|canvas|input|textarea|select|video|h[1-6])/i.test(el.tagName);\n    }\n\n    function splitElement(element) {\n      if (element.tagName == \"TABLE\") {\n        setCSS(element, {\n          tableLayout: \"fixed\"\n        });\n      }\n\n      if (keepTogether(element)) {\n        return;\n      }\n\n      var style = getComputedStyle(element);\n      var bottomPadding = parseFloat(getPropertyValue(style, \"padding-bottom\"));\n      var bottomBorder = parseFloat(getPropertyValue(style, \"border-bottom-width\"));\n      var saveAdjust = adjust;\n      adjust += bottomPadding + bottomBorder;\n      var isFirst = true;\n\n      for (var el = element.firstChild; el; el = el.nextSibling) {\n        if (el.nodeType == 1\n        /* Element */\n        ) {\n            isFirst = false;\n\n            if (matches(el, forceBreak)) {\n              breakAtElement(el);\n              continue;\n            }\n\n            if (!pageHeight) {\n              // we're in \"manual breaks mode\"\n              splitElement(el);\n              continue;\n            }\n\n            if (!/^(?:static|relative)$/.test(getPropertyValue(getComputedStyle(el), \"position\"))) {\n              continue;\n            }\n\n            var fall = fallsOnMargin(el);\n\n            if (fall == 1) {\n              // element starts on next page, break before anyway.\n              breakAtElement(el);\n            } else if (fall) {\n              // elements ends up on next page, or possibly doesn't fit on a page at\n              // all.  break before it anyway if it's an <img> or <tr>, otherwise\n              // attempt to split.\n              if (keepTogether(el)) {\n                breakAtElement(el);\n              } else {\n                splitElement(el);\n              }\n            } else {\n              splitElement(el);\n            }\n          } else if (el.nodeType == 3\n        /* Text */\n        && pageHeight) {\n          splitText(el, isFirst);\n          isFirst = false;\n        }\n      }\n\n      adjust = saveAdjust;\n    }\n\n    function firstInParent(el) {\n      var p = el.parentNode,\n          first = p.firstChild;\n\n      if (el === first) {\n        return true;\n      }\n\n      if (el === p.children[0]) {\n        if (first.nodeType == 7\n        /* comment */\n        || first.nodeType == 8\n        /* processing instruction */\n        ) {\n            return true;\n          }\n\n        if (first.nodeType == 3\n        /* text */\n        ) {\n            // if whitespace only we can probably consider it's first\n            return !/\\S/.test(first.data);\n          }\n      }\n\n      return false;\n    }\n\n    function breakAtElement(el) {\n      if (el.nodeType == 1 && el !== copy && firstInParent(el)) {\n        return breakAtElement(el.parentNode);\n      }\n\n      var table, colgroup, thead, grid, gridHead;\n      table = closest(el, \"table\");\n      colgroup = table && table.querySelector(\"colgroup\");\n\n      if (options.repeatHeaders) {\n        thead = table && table.querySelector(\"thead\"); // If we break page in a Kendo Grid, repeat its header.  This ugly hack is\n        // necessary because a scrollable grid will keep the header in a separate\n        // <table> element from its content.\n        //\n        // XXX: This is likely to break as soon as the widget HTML is modified.\n\n        grid = closest(el, \".k-grid.k-widget\");\n\n        if (grid && grid.querySelector(\".k-auto-scrollable\")) {\n          gridHead = grid.querySelector(\".k-grid-header\");\n        }\n      }\n\n      var page = makePage();\n      var range = doc.createRange();\n      range.setStartBefore(copy);\n      range.setEndBefore(el);\n      page.appendChild(range.extractContents());\n      copy.parentNode.insertBefore(page, copy);\n      preventBulletOnListItem(el.parentNode);\n\n      if (table) {\n        table = closest(el, \"table\"); // that's the <table> on next page!\n\n        if (options.repeatHeaders && thead) {\n          table.insertBefore(thead.cloneNode(true), table.firstChild);\n        }\n\n        if (colgroup) {\n          table.insertBefore(colgroup.cloneNode(true), table.firstChild);\n        }\n      }\n\n      if (options.repeatHeaders && gridHead) {\n        grid = closest(el, \".k-grid.k-widget\");\n        grid.insertBefore(gridHead.cloneNode(true), grid.firstChild);\n      }\n    }\n\n    function makePage() {\n      var page = doc.createElement(\"KENDO-PDF-PAGE\");\n      setCSS(page, {\n        display: \"block\",\n        boxSizing: \"content-box\",\n        width: pageWidth ? pageWidth + \"px\" : \"auto\",\n        padding: margin.top + \"px \" + margin.right + \"px \" + margin.bottom + \"px \" + margin.left + \"px\",\n        // allow absolutely positioned elements to be relative to current page\n        position: \"relative\",\n        // without the following we might affect layout of subsequent pages\n        height: pageHeight ? pageHeight + \"px\" : \"auto\",\n        overflow: pageHeight || pageWidth ? \"hidden\" : \"visible\",\n        clear: \"both\"\n      }); // debug\n      // $(\"<div>\").css({\n      //     position  : \"absolute\",\n      //     left      : margin.left,\n      //     top       : margin.top,\n      //     width     : pageWidth,\n      //     height    : pageHeight,\n      //     boxSizing : \"border-box\",\n      //     background: \"rgba(255, 255, 0, 0.5)\"\n      //     //border    : \"1px solid red\"\n      // }).appendTo(page);\n\n      if (options && options.pageClassName) {\n        page.className = options.pageClassName;\n      }\n\n      pages.push(page);\n      return page;\n    }\n\n    function fallsOnMargin(thing) {\n      var box = thing.getBoundingClientRect();\n\n      if (box.width === 0 || box.height === 0) {\n        // I'd say an element with dimensions zero fits on current page.\n        return 0;\n      }\n\n      var top = copy.getBoundingClientRect().top;\n      var available = pageHeight - adjust;\n      return box.height > available ? 3 : box.top - top > available ? 1 : box.bottom - top > available ? 2 : 0;\n    }\n\n    function splitText(node, isFirst) {\n      if (!/\\S/.test(node.data)) {\n        return;\n      }\n\n      var len = node.data.length;\n      var range = doc.createRange();\n      range.selectNodeContents(node);\n      var fall = fallsOnMargin(range);\n\n      if (!fall) {\n        return; // the whole text fits on current page\n      }\n\n      var nextnode = node;\n\n      if (fall == 1) {\n        // starts on next page, break before anyway.\n        if (isFirst) {\n          // avoid leaving an empty <p>, <li>, etc. on previous page.\n          breakAtElement(node.parentNode);\n        } else {\n          breakAtElement(node);\n        }\n      } else {\n        (function findEOP(min, pos, max) {\n          range.setEnd(node, pos);\n\n          if (min == pos || pos == max) {\n            return pos;\n          }\n\n          if (fallsOnMargin(range)) {\n            return findEOP(min, min + pos >> 1, pos);\n          } else {\n            return findEOP(pos, pos + max >> 1, max);\n          }\n        })(0, len >> 1, len);\n\n        if (!/\\S/.test(range.toString()) && isFirst) {\n          // avoid leaving an empty <p>, <li>, etc. on previous page.\n          breakAtElement(node.parentNode);\n        } else {\n          // This is only needed for IE, but it feels cleaner to do it anyway.  Without\n          // it, IE will truncate a very long text (playground/pdf-long-text-2.html).\n          nextnode = node.splitText(range.endOffset);\n          var page = makePage();\n          range.setStartBefore(copy);\n          page.appendChild(range.extractContents());\n          copy.parentNode.insertBefore(page, copy);\n          preventBulletOnListItem(nextnode.parentNode);\n        }\n      }\n\n      splitText(nextnode);\n    }\n\n    function preventBulletOnListItem(el) {\n      // set a hint on continued LI elements, to tell the\n      // renderer not to draw the bullet again.\n      // https://github.com/telerik/kendo-ui-core/issues/2732\n      var li = closest(el, \"li\");\n\n      if (li) {\n        li.setAttribute(\"kendo-no-bullet\", \"1\");\n        preventBulletOnListItem(li.parentNode);\n      }\n    }\n  }\n\n  return promise;\n} // This is needed for the Spreadsheet print functionality.  Since\n// there we only need to draw text, this cuts through the ceremony\n// of drawDOM/renderElement and renders the text node directly.\n\n\nfunction drawText(element) {\n  var group = new Group();\n  nodeInfo._clipbox = false;\n  nodeInfo._matrix = geo.Matrix.unit();\n  nodeInfo._stackingContext = {\n    element: element,\n    group: group\n  };\n  pushNodeInfo(element, getComputedStyle(element), group);\n\n  if (element.firstChild.nodeType == 3\n  /* Text */\n  ) {\n      // avoid the penalty of renderElement\n      renderText(element, element.firstChild, group);\n    } else {\n    _renderElement(element, group);\n  }\n\n  popNodeInfo();\n  return group;\n}\n\nvar parseBackgroundImage = function () {\n  var tok_linear_gradient = /^((-webkit-|-moz-|-o-|-ms-)?linear-gradient\\s*)\\(/; //var tok_radial_gradient  = /^((-webkit-|-moz-|-o-|-ms-)?radial-gradient\\s*)\\(/;\n\n  var tok_percent = /^([-0-9.]+%)/;\n  var tok_length = /^([-0-9.]+px)/;\n  var tok_keyword = /^(left|right|top|bottom|to|center)\\W/;\n  var tok_angle = /^([-0-9.]+(deg|grad|rad|turn)|0)/;\n  var tok_whitespace = /^(\\s+)/;\n  var tok_popen = /^(\\()/;\n  var tok_pclose = /^(\\))/;\n  var tok_comma = /^(,)/;\n  var tok_url = /^(url)\\(/;\n  var tok_content = /^(.*?)\\)/;\n  var cache1 = {},\n      cache2 = {};\n\n  function parse(input) {\n    var orig = input;\n\n    if (hasOwnProperty(cache1, orig)) {\n      return cache1[orig];\n    }\n\n    function skip_ws() {\n      var m = tok_whitespace.exec(input);\n\n      if (m) {\n        input = input.substr(m[1].length);\n      }\n    }\n\n    function read(token) {\n      skip_ws();\n      var m = token.exec(input);\n\n      if (m) {\n        input = input.substr(m[1].length);\n        return m[1];\n      }\n    }\n\n    function read_stop() {\n      var color = utils_parseColor(input, true);\n      var length, percent;\n\n      if (color) {\n        var match = /^#[0-9a-f]+/i.exec(input) || /^rgba?\\(.*?\\)/i.exec(input) || /^..*?\\b/.exec(input); // maybe named color\n\n        input = input.substr(match[0].length);\n        color = color.toRGB();\n\n        if (!(length = read(tok_length))) {\n          percent = read(tok_percent);\n        }\n\n        return {\n          color: color,\n          length: length,\n          percent: percent\n        };\n      }\n    }\n\n    function read_linear_gradient(propName) {\n      var angle;\n      var to1, to2;\n      var stops = [];\n      var reverse = false;\n\n      if (read(tok_popen)) {\n        // 1. [ <angle> || to <side-or-corner>, ]?\n        angle = read(tok_angle);\n\n        if (angle == \"0\") {\n          angle = \"0deg\"; // Edge\n        }\n\n        if (angle) {\n          angle = parseAngle(angle);\n          read(tok_comma);\n        } else {\n          to1 = read(tok_keyword);\n\n          if (to1 == \"to\") {\n            to1 = read(tok_keyword);\n          } else if (to1 && /^-/.test(propName)) {\n            reverse = true;\n          }\n\n          to2 = read(tok_keyword);\n          read(tok_comma);\n        }\n\n        if (/-moz-/.test(propName) && angle == null && to1 == null) {\n          var x = read(tok_percent),\n              y = read(tok_percent);\n          reverse = true;\n\n          if (x == \"0%\") {\n            to1 = \"left\";\n          } else if (x == \"100%\") {\n            to1 = \"right\";\n          }\n\n          if (y == \"0%\") {\n            to2 = \"top\";\n          } else if (y == \"100%\") {\n            to2 = \"bottom\";\n          }\n\n          read(tok_comma);\n        } // 2. color stops\n\n\n        while (input && !read(tok_pclose)) {\n          var stop = read_stop();\n\n          if (!stop) {\n            break;\n          }\n\n          stops.push(stop);\n          read(tok_comma);\n        }\n\n        return {\n          type: \"linear\",\n          angle: angle,\n          to: to1 && to2 ? to1 + \" \" + to2 : to1 ? to1 : to2 ? to2 : null,\n          stops: stops,\n          reverse: reverse\n        };\n      }\n    }\n\n    function read_url() {\n      if (read(tok_popen)) {\n        var url = read(tok_content);\n        url = url.replace(/^['\"]+|[\"']+$/g, \"\");\n        read(tok_pclose);\n        return {\n          type: \"url\",\n          url: url\n        };\n      }\n    }\n\n    var tok;\n\n    if (tok = read(tok_linear_gradient)) {\n      tok = read_linear_gradient(tok);\n    } else if (tok = read(tok_url)) {\n      tok = read_url();\n    }\n\n    return cache1[orig] = tok || {\n      type: \"none\"\n    };\n  }\n\n  return function (input) {\n    if (hasOwnProperty(cache2, input)) {\n      return cache2[input];\n    }\n\n    return cache2[input] = splitProperty(input).map(parse);\n  };\n}();\n\nvar splitProperty = function () {\n  var cache = {};\n  return function (input, separator) {\n    if (!separator) {\n      separator = /^\\s*,\\s*/;\n    }\n\n    var cacheKey = input + separator;\n\n    if (hasOwnProperty(cache, cacheKey)) {\n      return cache[cacheKey];\n    }\n\n    var ret = [];\n    var last = 0,\n        pos = 0;\n    var in_paren = 0;\n    var in_string = false;\n    var m;\n\n    function looking_at(rx) {\n      return m = rx.exec(input.substr(pos));\n    }\n\n    function trim(str) {\n      return str.replace(/^\\s+|\\s+$/g, \"\");\n    }\n\n    while (pos < input.length) {\n      if (!in_string && looking_at(/^[\\(\\[\\{]/)) {\n        in_paren++;\n        pos++;\n      } else if (!in_string && looking_at(/^[\\)\\]\\}]/)) {\n        in_paren--;\n        pos++;\n      } else if (!in_string && looking_at(/^[\\\"\\']/)) {\n        in_string = m[0];\n        pos++;\n      } else if (in_string == \"'\" && looking_at(/^\\\\\\'/)) {\n        pos += 2;\n      } else if (in_string == '\"' && looking_at(/^\\\\\\\"/)) {\n        pos += 2;\n      } else if (in_string == \"'\" && looking_at(/^\\'/)) {\n        in_string = false;\n        pos++;\n      } else if (in_string == '\"' && looking_at(/^\\\"/)) {\n        in_string = false;\n        pos++;\n      } else if (looking_at(separator)) {\n        if (!in_string && !in_paren && pos > last) {\n          ret.push(trim(input.substring(last, pos)));\n          last = pos + m[0].length;\n        }\n\n        pos += m[0].length;\n      } else {\n        pos++;\n      }\n    }\n\n    if (last < pos) {\n      ret.push(trim(input.substring(last, pos)));\n    }\n\n    return cache[cacheKey] = ret;\n  };\n}();\n\nvar getFontURL = function (cache) {\n  return function (el) {\n    // XXX: for IE we get here the whole cssText of the rule,\n    // because the computedStyle.src is empty.  Next time we need\n    // to fix these regexps we better write a CSS parser. :-\\\n    var url = cache[el];\n\n    if (!url) {\n      var m;\n\n      if (m = /url\\((['\"]?)([^'\")]*?)\\1\\)\\s+format\\((['\"]?)truetype\\3\\)/.exec(el)) {\n        url = cache[el] = m[2];\n      } else if (m = /url\\((['\"]?)([^'\")]*?\\.ttf)\\1\\)/.exec(el)) {\n        url = cache[el] = m[2];\n      }\n    }\n\n    return url;\n  };\n}(Object.create(null));\n\nvar getFontHeight = function (cache) {\n  return function (font) {\n    var height = cache[font];\n\n    if (height == null) {\n      height = cache[font] = measureText(\"Mapq\", {\n        font: font\n      }).height;\n    }\n\n    return height;\n  };\n}(Object.create(null));\n\nfunction getFontFaces(doc) {\n  if (doc == null) {\n    doc = document;\n  }\n\n  var result = {};\n\n  for (var i = 0; i < doc.styleSheets.length; ++i) {\n    doStylesheet(doc.styleSheets[i]);\n  }\n\n  return result;\n\n  function doStylesheet(ss) {\n    if (ss) {\n      var rules = null;\n\n      try {\n        rules = ss.cssRules;\n      } catch (ex) {}\n\n      if (rules) {\n        addRules(ss, rules);\n      }\n    }\n  }\n\n  function findFonts(rule) {\n    var src = getPropertyValue(rule.style, \"src\");\n\n    if (src) {\n      return splitProperty(src).reduce(function (a, el) {\n        var font = getFontURL(el);\n\n        if (font) {\n          a.push(font);\n        }\n\n        return a;\n      }, []);\n    } else {\n      // Internet Explorer\n      // XXX: this is gross.  should work though for valid CSS.\n      var font = getFontURL(rule.cssText);\n      return font ? [font] : [];\n    }\n  }\n\n  function addRules(styleSheet, rules) {\n    for (var i = 0; i < rules.length; ++i) {\n      var r = rules[i];\n\n      switch (r.type) {\n        case 3:\n          // CSSImportRule\n          doStylesheet(r.styleSheet);\n          break;\n\n        case 5:\n          // CSSFontFaceRule\n          var style = r.style;\n          var family = splitProperty(getPropertyValue(style, \"font-family\"));\n          var bold = /^([56789]00|bold)$/i.test(getPropertyValue(style, \"font-weight\"));\n          var italic = \"italic\" == getPropertyValue(style, \"font-style\");\n          var src = findFonts(r);\n\n          if (src.length > 0) {\n            addRule(styleSheet, family, bold, italic, src[0]);\n          }\n\n      }\n    }\n  }\n\n  function addRule(styleSheet, names, bold, italic, url) {\n    // We get full resolved absolute URLs in Chrome, but sadly\n    // not in Firefox.\n    if (!/^data:/i.test(url)) {\n      if (!(/^[^\\/:]+:\\/\\//.test(url) || /^\\//.test(url))) {\n        url = String(styleSheet.href).replace(/[^\\/]*$/, \"\") + url;\n      }\n    }\n\n    names.forEach(function (name) {\n      name = name.replace(/^(['\"]?)(.*?)\\1$/, \"$2\"); // it's quoted\n\n      if (bold) {\n        name += \"|bold\";\n      }\n\n      if (italic) {\n        name += \"|italic\";\n      }\n\n      result[name] = url;\n    });\n  }\n}\n\nfunction hasOwnProperty(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nfunction getCounter(name) {\n  name = \"_counter_\" + name;\n  return nodeInfo[name];\n}\n\nfunction getAllCounters(name) {\n  var values = [],\n      p = nodeInfo;\n  name = \"_counter_\" + name;\n\n  while (p) {\n    if (hasOwnProperty(p, name)) {\n      values.push(p[name]);\n    }\n\n    p = Object.getPrototypeOf(p);\n  }\n\n  return values.reverse();\n}\n\nfunction incCounter(name, inc) {\n  var p = nodeInfo;\n  name = \"_counter_\" + name;\n\n  while (p && !hasOwnProperty(p, name)) {\n    p = Object.getPrototypeOf(p);\n  }\n\n  if (!p) {\n    p = nodeInfo._root;\n  }\n\n  p[name] = (p[name] || 0) + (inc == null ? 1 : inc);\n}\n\nfunction resetCounter(name, val) {\n  name = \"_counter_\" + name;\n  nodeInfo[name] = val == null ? 0 : val;\n}\n\nfunction doCounters(a, f, def) {\n  for (var i = 0; i < a.length;) {\n    var name = a[i++];\n    var val = parseFloat(a[i]);\n\n    if (isNaN(val)) {\n      f(name, def);\n    } else {\n      f(name, val);\n      ++i;\n    }\n  }\n}\n\nfunction updateCounters(style) {\n  var counterReset = getPropertyValue(style, \"counter-reset\");\n\n  if (counterReset) {\n    doCounters(splitProperty(counterReset, /^\\s+/), resetCounter, 0);\n  }\n\n  var counterIncrement = getPropertyValue(style, \"counter-increment\");\n\n  if (counterIncrement) {\n    doCounters(splitProperty(counterIncrement, /^\\s+/), incCounter, 1);\n  }\n}\n\nfunction parseColor(str, css) {\n  var color = utils_parseColor(str, true);\n\n  if (color) {\n    color = color.toRGB();\n\n    if (css) {\n      color = color.toCssRgba();\n    } else if (color.a === 0) {\n      color = null;\n    }\n  }\n\n  return color;\n}\n\nfunction whenImagesAreActuallyLoaded(elements, callback) {\n  var pending = 0;\n  elements.forEach(function (el) {\n    var images = el.querySelectorAll(\"img\");\n\n    for (var i = 0; i < images.length; ++i) {\n      var img = images[i];\n\n      if (!img.complete) {\n        pending++;\n        img.onload = img.onerror = next;\n      }\n    }\n  });\n\n  if (!pending) {\n    next();\n  }\n\n  function next() {\n    if (--pending <= 0) {\n      callback();\n    }\n  }\n}\n\nfunction cacheImages(elements, callback) {\n  var urls = [];\n\n  function add(url) {\n    if (!IMAGE_CACHE[url]) {\n      IMAGE_CACHE[url] = true;\n      urls.push(url);\n    }\n  }\n\n  elements.forEach(function dive(element) {\n    if (/^img$/i.test(element.tagName)) {\n      add(element.src);\n    }\n\n    parseBackgroundImage(getPropertyValue(getComputedStyle(element), \"background-image\")).forEach(function (bg) {\n      if (bg.type == \"url\") {\n        add(bg.url);\n      }\n    });\n\n    if (element.children) {\n      slice(element.children).forEach(dive);\n    }\n  });\n  var count = urls.length;\n\n  function next() {\n    if (--count <= 0) {\n      // Even though we cached them, they simply won't be available immediately in the newly\n      // created DOM.  Previously we'd allow a 10ms timeout, but that's arbitrary and clearly\n      // not working in all cases (https://github.com/telerik/kendo/issues/5399), so this\n      // function will wait for their .complete attribute.\n      whenImagesAreActuallyLoaded(elements, callback);\n    }\n  }\n\n  if (count === 0) {\n    next();\n  }\n\n  urls.forEach(function (url) {\n    var img = IMAGE_CACHE[url] = new window.Image();\n\n    if (!/^data:/i.test(url)) {\n      img.crossOrigin = \"Anonymous\";\n    }\n\n    img.src = url;\n\n    if (img.complete) {\n      next();\n    } else {\n      img.onload = next;\n\n      img.onerror = function () {\n        IMAGE_CACHE[url] = null;\n        next();\n      };\n    }\n  });\n}\n\nfunction alphaNumeral(n) {\n  var result = \"\";\n\n  do {\n    var r = n % 26;\n    result = String.fromCharCode(97 + r) + result;\n    n = Math.floor(n / 26);\n  } while (n > 0);\n\n  return result;\n}\n\nfunction pushNodeInfo(element, style, group) {\n  nodeInfo = Object.create(nodeInfo);\n  nodeInfo[element.tagName.toLowerCase()] = {\n    element: element,\n    style: style\n  };\n  var decoration = getPropertyValue(style, \"text-decoration\");\n\n  if (decoration && decoration != \"none\") {\n    var color = getPropertyValue(style, \"color\");\n    decoration.split(/\\s+/g).forEach(function (name) {\n      if (!nodeInfo[name]) {\n        nodeInfo[name] = color;\n      }\n    });\n  }\n\n  if (createsStackingContext(style)) {\n    nodeInfo._stackingContext = {\n      element: element,\n      group: group\n    };\n  }\n}\n\nfunction popNodeInfo() {\n  nodeInfo = Object.getPrototypeOf(nodeInfo);\n}\n\nfunction updateClipbox(path) {\n  if (nodeInfo._clipbox != null) {\n    var box = path.bbox(nodeInfo._matrix);\n\n    if (nodeInfo._clipbox) {\n      nodeInfo._clipbox = geo.Rect.intersect(nodeInfo._clipbox, box);\n    } else {\n      nodeInfo._clipbox = box;\n    }\n  }\n}\n\nfunction emptyClipbox() {\n  var cb = nodeInfo._clipbox;\n\n  if (cb == null) {\n    return true;\n  }\n\n  if (cb) {\n    return cb.width() === 0 || cb.height() === 0;\n  }\n}\n\nfunction createsStackingContext(style) {\n  function prop(name) {\n    return getPropertyValue(style, name);\n  }\n\n  if (prop(\"transform\") != \"none\" || prop(\"position\") != \"static\" || prop(\"z-index\") != \"auto\" || prop(\"opacity\") < 1) {\n    return true;\n  }\n}\n\nfunction getComputedStyle(element, pseudoElt) {\n  return window.getComputedStyle(element, pseudoElt || null);\n}\n\nfunction getPropertyValue(style, prop, defa) {\n  var val = style.getPropertyValue(prop);\n\n  if (val == null || val === \"\") {\n    if (browser.webkit) {\n      val = style.getPropertyValue(\"-webkit-\" + prop);\n    } else if (browser.mozilla) {\n      val = style.getPropertyValue(\"-moz-\" + prop);\n    } else if (browser.opera) {\n      val = style.getPropertyValue(\"-o-\" + prop);\n    } else if (microsoft) {\n      val = style.getPropertyValue(\"-ms-\" + prop);\n    }\n  }\n\n  if (arguments.length > 2 && (val == null || val === \"\")) {\n    return defa;\n  } else {\n    return val;\n  }\n}\n\nfunction pleaseSetPropertyValue(style, prop, value, important) {\n  style.setProperty(prop, value, important);\n\n  if (browser.webkit) {\n    style.setProperty(\"-webkit-\" + prop, value, important);\n  } else if (browser.mozilla) {\n    style.setProperty(\"-moz-\" + prop, value, important);\n  } else if (browser.opera) {\n    style.setProperty(\"-o-\" + prop, value, important);\n  } else if (microsoft) {\n    style.setProperty(\"-ms-\" + prop, value, important);\n    prop = \"ms\" + prop.replace(/(^|-)([a-z])/g, function (s, p1, p2) {\n      return p1 + p2.toUpperCase();\n    });\n    style[prop] = value;\n  }\n}\n\nfunction getBorder(style, side) {\n  side = \"border-\" + side;\n  return {\n    width: parseFloat(getPropertyValue(style, side + \"-width\")),\n    style: getPropertyValue(style, side + \"-style\"),\n    color: parseColor(getPropertyValue(style, side + \"-color\"), true)\n  };\n}\n\nfunction saveStyle(element, func) {\n  var prev = element.style.cssText;\n  var result = func();\n  element.style.cssText = prev;\n  return result;\n}\n\nfunction getBorderRadius(style, side) {\n  var r = getPropertyValue(style, \"border-\" + side + \"-radius\").split(/\\s+/g).map(parseFloat);\n\n  if (r.length == 1) {\n    r.push(r[0]);\n  }\n\n  return sanitizeRadius({\n    x: r[0],\n    y: r[1]\n  });\n}\n\nfunction getContentBox(element) {\n  var box = element.getBoundingClientRect();\n  box = innerBox(box, \"border-*-width\", element);\n  box = innerBox(box, \"padding-*\", element);\n  return box;\n}\n\nfunction innerBox(box, prop, element) {\n  var style, wt, wr, wb, wl;\n\n  if (typeof prop == \"string\") {\n    style = getComputedStyle(element);\n    wt = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"top\")));\n    wr = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"right\")));\n    wb = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"bottom\")));\n    wl = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"left\")));\n  } else if (typeof prop == \"number\") {\n    wt = wr = wb = wl = prop;\n  }\n\n  return {\n    top: box.top + wt,\n    right: box.right - wr,\n    bottom: box.bottom - wb,\n    left: box.left + wl,\n    width: box.right - box.left - wr - wl,\n    height: box.bottom - box.top - wb - wt\n  };\n}\n\nfunction getTransform(style) {\n  var transform = getPropertyValue(style, \"transform\");\n\n  if (transform == \"none\") {\n    return null;\n  }\n\n  var matrix = /^\\s*matrix\\(\\s*(.*?)\\s*\\)\\s*$/.exec(transform);\n\n  if (matrix) {\n    var origin = getPropertyValue(style, \"transform-origin\");\n    matrix = matrix[1].split(/\\s*,\\s*/g).map(parseFloat);\n    origin = origin.split(/\\s+/g).map(parseFloat);\n    return {\n      matrix: matrix,\n      origin: origin\n    };\n  }\n}\n\nfunction radiansToDegrees(radians) {\n  return 180 * radians / Math.PI % 360;\n}\n\nfunction parseAngle(angle) {\n  var num = parseFloat(angle);\n\n  if (/grad$/.test(angle)) {\n    return Math.PI * num / 200;\n  } else if (/rad$/.test(angle)) {\n    return num;\n  } else if (/turn$/.test(angle)) {\n    return Math.PI * num * 2;\n  } else if (/deg$/.test(angle)) {\n    return Math.PI * num / 180;\n  }\n}\n\nfunction setTransform(shape, m) {\n  m = new geo.Matrix(m[0], m[1], m[2], m[3], m[4], m[5]);\n  shape.transform(m);\n  return m;\n}\n\nfunction setClipping(shape, clipPath) {\n  shape.clip(clipPath);\n}\n\nfunction addArcToPath(path, x, y, options) {\n  var points = new geo.Arc([x, y], options).curvePoints(),\n      i = 1;\n\n  while (i < points.length) {\n    path.curveTo(points[i++], points[i++], points[i++]);\n  }\n}\n\nfunction sanitizeRadius(r) {\n  if (r.x <= 0 || r.y <= 0) {\n    r.x = r.y = 0;\n  }\n\n  return r;\n}\n\nfunction adjustBorderRadiusForBox(box, rTL, rTR, rBR, rBL) {\n  // adjust border radiuses such that the sum of adjacent\n  // radiuses is not bigger than the length of the side.\n  // seems the correct algorithm is variant (3) from here:\n  // http://www.w3.org/Style/CSS/Tracker/issues/29?changelog\n  var tl_x = Math.max(0, rTL.x),\n      tl_y = Math.max(0, rTL.y);\n  var tr_x = Math.max(0, rTR.x),\n      tr_y = Math.max(0, rTR.y);\n  var br_x = Math.max(0, rBR.x),\n      br_y = Math.max(0, rBR.y);\n  var bl_x = Math.max(0, rBL.x),\n      bl_y = Math.max(0, rBL.y);\n  var f = Math.min(box.width / (tl_x + tr_x), box.height / (tr_y + br_y), box.width / (br_x + bl_x), box.height / (bl_y + tl_y));\n\n  if (f < 1) {\n    tl_x *= f;\n    tl_y *= f;\n    tr_x *= f;\n    tr_y *= f;\n    br_x *= f;\n    br_y *= f;\n    bl_x *= f;\n    bl_y *= f;\n  }\n\n  return {\n    tl: {\n      x: tl_x,\n      y: tl_y\n    },\n    tr: {\n      x: tr_x,\n      y: tr_y\n    },\n    br: {\n      x: br_x,\n      y: br_y\n    },\n    bl: {\n      x: bl_x,\n      y: bl_y\n    }\n  };\n}\n\nfunction elementRoundBox(element, box, type) {\n  var style = getComputedStyle(element);\n  var rTL = getBorderRadius(style, \"top-left\");\n  var rTR = getBorderRadius(style, \"top-right\");\n  var rBL = getBorderRadius(style, \"bottom-left\");\n  var rBR = getBorderRadius(style, \"bottom-right\");\n\n  if (type == \"padding\" || type == \"content\") {\n    var bt = getBorder(style, \"top\");\n    var br = getBorder(style, \"right\");\n    var bb = getBorder(style, \"bottom\");\n    var bl = getBorder(style, \"left\");\n    rTL.x -= bl.width;\n    rTL.y -= bt.width;\n    rTR.x -= br.width;\n    rTR.y -= bt.width;\n    rBR.x -= br.width;\n    rBR.y -= bb.width;\n    rBL.x -= bl.width;\n    rBL.y -= bb.width;\n\n    if (type == \"content\") {\n      var pt = parseFloat(getPropertyValue(style, \"padding-top\"));\n      var pr = parseFloat(getPropertyValue(style, \"padding-right\"));\n      var pb = parseFloat(getPropertyValue(style, \"padding-bottom\"));\n      var pl = parseFloat(getPropertyValue(style, \"padding-left\"));\n      rTL.x -= pl;\n      rTL.y -= pt;\n      rTR.x -= pr;\n      rTR.y -= pt;\n      rBR.x -= pr;\n      rBR.y -= pb;\n      rBL.x -= pl;\n      rBL.y -= pb;\n    }\n  }\n\n  if (typeof type == \"number\") {\n    rTL.x -= type;\n    rTL.y -= type;\n    rTR.x -= type;\n    rTR.y -= type;\n    rBR.x -= type;\n    rBR.y -= type;\n    rBL.x -= type;\n    rBL.y -= type;\n  }\n\n  return roundBox(box, rTL, rTR, rBR, rBL);\n} // Create a drawing.Path for a rounded rectangle.  Receives the\n// bounding box and the border-radiuses in CSS order (top-left,\n// top-right, bottom-right, bottom-left).  The radiuses must be\n// objects containing x (horiz. radius) and y (vertical radius).\n\n\nfunction roundBox(box, rTL0, rTR0, rBR0, rBL0) {\n  var tmp = adjustBorderRadiusForBox(box, rTL0, rTR0, rBR0, rBL0);\n  var rTL = tmp.tl;\n  var rTR = tmp.tr;\n  var rBR = tmp.br;\n  var rBL = tmp.bl;\n  var path = new Path({\n    fill: null,\n    stroke: null\n  });\n  path.moveTo(box.left, box.top + rTL.y);\n\n  if (rTL.x) {\n    addArcToPath(path, box.left + rTL.x, box.top + rTL.y, {\n      startAngle: -180,\n      endAngle: -90,\n      radiusX: rTL.x,\n      radiusY: rTL.y\n    });\n  }\n\n  path.lineTo(box.right - rTR.x, box.top);\n\n  if (rTR.x) {\n    addArcToPath(path, box.right - rTR.x, box.top + rTR.y, {\n      startAngle: -90,\n      endAngle: 0,\n      radiusX: rTR.x,\n      radiusY: rTR.y\n    });\n  }\n\n  path.lineTo(box.right, box.bottom - rBR.y);\n\n  if (rBR.x) {\n    addArcToPath(path, box.right - rBR.x, box.bottom - rBR.y, {\n      startAngle: 0,\n      endAngle: 90,\n      radiusX: rBR.x,\n      radiusY: rBR.y\n    });\n  }\n\n  path.lineTo(box.left + rBL.x, box.bottom);\n\n  if (rBL.x) {\n    addArcToPath(path, box.left + rBL.x, box.bottom - rBL.y, {\n      startAngle: 90,\n      endAngle: 180,\n      radiusX: rBL.x,\n      radiusY: rBL.y\n    });\n  }\n\n  return path.close();\n}\n\nfunction formatCounter(val, style) {\n  var str = String(parseFloat(val));\n\n  switch (style) {\n    case \"decimal-leading-zero\":\n      if (str.length < 2) {\n        str = \"0\" + str;\n      }\n\n      return str;\n\n    case \"lower-roman\":\n      return arabicToRoman(val).toLowerCase();\n\n    case \"upper-roman\":\n      return arabicToRoman(val).toUpperCase();\n\n    case \"lower-latin\":\n    case \"lower-alpha\":\n      return alphaNumeral(val - 1);\n\n    case \"upper-latin\":\n    case \"upper-alpha\":\n      return alphaNumeral(val - 1).toUpperCase();\n\n    default:\n      return str;\n  }\n}\n\nfunction evalPseudoElementContent(element, content) {\n  function displayCounter(name, style, separator) {\n    if (!separator) {\n      return formatCounter(getCounter(name) || 0, style);\n    }\n\n    separator = separator.replace(/^\\s*([\"'])(.*)\\1\\s*$/, \"$2\");\n    return getAllCounters(name).map(function (val) {\n      return formatCounter(val, style);\n    }).join(separator);\n  }\n\n  var a = splitProperty(content, /^\\s+/);\n  var result = [],\n      m;\n  a.forEach(function (el) {\n    var tmp;\n\n    if (m = /^\\s*([\"'])(.*)\\1\\s*$/.exec(el)) {\n      result.push(m[2].replace(/\\\\([0-9a-f]{4})/gi, function (s, p) {\n        return String.fromCharCode(parseInt(p, 16));\n      }));\n    } else if (m = /^\\s*counter\\((.*?)\\)\\s*$/.exec(el)) {\n      tmp = splitProperty(m[1]);\n      result.push(displayCounter(tmp[0], tmp[1]));\n    } else if (m = /^\\s*counters\\((.*?)\\)\\s*$/.exec(el)) {\n      tmp = splitProperty(m[1]);\n      result.push(displayCounter(tmp[0], tmp[2], tmp[1]));\n    } else if (m = /^\\s*attr\\((.*?)\\)\\s*$/.exec(el)) {\n      result.push(element.getAttribute(m[1]) || \"\");\n    } else {\n      result.push(el);\n    }\n  });\n  return result.join(\"\");\n}\n\nfunction getCssText(style) {\n  if (style.cssText) {\n    return style.cssText;\n  } // Status: NEW.  Report year: 2002.  Current year: 2014.\n  // Nice played, Mozillians.\n  // https://bugzilla.mozilla.org/show_bug.cgi?id=137687\n\n\n  var result = [];\n\n  for (var i = 0; i < style.length; ++i) {\n    result.push(style[i] + \": \" + getPropertyValue(style, style[i]));\n  }\n\n  return result.join(\";\\n\");\n}\n\nfunction _renderWithPseudoElements(element, group) {\n  if (element.tagName == KENDO_PSEUDO_ELEMENT) {\n    _renderElement(element, group);\n\n    return;\n  }\n\n  var fake = [];\n\n  function pseudo(kind, place) {\n    var style = getComputedStyle(element, kind),\n        content = style.content;\n    updateCounters(style);\n\n    if (content && content != \"normal\" && content != \"none\" && style.width != \"0px\") {\n      var psel = element.ownerDocument.createElement(KENDO_PSEUDO_ELEMENT);\n      psel.style.cssText = getCssText(style);\n      psel.textContent = evalPseudoElementContent(element, content);\n      element.insertBefore(psel, place);\n      fake.push(psel);\n    }\n  }\n\n  pseudo(\":before\", element.firstChild);\n  pseudo(\":after\", null);\n\n  if (fake.length > 0) {\n    var saveClass = element.className;\n    element.className += \" kendo-pdf-hide-pseudo-elements\";\n\n    _renderElement(element, group);\n\n    element.className = saveClass;\n    fake.forEach(function (el) {\n      element.removeChild(el);\n    });\n  } else {\n    _renderElement(element, group);\n  }\n}\n\nfunction _renderElement(element, group) {\n  var style = getComputedStyle(element);\n  var top = getBorder(style, \"top\");\n  var right = getBorder(style, \"right\");\n  var bottom = getBorder(style, \"bottom\");\n  var left = getBorder(style, \"left\");\n  var rTL0 = getBorderRadius(style, \"top-left\");\n  var rTR0 = getBorderRadius(style, \"top-right\");\n  var rBL0 = getBorderRadius(style, \"bottom-left\");\n  var rBR0 = getBorderRadius(style, \"bottom-right\");\n  var dir = getPropertyValue(style, \"direction\");\n  var backgroundColor = getPropertyValue(style, \"background-color\");\n  backgroundColor = parseColor(backgroundColor);\n  var backgroundImage = parseBackgroundImage(getPropertyValue(style, \"background-image\"));\n  var backgroundRepeat = splitProperty(getPropertyValue(style, \"background-repeat\"));\n  var backgroundPosition = splitProperty(getPropertyValue(style, \"background-position\"));\n  var backgroundOrigin = splitProperty(getPropertyValue(style, \"background-origin\"));\n  var backgroundSize = splitProperty(getPropertyValue(style, \"background-size\")); // IE shrinks the text with text-overflow: ellipsis,\n  // apparently because the returned bounding box for the range\n  // is limited to the visible area minus space for the dots,\n  // instead of being the full width of the text.\n  //\n  // https://github.com/telerik/kendo/issues/5232\n  // https://github.com/telerik/kendo-ui-core/issues/1868\n  //\n  // We have to test it here rather than in renderText because\n  // text-overflow: ellipsis could be set on a parent element (not\n  // necessarily the one containing the text); in this case,\n  // getComputedStyle(elementWithTheText) will return \"clip\", not\n  // \"ellipsis\" (which is probably a bug, but oh well...)\n\n  var textOverflow, saveTextOverflow;\n\n  if (microsoft) {\n    textOverflow = style.textOverflow; // computed style\n\n    if (textOverflow == \"ellipsis\") {\n      saveTextOverflow = element.style.textOverflow; // own style.\n\n      element.style.textOverflow = \"clip\";\n    }\n  }\n\n  if (browser.msie && browser.version < 10) {\n    // IE9 hacks.  getPropertyValue won't return the correct\n    // value.  Sucks that we have to do it here, I'd prefer to\n    // move it in getPropertyValue, but we don't have the\n    // element.\n    backgroundPosition = splitProperty(element.currentStyle.backgroundPosition);\n  }\n\n  var innerbox = innerBox(element.getBoundingClientRect(), \"border-*-width\", element); // CSS \"clip\" property - if present, replace the group with a\n  // new one which is clipped.  This must happen before drawing\n  // the borders and background.\n\n  (function () {\n    var clip = getPropertyValue(style, \"clip\");\n    var m = /^\\s*rect\\((.*)\\)\\s*$/.exec(clip);\n\n    if (m) {\n      var a = m[1].split(/[ ,]+/g);\n      var top = a[0] == \"auto\" ? innerbox.top : parseFloat(a[0]) + innerbox.top;\n      var right = a[1] == \"auto\" ? innerbox.right : parseFloat(a[1]) + innerbox.left;\n      var bottom = a[2] == \"auto\" ? innerbox.bottom : parseFloat(a[2]) + innerbox.top;\n      var left = a[3] == \"auto\" ? innerbox.left : parseFloat(a[3]) + innerbox.left;\n      var tmp = new Group();\n      var clipPath = new Path().moveTo(left, top).lineTo(right, top).lineTo(right, bottom).lineTo(left, bottom).close();\n      setClipping(tmp, clipPath);\n      group.append(tmp);\n      group = tmp;\n      updateClipbox(clipPath);\n    }\n  })();\n\n  var boxes, i, cells;\n  var display = getPropertyValue(style, \"display\");\n\n  if (display == \"table-row\") {\n    // because of rowspan/colspan, we shouldn't draw background of table row elements on the\n    // box given by its getBoundingClientRect, because if we do we risk overwritting a\n    // previously rendered cell.  https://github.com/telerik/kendo/issues/4881\n    boxes = [];\n\n    for (i = 0, cells = element.children; i < cells.length; ++i) {\n      boxes.push(cells[i].getBoundingClientRect());\n    }\n  } else {\n    boxes = element.getClientRects();\n\n    if (boxes.length == 1) {\n      // Workaround the missing borders in Chrome!  getClientRects() boxes contains values\n      // rounded to integer.  getBoundingClientRect() appears to work fine.  We still need\n      // getClientRects() to support cases where there are more boxes (continued inline\n      // elements that might have border/background).\n      boxes = [element.getBoundingClientRect()];\n    }\n  } // This function workarounds another Chrome bug, where boxes returned for a table with\n  // border-collapse: collapse will overlap the table border.  Our rendering is not perfect in\n  // such case anyway, but with this is better than without it.\n\n\n  boxes = adjustBoxes(boxes);\n\n  for (i = 0; i < boxes.length; ++i) {\n    drawOneBox(boxes[i], i === 0, i == boxes.length - 1);\n  } // Render links as separate groups.  We can't use boxes returned by element's getClientRects\n  // because if display type is \"inline\" (default for <a>), boxes will not include the height of\n  // images inside.  https://github.com/telerik/kendo-ui-core/issues/3359\n\n\n  if (element.tagName == \"A\" && element.href && !/^#?$/.test(element.getAttribute(\"href\"))) {\n    if (!nodeInfo._avoidLinks || !matches(element, nodeInfo._avoidLinks)) {\n      var r = document.createRange();\n      r.selectNodeContents(element);\n      slice(r.getClientRects()).forEach(function (box) {\n        var g = new Group();\n        g._pdfLink = {\n          url: element.href,\n          top: box.top,\n          right: box.right,\n          bottom: box.bottom,\n          left: box.left\n        };\n        group.append(g);\n      });\n    }\n  }\n\n  if (boxes.length > 0 && display == \"list-item\" && !element.getAttribute(\"kendo-no-bullet\")) {\n    drawBullet(boxes[0]);\n  } // overflow: hidden/auto - if present, replace the group with\n  // a new one clipped by the inner box.\n\n\n  (function () {\n    function clipit() {\n      var clipPath = elementRoundBox(element, innerbox, \"padding\");\n      var tmp = new Group();\n      setClipping(tmp, clipPath);\n      group.append(tmp);\n      group = tmp;\n      updateClipbox(clipPath);\n    }\n\n    if (isFormField(element)) {\n      clipit();\n    } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, \"overflow\"))) {\n      clipit();\n    } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, \"overflow-x\"))) {\n      clipit();\n    } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, \"overflow-y\"))) {\n      clipit();\n    }\n  })();\n\n  if (!maybeRenderWidget(element, group)) {\n    renderContents(element, group);\n  }\n\n  if (microsoft && textOverflow == \"ellipsis\") {\n    element.style.textOverflow = saveTextOverflow;\n  }\n\n  return group; // only utility functions after this line.\n\n  function adjustBoxes(boxes) {\n    if (/^td$/i.test(element.tagName)) {\n      var table = nodeInfo.table;\n\n      if (table && getPropertyValue(table.style, \"border-collapse\") == \"collapse\") {\n        var tableBorderLeft = getBorder(table.style, \"left\").width;\n        var tableBorderTop = getBorder(table.style, \"top\").width; // check if we need to adjust\n\n        if (tableBorderLeft === 0 && tableBorderTop === 0) {\n          return boxes; // nope\n        }\n\n        var tableBox = table.element.getBoundingClientRect();\n        var firstCell = table.element.rows[0].cells[0];\n        var firstCellBox = firstCell.getBoundingClientRect();\n\n        if (firstCellBox.top == tableBox.top || firstCellBox.left == tableBox.left) {\n          return slice(boxes).map(function (box) {\n            return {\n              left: box.left + tableBorderLeft,\n              top: box.top + tableBorderTop,\n              right: box.right + tableBorderLeft,\n              bottom: box.bottom + tableBorderTop,\n              height: box.height,\n              width: box.width\n            };\n          });\n        }\n      }\n    }\n\n    return boxes;\n  } // this function will be called to draw each border.  it\n  // draws starting at origin and the resulted path must be\n  // translated/rotated to be placed in the proper position.\n  //\n  // arguments are named as if it draws the top border:\n  //\n  //    - `len` the length of the edge\n  //    - `Wtop` the width of the edge (i.e. border-top-width)\n  //    - `Wleft` the width of the left edge (border-left-width)\n  //    - `Wright` the width of the right edge\n  //    - `rl` and `rl` -- the border radius on the left and right\n  //      (objects containing x and y, for horiz/vertical radius)\n  //    - `transform` -- transformation to apply\n  //\n\n\n  function drawEdge(color, len, Wtop, Wleft, Wright, rl, rr, transform) {\n    if (Wtop <= 0) {\n      return;\n    }\n\n    var path,\n        edge = new Group();\n    setTransform(edge, transform);\n    group.append(edge);\n    sanitizeRadius(rl);\n    sanitizeRadius(rr); // draw main border.  this is the area without the rounded corners\n\n    path = new Path({\n      fill: {\n        color: color\n      },\n      stroke: null\n    });\n    edge.append(path);\n    path.moveTo(rl.x ? Math.max(rl.x, Wleft) : 0, 0).lineTo(len - (rr.x ? Math.max(rr.x, Wright) : 0), 0).lineTo(len - Math.max(rr.x, Wright), Wtop).lineTo(Math.max(rl.x, Wleft), Wtop).close();\n\n    if (rl.x) {\n      drawRoundCorner(Wleft, rl, [-1, 0, 0, 1, rl.x, 0]);\n    }\n\n    if (rr.x) {\n      drawRoundCorner(Wright, rr, [1, 0, 0, 1, len - rr.x, 0]);\n    } // draws one round corner, starting at origin (needs to be\n    // translated/rotated to be placed properly).\n\n\n    function drawRoundCorner(Wright, r, transform) {\n      var angle = Math.PI / 2 * Wright / (Wright + Wtop); // not sanitizing this one, because negative values\n      // are useful to fill the box correctly.\n\n      var ri = {\n        x: r.x - Wright,\n        y: r.y - Wtop\n      };\n      var path = new Path({\n        fill: {\n          color: color\n        },\n        stroke: null\n      }).moveTo(0, 0);\n      setTransform(path, transform);\n      addArcToPath(path, 0, r.y, {\n        startAngle: -90,\n        endAngle: -radiansToDegrees(angle),\n        radiusX: r.x,\n        radiusY: r.y\n      });\n\n      if (ri.x > 0 && ri.y > 0) {\n        path.lineTo(ri.x * Math.cos(angle), r.y - ri.y * Math.sin(angle));\n        addArcToPath(path, 0, r.y, {\n          startAngle: -radiansToDegrees(angle),\n          endAngle: -90,\n          radiusX: ri.x,\n          radiusY: ri.y,\n          anticlockwise: true\n        });\n      } else if (ri.x > 0) {\n        path.lineTo(ri.x, Wtop).lineTo(0, Wtop);\n      } else {\n        path.lineTo(ri.x, Wtop).lineTo(ri.x, 0);\n      }\n\n      edge.append(path.close());\n    }\n  }\n\n  function drawBackground(box) {\n    var background = new Group();\n    setClipping(background, roundBox(box, rTL0, rTR0, rBR0, rBL0));\n    group.append(background);\n\n    if (backgroundColor) {\n      var path = new Path({\n        fill: {\n          color: backgroundColor.toCssRgba()\n        },\n        stroke: null\n      });\n      path.moveTo(box.left, box.top).lineTo(box.right, box.top).lineTo(box.right, box.bottom).lineTo(box.left, box.bottom).close();\n      background.append(path);\n    }\n\n    for (var i = backgroundImage.length; --i >= 0;) {\n      drawOneBackground(background, box, backgroundImage[i], backgroundRepeat[i % backgroundRepeat.length], backgroundPosition[i % backgroundPosition.length], backgroundOrigin[i % backgroundOrigin.length], backgroundSize[i % backgroundSize.length]);\n    }\n  }\n\n  function drawOneBackground(group, box, background, backgroundRepeat, backgroundPosition, backgroundOrigin, backgroundSize) {\n    if (!background || background == \"none\") {\n      return;\n    }\n\n    if (background.type == \"url\") {\n      var img = IMAGE_CACHE[background.url];\n\n      if (img && img.width > 0 && img.height > 0) {\n        drawBackgroundImage(group, box, img.width, img.height, function (group, rect) {\n          group.append(new Image(background.url, rect));\n        });\n      }\n    } else if (background.type == \"linear\") {\n      drawBackgroundImage(group, box, box.width, box.height, gradientRenderer(background));\n    } else {\n      return;\n    }\n\n    function drawBackgroundImage(group, box, img_width, img_height, renderBG) {\n      var aspect_ratio = img_width / img_height,\n          f; // for background-origin: border-box the box is already appropriate\n\n      var orgBox = box;\n\n      if (backgroundOrigin == \"content-box\") {\n        orgBox = innerBox(orgBox, \"border-*-width\", element);\n        orgBox = innerBox(orgBox, \"padding-*\", element);\n      } else if (backgroundOrigin == \"padding-box\") {\n        orgBox = innerBox(orgBox, \"border-*-width\", element);\n      }\n\n      if (!/^\\s*auto(\\s+auto)?\\s*$/.test(backgroundSize)) {\n        if (backgroundSize == \"contain\") {\n          f = Math.min(orgBox.width / img_width, orgBox.height / img_height);\n          img_width *= f;\n          img_height *= f;\n        } else if (backgroundSize == \"cover\") {\n          f = Math.max(orgBox.width / img_width, orgBox.height / img_height);\n          img_width *= f;\n          img_height *= f;\n        } else {\n          var size = backgroundSize.split(/\\s+/g); // compute width\n\n          if (/%$/.test(size[0])) {\n            img_width = orgBox.width * parseFloat(size[0]) / 100;\n          } else {\n            img_width = parseFloat(size[0]);\n          } // compute height\n\n\n          if (size.length == 1 || size[1] == \"auto\") {\n            img_height = img_width / aspect_ratio;\n          } else if (/%$/.test(size[1])) {\n            img_height = orgBox.height * parseFloat(size[1]) / 100;\n          } else {\n            img_height = parseFloat(size[1]);\n          }\n        }\n      }\n\n      var pos = String(backgroundPosition); // IE sometimes reports single-word positions\n      // https://github.com/telerik/kendo-ui-core/issues/2786\n      //\n      // it seems to switch to percentages when the horizontal\n      // position is not \"center\", therefore we don't handle\n      // multi-word cases here.  All other browsers return\n      // percentages or pixels instead of keywords.  At least\n      // for now...\n\n      switch (pos) {\n        case \"bottom\":\n          pos = \"50% 100%\";\n          break;\n\n        case \"top\":\n          pos = \"50% 0\";\n          break;\n\n        case \"left\":\n          pos = \"0 50%\";\n          break;\n\n        case \"right\":\n          pos = \"100% 50%\";\n          break;\n\n        case \"center\":\n          pos = \"50% 50%\";\n          break;\n      }\n\n      pos = pos.split(/\\s+/);\n\n      if (pos.length == 1) {\n        pos[1] = \"50%\";\n      }\n\n      if (/%$/.test(pos[0])) {\n        pos[0] = parseFloat(pos[0]) / 100 * (orgBox.width - img_width);\n      } else {\n        pos[0] = parseFloat(pos[0]);\n      }\n\n      if (/%$/.test(pos[1])) {\n        pos[1] = parseFloat(pos[1]) / 100 * (orgBox.height - img_height);\n      } else {\n        pos[1] = parseFloat(pos[1]);\n      }\n\n      var rect = new geo.Rect([orgBox.left + pos[0], orgBox.top + pos[1]], [img_width, img_height]); // XXX: background-repeat could be implemented more\n      //      efficiently as a fill pattern (at least for PDF\n      //      output, probably SVG too).\n\n      function rewX() {\n        while (rect.origin.x > box.left) {\n          rect.origin.x -= img_width;\n        }\n      }\n\n      function rewY() {\n        while (rect.origin.y > box.top) {\n          rect.origin.y -= img_height;\n        }\n      }\n\n      function repeatX() {\n        while (rect.origin.x < box.right) {\n          renderBG(group, rect.clone());\n          rect.origin.x += img_width;\n        }\n      }\n\n      if (backgroundRepeat == \"no-repeat\") {\n        renderBG(group, rect);\n      } else if (backgroundRepeat == \"repeat-x\") {\n        rewX();\n        repeatX();\n      } else if (backgroundRepeat == \"repeat-y\") {\n        rewY();\n\n        while (rect.origin.y < box.bottom) {\n          renderBG(group, rect.clone());\n          rect.origin.y += img_height;\n        }\n      } else if (backgroundRepeat == \"repeat\") {\n        rewX();\n        rewY();\n        var origin = rect.origin.clone();\n\n        while (rect.origin.y < box.bottom) {\n          rect.origin.x = origin.x;\n          repeatX();\n          rect.origin.y += img_height;\n        }\n      }\n    }\n  }\n\n  function drawBullet() {\n    var listStyleType = getPropertyValue(style, \"list-style-type\");\n\n    if (listStyleType == \"none\") {\n      return;\n    }\n\n    var listStylePosition = getPropertyValue(style, \"list-style-position\");\n\n    function _drawBullet(f) {\n      saveStyle(element, function () {\n        element.style.position = \"relative\";\n        var bullet = element.ownerDocument.createElement(KENDO_PSEUDO_ELEMENT);\n        bullet.style.position = \"absolute\";\n        bullet.style.boxSizing = \"border-box\";\n\n        if (listStylePosition == \"outside\") {\n          bullet.style.width = \"6em\";\n          bullet.style.left = \"-6.8em\";\n          bullet.style.textAlign = \"right\";\n        } else {\n          bullet.style.left = \"0px\";\n        }\n\n        f(bullet);\n        element.insertBefore(bullet, element.firstChild);\n        renderElement(bullet, group);\n        element.removeChild(bullet);\n      });\n    }\n\n    function elementIndex(f) {\n      var a = element.parentNode.children;\n      var k = element.getAttribute(\"kendo-split-index\");\n\n      if (k != null) {\n        return f(k | 0, a.length);\n      }\n\n      for (var i = 0; i < a.length; ++i) {\n        if (a[i] === element) {\n          return f(i, a.length);\n        }\n      }\n    }\n\n    switch (listStyleType) {\n      case \"circle\":\n      case \"disc\":\n      case \"square\":\n        _drawBullet(function (bullet) {\n          // XXX: the science behind these values is called \"trial and error\".\n          bullet.style.fontSize = \"60%\";\n          bullet.style.lineHeight = \"200%\";\n          bullet.style.paddingRight = \"0.5em\";\n          bullet.style.fontFamily = \"DejaVu Serif\";\n          bullet.innerHTML = {\n            \"disc\": \"\\u25cf\",\n            \"circle\": \"\\u25ef\",\n            \"square\": \"\\u25a0\"\n          }[listStyleType];\n        });\n\n        break;\n\n      case \"decimal\":\n      case \"decimal-leading-zero\":\n        _drawBullet(function (bullet) {\n          elementIndex(function (idx) {\n            ++idx;\n\n            if (listStyleType == \"decimal-leading-zero\" && idx < 10) {\n              idx = \"0\" + idx;\n            }\n\n            bullet.innerHTML = idx + \".\";\n          });\n        });\n\n        break;\n\n      case \"lower-roman\":\n      case \"upper-roman\":\n        _drawBullet(function (bullet) {\n          elementIndex(function (idx) {\n            idx = arabicToRoman(idx + 1);\n\n            if (listStyleType == \"upper-roman\") {\n              idx = idx.toUpperCase();\n            }\n\n            bullet.innerHTML = idx + \".\";\n          });\n        });\n\n        break;\n\n      case \"lower-latin\":\n      case \"lower-alpha\":\n      case \"upper-latin\":\n      case \"upper-alpha\":\n        _drawBullet(function (bullet) {\n          elementIndex(function (idx) {\n            idx = alphaNumeral(idx);\n\n            if (/^upper/i.test(listStyleType)) {\n              idx = idx.toUpperCase();\n            }\n\n            bullet.innerHTML = idx + \".\";\n          });\n        });\n\n        break;\n    }\n  } // draws a single border box\n\n\n  function drawOneBox(box, isFirst, isLast) {\n    if (box.width === 0 || box.height === 0) {\n      return;\n    }\n\n    drawBackground(box);\n    var shouldDrawLeft = left.width > 0 && (isFirst && dir == \"ltr\" || isLast && dir == \"rtl\");\n    var shouldDrawRight = right.width > 0 && (isLast && dir == \"ltr\" || isFirst && dir == \"rtl\"); // The most general case is that the 4 borders have different widths and border\n    // radiuses.  The way that is handled is by drawing 3 Paths for each border: the\n    // straight line, and two round corners which represent half of the entire rounded\n    // corner.  To simplify code those shapes are drawed at origin (by the drawEdge\n    // function), then translated/rotated into the right position.\n    //\n    // However, this leads to poor results due to rounding in the simpler cases where\n    // borders are straight lines.  Therefore we handle a few such cases separately with\n    // straight lines. C^wC^wC^w -- nope, scratch that.  poor rendering was because of a bug\n    // in Chrome (getClientRects() returns rounded integer values rather than exact floats.\n    // web dev is still a ghetto.)\n    // first, just in case there is no border...\n\n    if (top.width === 0 && left.width === 0 && right.width === 0 && bottom.width === 0) {\n      return;\n    } // START paint borders\n    // if all borders have equal colors...\n\n\n    if (top.color == right.color && top.color == bottom.color && top.color == left.color) {\n      // if same widths too, we can draw the whole border by stroking a single path.\n      if (top.width == right.width && top.width == bottom.width && top.width == left.width) {\n        if (shouldDrawLeft && shouldDrawRight) {\n          // reduce box by half the border width, so we can draw it by stroking.\n          box = innerBox(box, top.width / 2); // adjust the border radiuses, again by top.width/2, and make the path element.\n\n          var path = elementRoundBox(element, box, top.width / 2);\n          path.options.stroke = {\n            color: top.color,\n            width: top.width\n          };\n          group.append(path);\n          return;\n        }\n      }\n    } // if border radiuses are zero and widths are at most one pixel, we can again use simple\n    // paths.\n\n\n    if (rTL0.x === 0 && rTR0.x === 0 && rBR0.x === 0 && rBL0.x === 0) {\n      // alright, 1.9px will do as well.  the difference in color blending should not be\n      // noticeable.\n      if (top.width < 2 && left.width < 2 && right.width < 2 && bottom.width < 2) {\n        // top border\n        if (top.width > 0) {\n          group.append(new Path({\n            stroke: {\n              width: top.width,\n              color: top.color\n            }\n          }).moveTo(box.left, box.top + top.width / 2).lineTo(box.right, box.top + top.width / 2));\n        } // bottom border\n\n\n        if (bottom.width > 0) {\n          group.append(new Path({\n            stroke: {\n              width: bottom.width,\n              color: bottom.color\n            }\n          }).moveTo(box.left, box.bottom - bottom.width / 2).lineTo(box.right, box.bottom - bottom.width / 2));\n        } // left border\n\n\n        if (shouldDrawLeft) {\n          group.append(new Path({\n            stroke: {\n              width: left.width,\n              color: left.color\n            }\n          }).moveTo(box.left + left.width / 2, box.top).lineTo(box.left + left.width / 2, box.bottom));\n        } // right border\n\n\n        if (shouldDrawRight) {\n          group.append(new Path({\n            stroke: {\n              width: right.width,\n              color: right.color\n            }\n          }).moveTo(box.right - right.width / 2, box.top).lineTo(box.right - right.width / 2, box.bottom));\n        }\n\n        return;\n      }\n    } // END paint borders\n\n\n    var tmp = adjustBorderRadiusForBox(box, rTL0, rTR0, rBR0, rBL0);\n    var rTL = tmp.tl;\n    var rTR = tmp.tr;\n    var rBR = tmp.br;\n    var rBL = tmp.bl; // top border\n\n    drawEdge(top.color, box.width, top.width, left.width, right.width, rTL, rTR, [1, 0, 0, 1, box.left, box.top]); // bottom border\n\n    drawEdge(bottom.color, box.width, bottom.width, right.width, left.width, rBR, rBL, [-1, 0, 0, -1, box.right, box.bottom]); // for left/right borders we need to invert the border-radiuses\n\n    function inv(p) {\n      return {\n        x: p.y,\n        y: p.x\n      };\n    } // left border\n\n\n    drawEdge(left.color, box.height, left.width, bottom.width, top.width, inv(rBL), inv(rTL), [0, -1, 1, 0, box.left, box.bottom]); // right border\n\n    drawEdge(right.color, box.height, right.width, top.width, bottom.width, inv(rTR), inv(rBR), [0, 1, -1, 0, box.right, box.top]);\n  }\n}\n\nfunction gradientRenderer(gradient) {\n  return function (group, rect) {\n    var width = rect.width(),\n        height = rect.height();\n\n    switch (gradient.type) {\n      case \"linear\":\n        // figure out the angle.\n        var angle = gradient.angle != null ? gradient.angle : Math.PI;\n\n        switch (gradient.to) {\n          case \"top\":\n            angle = 0;\n            break;\n\n          case \"left\":\n            angle = -Math.PI / 2;\n            break;\n\n          case \"bottom\":\n            angle = Math.PI;\n            break;\n\n          case \"right\":\n            angle = Math.PI / 2;\n            break;\n\n          case \"top left\":\n          case \"left top\":\n            angle = -Math.atan2(height, width);\n            break;\n\n          case \"top right\":\n          case \"right top\":\n            angle = Math.atan2(height, width);\n            break;\n\n          case \"bottom left\":\n          case \"left bottom\":\n            angle = Math.PI + Math.atan2(height, width);\n            break;\n\n          case \"bottom right\":\n          case \"right bottom\":\n            angle = Math.PI - Math.atan2(height, width);\n            break;\n        }\n\n        if (gradient.reverse) {\n          angle -= Math.PI;\n        } // limit the angle between 0..2PI\n\n\n        angle %= 2 * Math.PI;\n\n        if (angle < 0) {\n          angle += 2 * Math.PI;\n        } // compute gradient's start/end points.  here len is the length of the gradient line\n        // and x,y is the end point relative to the center of the rectangle in conventional\n        // (math) axis direction.\n        // this is the original (unscaled) length of the gradient line.  needed to deal with\n        // absolutely positioned color stops.  formula from the CSS spec:\n        // http://dev.w3.org/csswg/css-images-3/#linear-gradient-syntax\n\n\n        var pxlen = Math.abs(width * Math.sin(angle)) + Math.abs(height * Math.cos(angle)); // The math below is pretty simple, but it took a while to figure out.  We compute x\n        // and y, the *end* of the gradient line.  However, we want to transform them into\n        // element-based coordinates (SVG's gradientUnits=\"objectBoundingBox\").  That means,\n        // x=0 is the left edge, x=1 is the right edge, y=0 is the top edge and y=1 is the\n        // bottom edge.\n        //\n        // A naive approach would use the original angle for these calculations.  Say we'd\n        // like to draw a gradient angled at 45deg in a 100x400 box.  When we use\n        // objectBoundingBox, the renderer will draw it in a 1x1 *square* box, and then\n        // scale that to the desired dimensions.  The 45deg angle will look more like 70deg\n        // after scaling.  SVG (http://www.w3.org/TR/SVG/pservers.html#LinearGradients) says\n        // the following:\n        //\n        //     When gradientUnits=\"objectBoundingBox\" and 'gradientTransform' is the\n        //     identity matrix, the normal of the linear gradient is perpendicular to the\n        //     gradient vector in object bounding box space (i.e., the abstract coordinate\n        //     system where (0,0) is at the top/left of the object bounding box and (1,1) is\n        //     at the bottom/right of the object bounding box). When the object's bounding\n        //     box is not square, the gradient normal which is initially perpendicular to\n        //     the gradient vector within object bounding box space may render\n        //     non-perpendicular relative to the gradient vector in user space. If the\n        //     gradient vector is parallel to one of the axes of the bounding box, the\n        //     gradient normal will remain perpendicular. This transformation is due to\n        //     application of the non-uniform scaling transformation from bounding box space\n        //     to user space.\n        //\n        // which is an extremely long and confusing way to tell what I just said above.\n        //\n        // For this reason we need to apply the reverse scaling to the original angle, so\n        // that when it'll finally be rendered it'll actually be at the desired slope.  Now\n        // I'll let you figure out the math yourself.\n\n        var scaledAngle = Math.atan(width * Math.tan(angle) / height);\n        var sin = Math.sin(scaledAngle),\n            cos = Math.cos(scaledAngle);\n        var len = Math.abs(sin) + Math.abs(cos);\n        var x = len / 2 * sin;\n        var y = len / 2 * cos; // Because of the arctangent, our scaledAngle ends up between -PI/2..PI/2, possibly\n        // losing the intended direction of the gradient.  The following fixes it.\n\n        if (angle > Math.PI / 2 && angle <= 3 * Math.PI / 2) {\n          x = -x;\n          y = -y;\n        } // compute the color stops.\n\n\n        var implicit = [],\n            right = 0;\n        var stops = gradient.stops.map(function (s, i) {\n          var offset = s.percent;\n\n          if (offset) {\n            offset = parseFloat(offset) / 100;\n          } else if (s.length) {\n            offset = parseFloat(s.length) / pxlen;\n          } else if (i === 0) {\n            offset = 0;\n          } else if (i == gradient.stops.length - 1) {\n            offset = 1;\n          }\n\n          var stop = {\n            color: s.color.toCssRgba(),\n            offset: offset\n          };\n\n          if (offset != null) {\n            right = offset; // fix implicit offsets\n\n            implicit.forEach(function (s, i) {\n              var stop = s.stop;\n              stop.offset = s.left + (right - s.left) * (i + 1) / (implicit.length + 1);\n            });\n            implicit = [];\n          } else {\n            implicit.push({\n              left: right,\n              stop: stop\n            });\n          }\n\n          return stop;\n        });\n        var start = [0.5 - x, 0.5 + y];\n        var end = [0.5 + x, 0.5 - y]; // finally, draw it.\n\n        group.append(Path.fromRect(rect).stroke(null).fill(new LinearGradient({\n          start: start,\n          end: end,\n          stops: stops,\n          userSpace: false\n        })));\n        break;\n\n      case \"radial\":\n        // XXX:\n        if (window.console && window.console.log) {\n          window.console.log(\"Radial gradients are not yet supported in HTML renderer\");\n        }\n\n        break;\n    }\n  };\n}\n\nfunction maybeRenderWidget(element, group) {\n  var visual;\n\n  if (element._kendoExportVisual) {\n    visual = element._kendoExportVisual();\n  } else if (window.kendo && window.kendo.jQuery && element.getAttribute(window.kendo.attr(\"role\"))) {\n    var widget = window.kendo.widgetInstance(window.kendo.jQuery(element));\n\n    if (widget && (widget.exportDOMVisual || widget.exportVisual)) {\n      if (widget.exportDOMVisual) {\n        visual = widget.exportDOMVisual();\n      } else {\n        visual = widget.exportVisual();\n      }\n    }\n  }\n\n  if (!visual) {\n    return false;\n  }\n\n  var wrap = new Group();\n  wrap.children.push(visual);\n  var bbox = element.getBoundingClientRect();\n  wrap.transform(geo.transform().translate(bbox.left, bbox.top));\n  group.append(wrap);\n  return true;\n}\n\nfunction renderImage(element, url, group) {\n  var box = getContentBox(element);\n  var rect = new geo.Rect([box.left, box.top], [box.width, box.height]);\n  var image = new Image(url, rect);\n  setClipping(image, elementRoundBox(element, box, \"content\"));\n  group.append(image);\n}\n\nfunction zIndexSort(a, b) {\n  var sa = getComputedStyle(a);\n  var sb = getComputedStyle(b);\n  var za = parseFloat(getPropertyValue(sa, \"z-index\"));\n  var zb = parseFloat(getPropertyValue(sb, \"z-index\"));\n  var pa = getPropertyValue(sa, \"position\");\n  var pb = getPropertyValue(sb, \"position\");\n\n  if (isNaN(za) && isNaN(zb)) {\n    if (/static|absolute/.test(pa) && /static|absolute/.test(pb)) {\n      return 0;\n    }\n\n    if (pa == \"static\") {\n      return -1;\n    }\n\n    if (pb == \"static\") {\n      return 1;\n    }\n\n    return 0;\n  }\n\n  if (isNaN(za)) {\n    return zb === 0 ? 0 : zb > 0 ? -1 : 1;\n  }\n\n  if (isNaN(zb)) {\n    return za === 0 ? 0 : za > 0 ? 1 : -1;\n  }\n\n  return parseFloat(za) - parseFloat(zb);\n}\n\nfunction isFormField(element) {\n  return /^(?:textarea|select|input)$/i.test(element.tagName);\n}\n\nfunction getSelectedOption(element) {\n  if (element.selectedOptions && element.selectedOptions.length > 0) {\n    return element.selectedOptions[0];\n  }\n\n  return element.options[element.selectedIndex];\n}\n\nfunction renderCheckbox(element, group) {\n  var style = getComputedStyle(element);\n  var color = getPropertyValue(style, \"color\");\n  var box = element.getBoundingClientRect();\n\n  if (element.type == \"checkbox\") {\n    group.append(Path.fromRect(new geo.Rect([box.left + 1, box.top + 1], [box.width - 2, box.height - 2])).stroke(color, 1));\n\n    if (element.checked) {\n      // fill a rectangle inside?  looks kinda ugly.\n      // group.append(\n      //     Path.fromRect(\n      //         new geo.Rect([ box.left+4, box.top+4 ],\n      //                      [ box.width-8, box.height-8])\n      //     ).fill(color).stroke(null)\n      // );\n      // let's draw a checkmark instead.  artistic, eh?\n      group.append(new Path().stroke(color, 1.2).moveTo(box.left + 0.22 * box.width, box.top + 0.55 * box.height).lineTo(box.left + 0.45 * box.width, box.top + 0.75 * box.height).lineTo(box.left + 0.78 * box.width, box.top + 0.22 * box.width));\n    }\n  } else {\n    group.append(new Circle(new geo.Circle([(box.left + box.right) / 2, (box.top + box.bottom) / 2], Math.min(box.width - 2, box.height - 2) / 2)).stroke(color, 1));\n\n    if (element.checked) {\n      group.append(new Circle(new geo.Circle([(box.left + box.right) / 2, (box.top + box.bottom) / 2], Math.min(box.width - 8, box.height - 8) / 2)).fill(color).stroke(null));\n    }\n  }\n}\n\nfunction renderFormField(element, group) {\n  var tag = element.tagName.toLowerCase();\n\n  if (tag == \"input\" && (element.type == \"checkbox\" || element.type == \"radio\")) {\n    return renderCheckbox(element, group);\n  }\n\n  var p = element.parentNode;\n  var doc = element.ownerDocument;\n  var el = doc.createElement(KENDO_PSEUDO_ELEMENT);\n  var option;\n  el.style.cssText = getCssText(getComputedStyle(element));\n\n  if (tag == \"input\") {\n    el.style.whiteSpace = \"pre\";\n  }\n\n  if (tag == \"select\" || tag == \"textarea\") {\n    el.style.overflow = \"auto\";\n  }\n\n  if (tag == \"select\") {\n    if (element.multiple) {\n      for (var i = 0; i < element.options.length; ++i) {\n        option = doc.createElement(KENDO_PSEUDO_ELEMENT);\n        option.style.cssText = getCssText(getComputedStyle(element.options[i]));\n        option.style.display = \"block\"; // IE9 messes up without this\n\n        option.textContent = element.options[i].textContent;\n        el.appendChild(option);\n      }\n    } else {\n      option = getSelectedOption(element);\n\n      if (option) {\n        el.textContent = option.textContent;\n      }\n    }\n  } else {\n    el.textContent = element.value;\n  }\n\n  p.insertBefore(el, element);\n  el.scrollLeft = element.scrollLeft;\n  el.scrollTop = element.scrollTop; // must temporarily hide the original element, otherwise it\n  // may affect layout of the fake element we want to render.\n\n  element.style.display = \"none\";\n  renderContents(el, group);\n  element.style.display = \"\";\n  p.removeChild(el);\n}\n\nfunction renderContents(element, group) {\n  if (nodeInfo._stackingContext.element === element) {\n    // the group that was set in pushNodeInfo might have\n    // changed due to clipping/transforms, update it here.\n    nodeInfo._stackingContext.group = group;\n  }\n\n  switch (element.tagName.toLowerCase()) {\n    case \"img\":\n      renderImage(element, element.src, group);\n      break;\n\n    case \"svg\":\n      var xml = new window.XMLSerializer().serializeToString(element);\n      var dataURL = \"data:image/svg+xml;base64,\" + encodeBase64(xml);\n      renderImage(element, dataURL, group);\n      break;\n\n    case \"canvas\":\n      try {\n        renderImage(element, element.toDataURL(\"image/png\"), group);\n      } catch (ex) {// tainted; can't draw it, ignore.\n      }\n\n      break;\n\n    case \"textarea\":\n    case \"input\":\n    case \"select\":\n      renderFormField(element, group);\n      break;\n\n    default:\n      var children = [],\n          floats = [],\n          positioned = [];\n\n      for (var i = element.firstChild; i; i = i.nextSibling) {\n        switch (i.nodeType) {\n          case 3:\n            // Text\n            if (/\\S/.test(i.data)) {\n              renderText(element, i, group);\n            }\n\n            break;\n\n          case 1:\n            // Element\n            var style = getComputedStyle(i);\n            var floating = getPropertyValue(style, \"float\");\n            var position = getPropertyValue(style, \"position\");\n\n            if (position != \"static\") {\n              positioned.push(i);\n            } else if (floating != \"none\") {\n              floats.push(i);\n            } else {\n              children.push(i);\n            }\n\n            break;\n        }\n      }\n\n      mergeSort(children, zIndexSort).forEach(function (el) {\n        renderElement(el, group);\n      });\n      mergeSort(floats, zIndexSort).forEach(function (el) {\n        renderElement(el, group);\n      });\n      mergeSort(positioned, zIndexSort).forEach(function (el) {\n        renderElement(el, group);\n      });\n  }\n}\n\nfunction renderText(element, node, group) {\n  if (emptyClipbox()) {\n    return;\n  }\n\n  var style = getComputedStyle(element);\n\n  if (parseFloat(getPropertyValue(style, \"text-indent\")) < -500) {\n    // assume it should not be displayed.  the slider's\n    // draggable handle displays a Drag text for some reason,\n    // having text-indent: -3333px.\n    return;\n  }\n\n  var text = node.data;\n  var start = 0;\n  var end = text.search(/\\S\\s*$/) + 1;\n\n  if (!end) {\n    return; // whitespace-only node\n  }\n\n  var fontSize = getPropertyValue(style, \"font-size\");\n  var lineHeight = getPropertyValue(style, \"line-height\"); // simply getPropertyValue(\"font\") doesn't work in Firefox :-\\\n\n  var font = [getPropertyValue(style, \"font-style\"), getPropertyValue(style, \"font-variant\"), getPropertyValue(style, \"font-weight\"), fontSize, // no need for line height here; it breaks layout in FF\n  getPropertyValue(style, \"font-family\")].join(\" \");\n  fontSize = parseFloat(fontSize);\n  lineHeight = parseFloat(lineHeight);\n\n  if (fontSize === 0) {\n    return;\n  }\n\n  var color = getPropertyValue(style, \"color\");\n  var range = element.ownerDocument.createRange();\n  var align = getPropertyValue(style, \"text-align\");\n  var isJustified = align == \"justify\";\n  var columnCount = getPropertyValue(style, \"column-count\", 1);\n  var whiteSpace = getPropertyValue(style, \"white-space\");\n  var textTransform = getPropertyValue(style, \"text-transform\"); // A line of 500px, with a font of 12px, contains an average of 80 characters, but since we\n  // err, we'd like to guess a bigger number rather than a smaller one.  Multiplying by 5\n  // seems to be a good option.\n\n  var estimateLineLength = element.getBoundingClientRect().width / fontSize * 5;\n\n  if (estimateLineLength === 0) {\n    estimateLineLength = 500;\n  } // we'll maintain this so we can workaround bugs in Chrome's Range.getClientRects\n  // https://github.com/telerik/kendo/issues/5740\n\n\n  var prevLineBottom = null;\n  var underline = nodeInfo[\"underline\"];\n  var lineThrough = nodeInfo[\"line-through\"];\n  var overline = nodeInfo[\"overline\"];\n  var hasDecoration = underline || lineThrough || overline; // doChunk returns true when all text has been rendered\n\n  while (!doChunk()) {}\n\n  if (hasDecoration) {\n    range.selectNode(node);\n    slice(range.getClientRects()).forEach(decorate);\n  }\n\n  return; // only function declarations after this line\n\n  function actuallyGetRangeBoundingRect(range) {\n    // XXX: to be revised when this Chrome bug is fixed:\n    // https://bugs.chromium.org/p/chromium/issues/detail?id=612459\n    if (microsoft || browser.chrome) {\n      // Workaround browser bugs: IE and Chrome would sometimes\n      // return 0 or 1-width rectangles before or after the main\n      // one.  https://github.com/telerik/kendo/issues/4674\n      // Actually Chrome 50 got worse, since the rectangles can now have the width of a\n      // full character, making it hard to tell whether it's a bogus rectangle or valid\n      // selection location.  The workaround is to ignore rectangles that fall on the\n      // previous line.  https://github.com/telerik/kendo/issues/5740\n      var rectangles = range.getClientRects(),\n          box = {\n        top: Infinity,\n        right: -Infinity,\n        bottom: -Infinity,\n        left: Infinity\n      },\n          done = false;\n\n      for (var i = 0; i < rectangles.length; ++i) {\n        var b = rectangles[i];\n\n        if (b.width <= 1 || b.bottom === prevLineBottom) {\n          continue; // bogus rectangle\n        }\n\n        box.left = Math.min(b.left, box.left);\n        box.top = Math.min(b.top, box.top);\n        box.right = Math.max(b.right, box.right);\n        box.bottom = Math.max(b.bottom, box.bottom);\n        done = true;\n      }\n\n      if (!done) {\n        return range.getBoundingClientRect();\n      }\n\n      box.width = box.right - box.left;\n      box.height = box.bottom - box.top;\n      return box;\n    }\n\n    return range.getBoundingClientRect();\n  } // Render a chunk of text, typically one line (but for justified text we render each word as\n  // a separate Text object, because spacing is variable).  Returns true when it finished the\n  // current node.  After each chunk it updates `start` to just after the last rendered\n  // character.\n\n\n  function doChunk() {\n    var origStart = start;\n    var box,\n        pos = text.substr(start).search(/\\S/);\n    start += pos;\n\n    if (pos < 0 || start >= end) {\n      return true;\n    } // Select a single character to determine the height of a line of text.  The box.bottom\n    // will be essential for us to figure out where the next line begins.\n\n\n    range.setStart(node, start);\n    range.setEnd(node, start + 1);\n    box = actuallyGetRangeBoundingRect(range); // for justified text we must split at each space, because space has variable width.\n\n    var found = false;\n\n    if (isJustified || columnCount > 1) {\n      pos = text.substr(start).search(/\\s/);\n\n      if (pos >= 0) {\n        // we can only split there if it's on the same line, otherwise we'll fall back\n        // to the default mechanism (see findEOL below).\n        range.setEnd(node, start + pos);\n        var r = actuallyGetRangeBoundingRect(range);\n\n        if (r.bottom == box.bottom) {\n          box = r;\n          found = true;\n          start += pos;\n        }\n      }\n    }\n\n    if (!found) {\n      // This code does three things: (1) it selects one line of text in `range`, (2) it\n      // leaves the bounding rect of that line in `box` and (3) it returns the position\n      // just after the EOL.  We know where the line starts (`start`) but we don't know\n      // where it ends.  To figure this out, we select a piece of text and look at the\n      // bottom of the bounding box.  If it changes, we have more than one line selected\n      // and should retry with a smaller selection.\n      //\n      // To speed things up, we first try to select all text in the node (`start` ->\n      // `end`).  If there's more than one line there, then select only half of it.  And\n      // so on.  When we find a value for `end` that fits in one line, we try increasing\n      // it (also in halves) until we get to the next line.  The algorithm stops when the\n      // right side of the bounding box does not change.\n      //\n      // One more thing to note is that everything happens in a single Text DOM node.\n      // There's no other tags inside it, therefore the left/top coordinates of the\n      // bounding box will not change.\n      pos = function findEOL(min, eol, max) {\n        range.setEnd(node, eol);\n        var r = actuallyGetRangeBoundingRect(range);\n\n        if (r.bottom != box.bottom && min < eol) {\n          return findEOL(min, min + eol >> 1, eol);\n        } else if (r.right != box.right) {\n          box = r;\n\n          if (eol < max) {\n            return findEOL(eol, eol + max >> 1, max);\n          } else {\n            return eol;\n          }\n        } else {\n          return eol;\n        }\n      }(start, Math.min(end, start + estimateLineLength), end);\n\n      if (pos == start) {\n        // if EOL is at the start, then no more text fits on this line.  Skip the\n        // remainder of this node entirely to avoid a stack overflow.\n        return true;\n      }\n\n      start = pos;\n      pos = range.toString().search(/\\s+$/);\n\n      if (pos === 0) {\n        return false; // whitespace only; we should not get here.\n      }\n\n      if (pos > 0) {\n        // eliminate trailing whitespace\n        range.setEnd(node, range.startOffset + pos);\n        box = actuallyGetRangeBoundingRect(range);\n      }\n    } // another workaround for IE: if we rely on getBoundingClientRect() we'll overlap with the bullet for LI\n    // elements.  Calling getClientRects() and using the *first* rect appears to give us the correct location.\n    // Note: not to be used in Chrome as it randomly returns a zero-width rectangle from the previous line.\n\n\n    if (microsoft) {\n      box = range.getClientRects()[0];\n    }\n\n    var str = range.toString();\n\n    if (!/^(?:pre|pre-wrap)$/i.test(whiteSpace)) {\n      // node with non-significant space -- collapse whitespace.\n      str = str.replace(/\\s+/g, \" \");\n    } else if (/\\t/.test(str)) {\n      // with significant whitespace we need to do something about literal TAB characters.\n      // There's no TAB glyph in a font so they would be rendered in PDF as an empty box,\n      // and the whole text will stretch to fill the original width.  The core PDF lib\n      // does not have sufficient context to deal with it.\n      // calculate the starting column here, since we initially discarded any whitespace.\n      var cc = 0;\n\n      for (pos = origStart; pos < range.startOffset; ++pos) {\n        var code = text.charCodeAt(pos);\n\n        if (code == 9) {\n          // when we meet a TAB we must round up to the next tab stop.\n          // in all browsers TABs seem to be 8 characters.\n          cc += 8 - cc % 8;\n        } else if (code == 10 || code == 13) {\n          // just in case we meet a newline we must restart.\n          cc = 0;\n        } else {\n          // ordinary character --> advance one column\n          cc++;\n        }\n      } // based on starting column, replace any TAB characters in the string we actually\n      // have to display with spaces so that they align to columns multiple of 8.\n\n\n      while ((pos = str.search(\"\\t\")) >= 0) {\n        var indent = \"        \".substr(0, 8 - (cc + pos) % 8);\n        str = str.substr(0, pos) + indent + str.substr(pos + 1);\n      }\n    }\n\n    if (!found) {\n      prevLineBottom = box.bottom;\n    }\n\n    drawText(str, box);\n  }\n\n  function drawText(str, box) {\n    // In IE the box height will be approximately lineHeight, while in\n    // other browsers it'll (correctly) be the height of the bounding\n    // box for the current text/font.  Which is to say, IE sucks again.\n    // The only good solution I can think of is to measure the text\n    // ourselves and center the bounding box.\n    if (microsoft && !isNaN(lineHeight)) {\n      var height = getFontHeight(font);\n      var top = (box.top + box.bottom - height) / 2;\n      box = {\n        top: top,\n        right: box.right,\n        bottom: top + height,\n        left: box.left,\n        height: height,\n        width: box.right - box.left\n      };\n    } // var path = new Path({ stroke: { color: \"red\" }});\n    // path.moveTo(box.left, box.top)\n    //     .lineTo(box.right, box.top)\n    //     .lineTo(box.right, box.bottom)\n    //     .lineTo(box.left, box.bottom)\n    //     .close();\n    // group.append(path);\n\n\n    switch (textTransform) {\n      case \"uppercase\":\n        str = str.toUpperCase();\n        break;\n\n      case \"lowercase\":\n        str = str.toLowerCase();\n        break;\n\n      case \"capitalize\":\n        str = str.replace(/(?:^|\\s)\\S/g, function (l) {\n          return l.toUpperCase();\n        });\n        break;\n    }\n\n    var text = new TextRect(str, new geo.Rect([box.left, box.top], [box.width, box.height]), {\n      font: font,\n      fill: {\n        color: color\n      }\n    });\n    group.append(text);\n  }\n\n  function decorate(box) {\n    line(underline, box.bottom);\n    line(lineThrough, box.bottom - box.height / 2.7);\n    line(overline, box.top);\n\n    function line(color, ypos) {\n      if (color) {\n        var width = fontSize / 12;\n        var path = new Path({\n          stroke: {\n            width: width,\n            color: color\n          }\n        });\n        ypos -= width;\n        path.moveTo(box.left, ypos).lineTo(box.right, ypos);\n        group.append(path);\n      }\n    }\n  }\n}\n\nfunction groupInStackingContext(element, group, zIndex) {\n  var main;\n\n  if (zIndex != \"auto\") {\n    // use the current stacking context\n    main = nodeInfo._stackingContext.group;\n    zIndex = parseFloat(zIndex);\n  } else {\n    // normal flow â€” use given container.  we still have to\n    // figure out where should we insert this element with the\n    // assumption that its z-index is zero, as the group might\n    // already contain elements with higher z-index.\n    main = group;\n    zIndex = 0;\n  }\n\n  var a = main.children;\n\n  for (var i = 0; i < a.length; ++i) {\n    if (a[i]._dom_zIndex != null && a[i]._dom_zIndex > zIndex) {\n      break;\n    }\n  }\n\n  var tmp = new Group();\n  main.insert(i, tmp);\n  tmp._dom_zIndex = zIndex;\n\n  if (main !== group) {\n    // console.log(\"Placing\", element, \"in\", nodeInfo._stackingContext.element, \"at position\", i, \" / \", a.length);\n    // console.log(a.slice(i+1));\n    // if (nodeInfo._matrix) {\n    //     tmp.transform(nodeInfo._matrix);\n    // }\n    if (nodeInfo._clipbox) {\n      var m = nodeInfo._matrix.invert();\n\n      var r = nodeInfo._clipbox.transformCopy(m);\n\n      setClipping(tmp, Path.fromRect(r)); // console.log(r);\n      // tmp.append(Path.fromRect(r));\n      // tmp.append(new Text(element.className || element.id, r.topLeft()));\n    }\n  }\n\n  return tmp;\n}\n\nfunction renderElement(element, container) {\n  var style = getComputedStyle(element);\n  updateCounters(style);\n\n  if (/^(style|script|link|meta|iframe|col|colgroup)$/i.test(element.tagName)) {\n    return;\n  }\n\n  if (nodeInfo._clipbox == null) {\n    return;\n  }\n\n  var opacity = parseFloat(getPropertyValue(style, \"opacity\"));\n  var visibility = getPropertyValue(style, \"visibility\");\n  var display = getPropertyValue(style, \"display\");\n\n  if (opacity === 0 || visibility == \"hidden\" || display == \"none\") {\n    return;\n  }\n\n  var tr = getTransform(style);\n  var group;\n  var zIndex = getPropertyValue(style, \"z-index\");\n\n  if ((tr || opacity < 1) && zIndex == \"auto\") {\n    zIndex = 0;\n  }\n\n  group = groupInStackingContext(element, container, zIndex); // XXX: remove at some point\n  // group._pdfElement = element;\n  // group.options._pdfDebug = \"\";\n  // if (element.id) {\n  //     group.options._pdfDebug = \"#\" + element.id;\n  // }\n  // if (element.className) {\n  //     group.options._pdfDebug += \".\" + element.className.split(\" \").join(\".\");\n  // }\n\n  if (opacity < 1) {\n    group.opacity(opacity * group.opacity());\n  }\n\n  pushNodeInfo(element, style, group);\n\n  if (!tr) {\n    _renderWithPseudoElements(element, group);\n  } else {\n    saveStyle(element, function () {\n      // must clear transform, so getBoundingClientRect returns correct values.\n      pleaseSetPropertyValue(element.style, \"transform\", \"none\", \"important\"); // must also clear transitions, so correct values are returned *immediately*\n\n      pleaseSetPropertyValue(element.style, \"transition\", \"none\", \"important\"); // the presence of any transform makes it behave like it had position: relative,\n      // because why not.\n      // http://meyerweb.com/eric/thoughts/2011/09/12/un-fixing-fixed-elements-with-css-transforms/\n\n      if (getPropertyValue(style, \"position\") == \"static\") {\n        // but only if it's not already positioned. :-/\n        pleaseSetPropertyValue(element.style, \"position\", \"relative\", \"important\");\n      } // must translate to origin before applying the CSS\n      // transformation, then translate back.\n\n\n      var bbox = element.getBoundingClientRect();\n      var x = bbox.left + tr.origin[0];\n      var y = bbox.top + tr.origin[1];\n      var m = [1, 0, 0, 1, -x, -y];\n      m = mmul(m, tr.matrix);\n      m = mmul(m, [1, 0, 0, 1, x, y]);\n      m = setTransform(group, m);\n      nodeInfo._matrix = nodeInfo._matrix.multiplyCopy(m);\n\n      _renderWithPseudoElements(element, group);\n    });\n  }\n\n  popNodeInfo(); //drawDebugBox(element.getBoundingClientRect(), container);\n} // function drawDebugBox(box, group, color) {\n//     var path = Path.fromRect(new geo.Rect([ box.left, box.top ], [ box.width, box.height ]));\n//     if (color) {\n//         path.stroke(color);\n//     }\n//     group.append(path);\n// }\n// function dumpTextNode(node) {\n//     var txt = node.data.replace(/^\\s+/, \"\");\n//     if (txt.length < 100) {\n//         console.log(node.data.length + \": |\" + txt);\n//     } else {\n//         console.log(node.data.length + \": |\" + txt.substr(0, 50) + \"|...|\" + txt.substr(-50));\n//     }\n// }\n\n\nfunction mmul(a, b) {\n  var a1 = a[0],\n      b1 = a[1],\n      c1 = a[2],\n      d1 = a[3],\n      e1 = a[4],\n      f1 = a[5];\n  var a2 = b[0],\n      b2 = b[1],\n      c2 = b[2],\n      d2 = b[3],\n      e2 = b[4],\n      f2 = b[5];\n  return [a1 * a2 + b1 * c2, a1 * b2 + b1 * d2, c1 * a2 + d1 * c2, c1 * b2 + d1 * d2, e1 * a2 + f1 * c2 + e2, e1 * b2 + f1 * d2 + f2];\n}\n\nexport { drawDOM, drawText, getFontFaces };","map":{"version":3,"sources":["D:/Castro/Development/hr-management-portal/hr-management-portal/node_modules/@progress/kendo-drawing/dist/es/html/core.js"],"names":["geo","PDF","arabicToRoman","createPromise","measureText","mergeSort","parseColor","utils_parseColor","support","template","compileTemplate","Path","Text","Group","Image","Circle","LinearGradient","encodeBase64","browser","slice","thing","Array","prototype","call","KENDO_PSEUDO_ELEMENT","IMAGE_CACHE","nodeInfo","_root","inBrowser","window","microsoft","msie","edge","TextRect","str","rect","options","getOrigin","_pdfRect","__proto__","Object","create","constructor","rawBBox","addClass","el","cls","classList","add","className","removeClass","remove","split","reduce","a","word","push","join","setCSS","styles","keys","forEach","key","style","matches","Element","p","selector","webkitMatchesSelector","mozMatchesSelector","msMatchesSelector","s","indexOf","document","querySelectorAll","closest","test","String","nodeType","parentNode","cloneNodes","$","clone","cloneNode","$el","$clone","i","data","tagName","getContext","drawImage","removeAttribute","value","checked","selected","firstChild","nextSibling","appendChild","dive","node","_kendoExportVisual","canvases","length","canvas","orig","kendo","jQuery","getXY","x","y","isArray","drawDOM","element","promise","reject","getComputedStyle","Error","defineFont","getFontFaces","ownerDocument","scale","doOne","group","pos","getBoundingClientRect","setTransform","left","top","_clipbox","_matrix","Matrix","unit","_stackingContext","avoidLinks","_avoidLinks","renderElement","cacheImages","forceBreak","forcePageBreak","hasPaperSize","paperSize","paperOptions","getPaperOptions","def","pageWidth","pageHeight","margin","hasMargin","Boolean","right","bottom","pdf","multiPage","_ignoreMargin","handlePageBreaks","progress","canceled","pageNum","next","pages","page","append","totalPages","cancel","setTimeout","container","removeChild","resolve","makeTemplate","replace","div","createElement","innerHTML","firstElementChild","callback","doc","copy","_destructive","adjust","tfoot","ol","children","li","index","setAttribute","display","position","boxSizing","width","paddingLeft","paddingRight","overflow","insertBefore","beforePageBreak","whenImagesAreActuallyLoaded","doPageBreak","splitElement","makePage","bind","keepTogether","offsetHeight","tag","getAttribute","tableLayout","bottomPadding","parseFloat","getPropertyValue","bottomBorder","saveAdjust","isFirst","breakAtElement","fall","fallsOnMargin","splitText","firstInParent","first","table","colgroup","thead","grid","gridHead","querySelector","repeatHeaders","range","createRange","setStartBefore","setEndBefore","extractContents","preventBulletOnListItem","padding","height","clear","pageClassName","box","available","len","selectNodeContents","nextnode","findEOP","min","max","setEnd","toString","endOffset","drawText","pushNodeInfo","renderText","_renderElement","popNodeInfo","parseBackgroundImage","tok_linear_gradient","tok_percent","tok_length","tok_keyword","tok_angle","tok_whitespace","tok_popen","tok_pclose","tok_comma","tok_url","tok_content","cache1","cache2","parse","input","hasOwnProperty","skip_ws","m","exec","substr","read","token","read_stop","color","percent","match","toRGB","read_linear_gradient","propName","angle","to1","to2","stops","reverse","parseAngle","stop","type","to","read_url","url","tok","splitProperty","map","cache","separator","cacheKey","ret","last","in_paren","in_string","looking_at","rx","trim","substring","getFontURL","getFontHeight","font","result","styleSheets","doStylesheet","ss","rules","cssRules","ex","addRules","findFonts","rule","src","cssText","styleSheet","r","family","bold","italic","addRule","names","href","name","obj","getCounter","getAllCounters","values","getPrototypeOf","incCounter","inc","resetCounter","val","doCounters","f","isNaN","updateCounters","counterReset","counterIncrement","css","toCssRgba","elements","pending","images","img","complete","onload","onerror","urls","bg","count","crossOrigin","alphaNumeral","n","fromCharCode","Math","floor","toLowerCase","decoration","createsStackingContext","updateClipbox","path","bbox","Rect","intersect","emptyClipbox","cb","prop","pseudoElt","defa","webkit","mozilla","opera","arguments","pleaseSetPropertyValue","important","setProperty","p1","p2","toUpperCase","getBorder","side","saveStyle","func","prev","getBorderRadius","sanitizeRadius","getContentBox","innerBox","wt","wr","wb","wl","getTransform","transform","matrix","origin","radiansToDegrees","radians","PI","num","shape","setClipping","clipPath","clip","addArcToPath","points","Arc","curvePoints","curveTo","adjustBorderRadiusForBox","rTL","rTR","rBR","rBL","tl_x","tl_y","tr_x","tr_y","br_x","br_y","bl_x","bl_y","tl","tr","br","bl","elementRoundBox","bt","bb","pt","pr","pb","pl","roundBox","rTL0","rTR0","rBR0","rBL0","tmp","fill","stroke","moveTo","startAngle","endAngle","radiusX","radiusY","lineTo","close","formatCounter","evalPseudoElementContent","content","displayCounter","parseInt","getCssText","_renderWithPseudoElements","fake","pseudo","kind","place","psel","textContent","saveClass","dir","backgroundColor","backgroundImage","backgroundRepeat","backgroundPosition","backgroundOrigin","backgroundSize","textOverflow","saveTextOverflow","version","currentStyle","innerbox","boxes","cells","getClientRects","adjustBoxes","drawOneBox","g","_pdfLink","drawBullet","clipit","isFormField","maybeRenderWidget","renderContents","tableBorderLeft","tableBorderTop","tableBox","firstCell","rows","firstCellBox","drawEdge","Wtop","Wleft","Wright","rl","rr","drawRoundCorner","ri","cos","sin","anticlockwise","drawBackground","background","drawOneBackground","drawBackgroundImage","gradientRenderer","img_width","img_height","renderBG","aspect_ratio","orgBox","size","rewX","rewY","repeatX","listStyleType","listStylePosition","_drawBullet","bullet","textAlign","elementIndex","k","fontSize","lineHeight","fontFamily","idx","isLast","shouldDrawLeft","shouldDrawRight","inv","gradient","atan2","pxlen","abs","scaledAngle","atan","tan","implicit","offset","start","end","fromRect","userSpace","console","log","visual","attr","widget","widgetInstance","exportDOMVisual","exportVisual","wrap","translate","renderImage","image","zIndexSort","b","sa","sb","za","zb","pa","getSelectedOption","selectedOptions","selectedIndex","renderCheckbox","renderFormField","option","whiteSpace","multiple","scrollLeft","scrollTop","xml","XMLSerializer","serializeToString","dataURL","toDataURL","floats","positioned","floating","text","search","align","isJustified","columnCount","textTransform","estimateLineLength","prevLineBottom","underline","lineThrough","overline","hasDecoration","doChunk","selectNode","decorate","actuallyGetRangeBoundingRect","chrome","rectangles","Infinity","done","origStart","setStart","found","findEOL","eol","startOffset","cc","code","charCodeAt","indent","l","line","ypos","groupInStackingContext","zIndex","main","_dom_zIndex","insert","invert","transformCopy","opacity","visibility","mmul","multiplyCopy","a1","b1","c1","d1","e1","f1","a2","b2","c2","d2","e2","f2"],"mappings":"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","sourcesContent":["/* eslint-disable no-multi-spaces, key-spacing, indent, camelcase, space-before-blocks, eqeqeq, brace-style */\n/* eslint-disable space-infix-ops, space-before-function-paren, array-bracket-spacing, object-curly-spacing */\n/* eslint-disable no-nested-ternary, max-params, default-case, no-else-return, no-empty, yoda */\n/* eslint-disable no-param-reassign, no-var, block-scoped-var */\n\nimport * as geo from \"../geometry\";\nimport * as PDF from \"../pdf\";\nimport { arabicToRoman, createPromise, measureText, mergeSort } from '../util';\nimport { parseColor as utils_parseColor, support, template as compileTemplate } from \"../common\";\nimport { Path, Text, Group, Image, Circle, LinearGradient } from \"../drawing\";\nimport { encodeBase64 } from \"../util\";\n\nvar browser = support.browser || {};\n/*\n\n  XXX: to test:\n\n  - cloneNodes function:\n    - drawing document containing canvas with page breaking\n    - drawing document with named radio <input>-s (should not clear selection)\n    - IE9/IE10 don't support el.dataset; do they copy user data?\n\n  - repeating table headers/footers on page breaking\n\n  - forceBreak, keepTogether\n\n  - avoidLinks\n\n */\n\n/* -----[ local vars ]----- */\n\nfunction slice(thing) {\n    return Array.prototype.slice.call(thing);\n}\n\nvar KENDO_PSEUDO_ELEMENT = \"KENDO-PSEUDO-ELEMENT\";\n\nvar IMAGE_CACHE = {};\n\nvar nodeInfo = {};\nnodeInfo._root = nodeInfo;\n\n/* -----[ Custom Text node to speed up rendering in PDF ]----- */\n\nvar inBrowser = typeof window !== 'undefined';\nvar microsoft = inBrowser ? browser.msie || browser.edge : false;\n\nvar TextRect = (function (Text) {\n  function TextRect(str, rect, options) {\n        Text.call(this, str, rect.getOrigin(), options);\n        this._pdfRect = rect;\n    }\n\n  if ( Text ) TextRect.__proto__ = Text;\n  TextRect.prototype = Object.create( Text && Text.prototype );\n  TextRect.prototype.constructor = TextRect;\n    TextRect.prototype.rect = function rect () {\n        // this is the crux of it: we can avoid a call to\n        // measure(), which is what the base class does, since we\n        // already know the rect.  measure() is s-l-o-w.\n        return this._pdfRect;\n    };\n    TextRect.prototype.rawBBox = function rawBBox () {\n        // also let's avoid creating a new rectangle.\n        return this._pdfRect;\n    };\n\n  return TextRect;\n}(Text));\n\nfunction addClass(el, cls) {\n    if (el.classList) {\n        el.classList.add(cls);\n    } else {\n        el.className += \" \" + cls;\n    }\n}\n\nfunction removeClass(el, cls) {\n    if (el.classList) {\n        el.classList.remove(cls);\n    } else {\n        el.className = el.className.split(/\\s+/).reduce(function(a, word){\n            if (word != cls) {\n                a.push(word);\n            }\n            return a;\n        }, []).join(\" \");\n    }\n}\n\nfunction setCSS(el, styles) {\n    Object.keys(styles).forEach(function(key){\n        el.style[key] = styles[key];\n    });\n}\n\nvar matches = typeof Element !== \"undefined\" && Element.prototype && (function(p){\n    if (p.matches) {\n        return function(el, selector) { return el.matches(selector); };\n    }\n    if (p.webkitMatchesSelector) {\n        return function(el, selector) { return el.webkitMatchesSelector(selector); };\n    }\n    if (p.mozMatchesSelector) {\n        return function(el, selector) { return el.mozMatchesSelector(selector); };\n    }\n    if (p.msMatchesSelector) {\n        return function(el, selector) { return el.msMatchesSelector(selector); };\n    }\n    return function(s) {\n\treturn [].indexOf.call(document.querySelectorAll(s), this) !== -1;\n    };\n})(Element.prototype);\n\nfunction closest(el, selector) {\n    if (el.closest) {\n        return el.closest(selector);\n    }\n    // IE: stringifying rather than simply comparing with `document`,\n    // which is not iframe-proof and fails in editor export â€”\n    // https://github.com/telerik/kendo/issues/6721\n    while (el && !/^\\[object (?:HTML)?Document\\]$/.test(String(el))) {\n        if (el.nodeType == 1 /* Element */ && matches(el, selector)) {\n            return el;\n        }\n        el = el.parentNode;\n    }\n}\n\n// clone nodes ourselves, so that we redraw <canvas> (DOM or\n// jQuery clone will not)\nvar cloneNodes = (function($){\n    if ($) {\n        // if we have Kendo and jQuery, use this version as it will\n        // maintain proper links between cloned element and Kendo\n        // widgets (i.e. it clones jQuery data(), which isn't the same\n        // as element's data attributes).\n        // https://github.com/telerik/kendo-ui-core/issues/2750\n        return function cloneNodes(el) {\n            var clone = el.cloneNode(false);\n            if (el.nodeType == 1 /* Element */) {\n                var $el = $(el), $clone = $(clone), i;\n                var data = $el.data();\n                for (i in data) {\n                    $clone.data(i, data[i]);\n                }\n                if (/^canvas$/i.test(el.tagName)) {\n                    clone.getContext(\"2d\").drawImage(el, 0, 0);\n                } else if (/^(?:input|select|textarea|option)$/i.test(el.tagName)) {\n                    // drop the name attributes so that we don't affect the selection of the\n                    // original nodes (i.e. checked status of radio buttons) when we insert our copy\n                    // into the DOM.  https://github.com/telerik/kendo/issues/5409\n                    clone.removeAttribute(\"id\");\n                    clone.removeAttribute(\"name\");\n                    if (!/^textarea$/i.test(el.tagName)) {\n                        clone.value = el.value;\n                    }\n                    clone.checked = el.checked;\n                    clone.selected = el.selected;\n                }\n                for (i = el.firstChild; i; i = i.nextSibling) {\n                    clone.appendChild(cloneNodes(i));\n                }\n            }\n            return clone;\n        };\n    } else {\n        // the no-jQuery version\n        return function cloneNodes(el) {\n            var clone = (function dive(node){\n                var clone = node.cloneNode(false);\n                if (node._kendoExportVisual) {\n                    clone._kendoExportVisual = node._kendoExportVisual;\n                }\n                for (var i = node.firstChild; i; i = i.nextSibling) {\n                    clone.appendChild(dive(i));\n                }\n                return clone;\n            })(el);\n\n            // re-draw canvases - https://github.com/telerik/kendo/issues/4872\n            var canvases = el.querySelectorAll(\"canvas\");\n            if (canvases.length) {\n                slice(clone.querySelectorAll(\"canvas\")).forEach(function (canvas, i) {\n                    canvas.getContext(\"2d\").drawImage(canvases[i], 0, 0);\n                });\n            }\n\n            // remove \"name\" attributes from <input> elements -\n            // https://github.com/telerik/kendo/issues/5409\n            var orig = el.querySelectorAll(\"input, select, textarea, option\");\n            slice(clone.querySelectorAll(\"input, select, textarea, option\")).forEach(function (el, i) {\n                el.removeAttribute(\"id\");\n                el.removeAttribute(\"name\");\n                if (!/^textarea$/i.test(el.tagName)) {\n                    el.value = orig[i].value;\n                }\n                el.checked = orig[i].checked;\n                el.selected = orig[i].selected;\n            });\n\n            return clone;\n        };\n    }\n})(typeof window !== \"undefined\" && window.kendo && window.kendo.jQuery);\n\nfunction getXY(thing) {\n    if (typeof thing == \"number\") {\n        return { x: thing, y: thing };\n    }\n    if (Array.isArray(thing)) {\n        return { x: thing[0], y: thing[1] };\n    }\n    return { x: thing.x, y: thing.y };\n}\n\nfunction drawDOM(element, options) {\n    if (!options) {\n        options = {};\n    }\n    var promise = createPromise();\n\n    if (!element) {\n        return promise.reject(\"No element to export\");\n    }\n\n    if (typeof window.getComputedStyle != \"function\") {\n        throw new Error(\"window.getComputedStyle is missing.  You are using an unsupported browser, or running in IE8 compatibility mode.  Drawing HTML is supported in Chrome, Firefox, Safari and IE9+.\");\n    }\n\n    PDF.defineFont(getFontFaces(element.ownerDocument));\n\n    var scale = getXY(options.scale || 1);\n\n    function doOne(element) {\n        var group = new Group();\n\n        // translate to start of page\n        var pos = element.getBoundingClientRect();\n        setTransform(group, [\n            scale.x,\n            0,\n            0,\n            scale.y,\n            (-pos.left * scale.x),\n            (-pos.top * scale.y)\n        ]);\n\n        nodeInfo._clipbox = false;\n        nodeInfo._matrix = geo.Matrix.unit();\n        nodeInfo._stackingContext = {\n            element: element,\n            group: group\n        };\n\n        if (options.avoidLinks === true) {\n            nodeInfo._avoidLinks = \"a\";\n        } else {\n            nodeInfo._avoidLinks = options.avoidLinks;\n        }\n\n        addClass(element, \"k-pdf-export\");\n        renderElement(element, group);\n        removeClass(element, \"k-pdf-export\");\n\n        return group;\n    }\n\n    cacheImages([ element ], function(){\n        var forceBreak = options && options.forcePageBreak;\n        var hasPaperSize = options && options.paperSize && options.paperSize != \"auto\";\n        var paperOptions = PDF.getPaperOptions(function(key, def){\n            if (key == \"paperSize\") {\n                // PDF.getPaperOptions croaks on \"auto\", just pass dummy A4 as we might\n                // still be interested in margins.\n                return hasPaperSize ? options[key] : \"A4\";\n            }\n            return key in options ? options[key] : def;\n        });\n        var pageWidth = hasPaperSize && paperOptions.paperSize[0];\n        var pageHeight = hasPaperSize && paperOptions.paperSize[1];\n        var margin = options.margin && paperOptions.margin;\n        var hasMargin = Boolean(margin);\n        if (forceBreak || pageHeight) {\n            if (!margin) {\n                margin = { left: 0, top: 0, right: 0, bottom: 0 };\n            }\n\n            // we want paper size and margin to be unaffected by\n            // scaling in the output, so we have to reverse-scale\n            // before our calculations begin.\n            if (pageWidth)  { pageWidth  /= scale.x; }\n            if (pageHeight) { pageHeight /= scale.y; }\n            margin.left   /= scale.x;\n            margin.right  /= scale.x;\n            margin.top    /= scale.y;\n            margin.bottom /= scale.y;\n\n            var group = new Group({\n                pdf: {\n                    multiPage     : true,\n                    paperSize     : hasPaperSize ? paperOptions.paperSize : \"auto\",\n                    _ignoreMargin : hasMargin // HACK!  see exportPDF in pdf/drawing.js\n                }\n            });\n            handlePageBreaks(\n                function(x) {\n                    if (options.progress) {\n                        var canceled = false, pageNum = 0;\n                        (function next(){\n                            if (pageNum < x.pages.length) {\n                                var page = doOne(x.pages[pageNum]);\n                                group.append(page);\n                                options.progress({\n                                    page: page,\n                                    pageNum: ++pageNum,\n                                    totalPages: x.pages.length,\n                                    cancel: function() {\n                                        canceled = true;\n                                    }\n                                });\n                                if (!canceled) {\n                                    setTimeout(next);\n                                } else {\n                                    // XXX: should we also fail() the deferred object?\n                                    x.container.parentNode.removeChild(x.container);\n                                }\n                            } else {\n                                x.container.parentNode.removeChild(x.container);\n                                promise.resolve(group);\n                            }\n                        })();\n                    } else {\n                        x.pages.forEach(function(page){\n                            group.append(doOne(page));\n                        });\n                        x.container.parentNode.removeChild(x.container);\n                        promise.resolve(group);\n                    }\n                },\n                element,\n                forceBreak,\n                pageWidth ? pageWidth - margin.left - margin.right : null,\n                pageHeight ? pageHeight - margin.top - margin.bottom : null,\n                margin,\n                options\n            );\n        } else {\n            promise.resolve(doOne(element));\n        }\n    });\n\n    function makeTemplate(template) {\n        if (template != null) {\n            if (typeof template == \"string\") {\n                template = compileTemplate(template.replace(/^\\s+|\\s+$/g, \"\"));\n            }\n            if (typeof template == \"function\") {\n                return function(data) {\n                    var el = template(data);\n                    if (el && typeof el == \"string\") {\n                        var div = document.createElement(\"div\");\n                        div.innerHTML = el;\n                        el = div.firstElementChild;\n                    }\n                    return el;\n                };\n            }\n            // assumed DOM element\n            return function() {\n                return template.cloneNode(true);\n            };\n        }\n    }\n\n    function handlePageBreaks(callback, element, forceBreak, pageWidth, pageHeight, margin, options) {\n        var template = makeTemplate(options.template);\n        var doc = element.ownerDocument;\n        var pages = [];\n        var copy = options._destructive ? element : cloneNodes(element);\n        var container = doc.createElement(\"KENDO-PDF-DOCUMENT\");\n        var adjust = 0;\n\n        // make sure <tfoot> elements are at the end (Grid widget\n        // places TFOOT before TBODY, tricking our algorithm to\n        // insert a page break right after the header).\n        // https://github.com/telerik/kendo/issues/4699\n        slice(copy.querySelectorAll(\"tfoot\")).forEach(function(tfoot){\n            tfoot.parentNode.appendChild(tfoot);\n        });\n\n        // remember the index of each LI from an ordered list.\n        // we'll use it to reconstruct the proper numbering.\n        slice(copy.querySelectorAll(\"ol\")).forEach(function(ol){\n            slice(ol.children).forEach(function(li, index){\n                li.setAttribute(\"kendo-split-index\", index);\n            });\n        });\n\n        setCSS(container, {\n            display   : \"block\",\n            position  : \"absolute\",\n            boxSizing : \"content-box\",\n            left      : \"-10000px\",\n            top       : \"-10000px\"\n        });\n\n        if (pageWidth) {\n            // subtle: if we don't set the width *and* margins here, the layout in this\n            // container will be different from the one in our final page elements, and we'll\n            // split at the wrong places.\n            setCSS(container, {\n                width        : pageWidth + \"px\",\n                paddingLeft  : margin.left + \"px\",\n                paddingRight : margin.right + \"px\"\n            });\n\n            // when the first element has a margin-top (i.e. a <h1>) the page will be\n            // inadvertently enlarged by that number (the browser will report the container's\n            // bounding box top to start at the element's top, rather than including its\n            // margin).  Adding overflow: hidden seems to fix it.\n            //\n            // to understand the difference, try the following snippets in your browser:\n            //\n            // 1. <div style=\"background: yellow\">\n            //      <h1 style=\"margin: 3em\">Foo</h1>\n            //    </div>\n            //\n            // 2. <div style=\"background: yellow; overflow: hidden\">\n            //      <h1 style=\"margin: 3em\">Foo</h1>\n            //    </div>\n            //\n            // this detail is not important when automatic page breaking is not requested, hence\n            // doing it only if pageWidth is defined.\n            setCSS(copy, { overflow: \"hidden\" });\n        }\n\n        element.parentNode.insertBefore(container, element);\n        container.appendChild(copy);\n\n        // With cache disabled, images will still have height zero until their `complete` attribute\n        // is true.  `whenImagesAreActuallyLoaded` will wait for it.\n        if (options.beforePageBreak) {\n            whenImagesAreActuallyLoaded([ container ], function() {\n                options.beforePageBreak(container, doPageBreak);\n            });\n        } else {\n            whenImagesAreActuallyLoaded([ container ], doPageBreak);\n        }\n\n        function doPageBreak() {\n            if (forceBreak != \"-\" || pageHeight) {\n                splitElement(copy);\n            }\n\n            {\n                var page = makePage();\n                copy.parentNode.insertBefore(page, copy);\n                page.appendChild(copy);\n            }\n\n            if (template) {\n                pages.forEach(function(page, i){\n                    var el = template({\n                        element    : page,\n                        pageNum    : i + 1,\n                        totalPages : pages.length\n                    });\n                    if (el) {\n                        page.appendChild(el);\n                    }\n                });\n            }\n\n            cacheImages(pages, callback.bind(null, { pages: pages, container: container }));\n        }\n\n        function keepTogether(el) {\n            if (options.keepTogether && matches(el, options.keepTogether) && el.offsetHeight <= pageHeight - adjust) {\n                return true;\n            }\n\n            var tag = el.tagName;\n            if (/^h[1-6]$/i.test(tag) && el.offsetHeight >= pageHeight - adjust) {\n                return false;\n            }\n\n            return (el.getAttribute(\"data-kendo-chart\") ||\n                    /^(?:img|tr|thead|th|tfoot|iframe|svg|object|canvas|input|textarea|select|video|h[1-6])/i.test(el.tagName));\n        }\n\n        function splitElement(element) {\n            if (element.tagName == \"TABLE\") {\n                setCSS(element, { tableLayout: \"fixed\" });\n            }\n            if (keepTogether(element)) {\n                return;\n            }\n            var style = getComputedStyle(element);\n            var bottomPadding = parseFloat(getPropertyValue(style, \"padding-bottom\"));\n            var bottomBorder = parseFloat(getPropertyValue(style, \"border-bottom-width\"));\n            var saveAdjust = adjust;\n            adjust += bottomPadding + bottomBorder;\n            var isFirst = true;\n            for (var el = element.firstChild; el; el = el.nextSibling) {\n                if (el.nodeType == 1 /* Element */) {\n                    isFirst = false;\n                    if (matches(el, forceBreak)) {\n                        breakAtElement(el);\n                        continue;\n                    }\n                    if (!pageHeight) {\n                        // we're in \"manual breaks mode\"\n                        splitElement(el);\n                        continue;\n                    }\n                    if (!/^(?:static|relative)$/.test(getPropertyValue(getComputedStyle(el), \"position\"))) {\n                        continue;\n                    }\n                    var fall = fallsOnMargin(el);\n                    if (fall == 1) {\n                        // element starts on next page, break before anyway.\n                        breakAtElement(el);\n                    }\n                    else if (fall) {\n                        // elements ends up on next page, or possibly doesn't fit on a page at\n                        // all.  break before it anyway if it's an <img> or <tr>, otherwise\n                        // attempt to split.\n                        if (keepTogether(el)) {\n                            breakAtElement(el);\n                        } else {\n                            splitElement(el);\n                        }\n                    }\n                    else {\n                        splitElement(el);\n                    }\n                }\n                else if (el.nodeType == 3 /* Text */ && pageHeight) {\n                    splitText(el, isFirst);\n                    isFirst = false;\n                }\n            }\n            adjust = saveAdjust;\n        }\n\n        function firstInParent(el) {\n            var p = el.parentNode, first = p.firstChild;\n            if (el === first) {\n                return true;\n            }\n            if (el === p.children[0]) {\n                if (first.nodeType == 7 /* comment */ ||\n                    first.nodeType == 8 /* processing instruction */) {\n                    return true;\n                }\n                if (first.nodeType == 3 /* text */) {\n                    // if whitespace only we can probably consider it's first\n                    return !/\\S/.test(first.data);\n                }\n            }\n            return false;\n        }\n\n        function breakAtElement(el) {\n            if (el.nodeType == 1 && el !== copy && firstInParent(el)) {\n                return breakAtElement(el.parentNode);\n            }\n            var table, colgroup, thead, grid, gridHead;\n            table = closest(el, \"table\");\n            colgroup = table && table.querySelector(\"colgroup\");\n            if (options.repeatHeaders) {\n                thead = table && table.querySelector(\"thead\");\n\n                // If we break page in a Kendo Grid, repeat its header.  This ugly hack is\n                // necessary because a scrollable grid will keep the header in a separate\n                // <table> element from its content.\n                //\n                // XXX: This is likely to break as soon as the widget HTML is modified.\n                grid = closest(el, \".k-grid.k-widget\");\n                if (grid && grid.querySelector(\".k-auto-scrollable\")) {\n                    gridHead = grid.querySelector(\".k-grid-header\");\n                }\n            }\n            var page = makePage();\n            var range = doc.createRange();\n            range.setStartBefore(copy);\n            range.setEndBefore(el);\n            page.appendChild(range.extractContents());\n            copy.parentNode.insertBefore(page, copy);\n            preventBulletOnListItem(el.parentNode);\n            if (table) {\n                table = closest(el, \"table\"); // that's the <table> on next page!\n                if (options.repeatHeaders && thead) {\n                    table.insertBefore(thead.cloneNode(true), table.firstChild);\n                }\n                if (colgroup) {\n                    table.insertBefore(colgroup.cloneNode(true), table.firstChild);\n                }\n            }\n            if (options.repeatHeaders && gridHead) {\n                grid = closest(el, \".k-grid.k-widget\");\n                grid.insertBefore(gridHead.cloneNode(true), grid.firstChild);\n            }\n        }\n\n        function makePage() {\n            var page = doc.createElement(\"KENDO-PDF-PAGE\");\n            setCSS(page, {\n                display  : \"block\",\n                boxSizing: \"content-box\",\n                width    : pageWidth ? (pageWidth + \"px\") : \"auto\",\n                padding  : (margin.top + \"px \" +\n                            margin.right + \"px \" +\n                            margin.bottom + \"px \" +\n                            margin.left + \"px\"),\n\n                // allow absolutely positioned elements to be relative to current page\n                position : \"relative\",\n\n                // without the following we might affect layout of subsequent pages\n                height   : pageHeight ? (pageHeight + \"px\") : \"auto\",\n                overflow : pageHeight || pageWidth ? \"hidden\" : \"visible\",\n                clear    : \"both\"\n            });\n\n            // debug\n            // $(\"<div>\").css({\n            //     position  : \"absolute\",\n            //     left      : margin.left,\n            //     top       : margin.top,\n            //     width     : pageWidth,\n            //     height    : pageHeight,\n            //     boxSizing : \"border-box\",\n            //     background: \"rgba(255, 255, 0, 0.5)\"\n            //     //border    : \"1px solid red\"\n            // }).appendTo(page);\n\n            if (options && options.pageClassName) {\n                page.className = options.pageClassName;\n            }\n            pages.push(page);\n            return page;\n        }\n\n        function fallsOnMargin(thing) {\n            var box = thing.getBoundingClientRect();\n            if (box.width === 0 || box.height === 0) {\n                // I'd say an element with dimensions zero fits on current page.\n                return 0;\n            }\n            var top = copy.getBoundingClientRect().top;\n            var available = pageHeight - adjust;\n            return (box.height > available) ? 3\n                : (box.top - top > available) ? 1\n                : (box.bottom - top > available) ? 2\n                : 0;\n        }\n\n        function splitText(node, isFirst) {\n            if (!/\\S/.test(node.data)) {\n                return;\n            }\n\n            var len = node.data.length;\n            var range = doc.createRange();\n            range.selectNodeContents(node);\n            var fall = fallsOnMargin(range);\n            if (!fall) {\n                return;     // the whole text fits on current page\n            }\n\n            var nextnode = node;\n            if (fall == 1) {\n                // starts on next page, break before anyway.\n                if (isFirst) {\n                    // avoid leaving an empty <p>, <li>, etc. on previous page.\n                    breakAtElement(node.parentNode);\n                } else {\n                    breakAtElement(node);\n                }\n            }\n            else {\n                (function findEOP(min, pos, max) {\n                    range.setEnd(node, pos);\n                    if (min == pos || pos == max) {\n                        return pos;\n                    }\n                    if (fallsOnMargin(range)) {\n                        return findEOP(min, (min + pos) >> 1, pos);\n                    } else {\n                        return findEOP(pos, (pos + max) >> 1, max);\n                    }\n                })(0, len >> 1, len);\n\n                if (!/\\S/.test(range.toString()) && isFirst) {\n                    // avoid leaving an empty <p>, <li>, etc. on previous page.\n                    breakAtElement(node.parentNode);\n                } else {\n                    // This is only needed for IE, but it feels cleaner to do it anyway.  Without\n                    // it, IE will truncate a very long text (playground/pdf-long-text-2.html).\n                    nextnode = node.splitText(range.endOffset);\n\n                    var page = makePage();\n                    range.setStartBefore(copy);\n                    page.appendChild(range.extractContents());\n                    copy.parentNode.insertBefore(page, copy);\n                    preventBulletOnListItem(nextnode.parentNode);\n                }\n            }\n\n            splitText(nextnode);\n        }\n\n        function preventBulletOnListItem(el) {\n            // set a hint on continued LI elements, to tell the\n            // renderer not to draw the bullet again.\n            // https://github.com/telerik/kendo-ui-core/issues/2732\n            var li = closest(el, \"li\");\n            if (li) {\n                li.setAttribute(\"kendo-no-bullet\", \"1\");\n                preventBulletOnListItem(li.parentNode);\n            }\n        }\n    }\n\n    return promise;\n}\n\n// This is needed for the Spreadsheet print functionality.  Since\n// there we only need to draw text, this cuts through the ceremony\n// of drawDOM/renderElement and renders the text node directly.\nfunction drawText(element) {\n    var group = new Group();\n    nodeInfo._clipbox = false;\n    nodeInfo._matrix = geo.Matrix.unit();\n    nodeInfo._stackingContext = {\n        element: element,\n        group: group\n    };\n    pushNodeInfo(element, getComputedStyle(element), group);\n    if (element.firstChild.nodeType == 3 /* Text */) {\n        // avoid the penalty of renderElement\n        renderText(element, element.firstChild, group);\n    } else {\n        _renderElement(element, group);\n    }\n    popNodeInfo();\n    return group;\n}\n\nvar parseBackgroundImage = (function(){\n    var tok_linear_gradient  = /^((-webkit-|-moz-|-o-|-ms-)?linear-gradient\\s*)\\(/;\n    //var tok_radial_gradient  = /^((-webkit-|-moz-|-o-|-ms-)?radial-gradient\\s*)\\(/;\n    var tok_percent          = /^([-0-9.]+%)/;\n    var tok_length           = /^([-0-9.]+px)/;\n    var tok_keyword          = /^(left|right|top|bottom|to|center)\\W/;\n    var tok_angle            = /^([-0-9.]+(deg|grad|rad|turn)|0)/;\n    var tok_whitespace       = /^(\\s+)/;\n    var tok_popen            = /^(\\()/;\n    var tok_pclose           = /^(\\))/;\n    var tok_comma            = /^(,)/;\n    var tok_url              = /^(url)\\(/;\n    var tok_content          = /^(.*?)\\)/;\n\n    var cache1 = {}, cache2 = {};\n\n    function parse(input) {\n        var orig = input;\n        if (hasOwnProperty(cache1, orig)) {\n            return cache1[orig];\n        }\n        function skip_ws() {\n            var m = tok_whitespace.exec(input);\n            if (m) {\n                input = input.substr(m[1].length);\n            }\n        }\n        function read(token) {\n            skip_ws();\n            var m = token.exec(input);\n            if (m) {\n                input = input.substr(m[1].length);\n                return m[1];\n            }\n        }\n\n        function read_stop() {\n            var color = utils_parseColor(input, true);\n            var length, percent;\n            if (color) {\n                var match =\n                    /^#[0-9a-f]+/i.exec(input) ||\n                    /^rgba?\\(.*?\\)/i.exec(input) ||\n                    /^..*?\\b/.exec(input); // maybe named color\n                input = input.substr(match[0].length);\n                color = color.toRGB();\n                if (!(length = read(tok_length))) {\n                    percent = read(tok_percent);\n                }\n                return { color: color, length: length, percent: percent };\n            }\n        }\n\n        function read_linear_gradient(propName) {\n            var angle;\n            var to1, to2;\n            var stops = [];\n            var reverse = false;\n\n            if (read(tok_popen)) {\n                // 1. [ <angle> || to <side-or-corner>, ]?\n                angle = read(tok_angle);\n                if (angle == \"0\") {\n                    angle = \"0deg\"; // Edge\n                }\n                if (angle) {\n                    angle = parseAngle(angle);\n                    read(tok_comma);\n                }\n                else {\n                    to1 = read(tok_keyword);\n                    if (to1 == \"to\") {\n                        to1 = read(tok_keyword);\n                    } else if (to1 && /^-/.test(propName)) {\n                        reverse = true;\n                    }\n                    to2 = read(tok_keyword);\n                    read(tok_comma);\n                }\n\n                if (/-moz-/.test(propName) && angle == null && to1 == null) {\n                    var x = read(tok_percent), y = read(tok_percent);\n                    reverse = true;\n                    if (x == \"0%\") {\n                        to1 = \"left\";\n                    } else if (x == \"100%\") {\n                        to1 = \"right\";\n                    }\n                    if (y == \"0%\") {\n                        to2 = \"top\";\n                    } else if (y == \"100%\") {\n                        to2 = \"bottom\";\n                    }\n                    read(tok_comma);\n                }\n\n                // 2. color stops\n                while (input && !read(tok_pclose)) {\n                    var stop = read_stop();\n                    if (!stop) {\n                        break;\n                    }\n                    stops.push(stop);\n                    read(tok_comma);\n                }\n\n                return {\n                    type    : \"linear\",\n                    angle   : angle,\n                    to      : to1 && to2 ? to1 + \" \" + to2 : to1 ? to1 : to2 ? to2 : null,\n                    stops   : stops,\n                    reverse : reverse\n                };\n            }\n        }\n\n        function read_url() {\n            if (read(tok_popen)) {\n                var url = read(tok_content);\n                url = url.replace(/^['\"]+|[\"']+$/g, \"\");\n                read(tok_pclose);\n                return { type: \"url\", url: url };\n            }\n        }\n\n        var tok;\n\n        if ((tok = read(tok_linear_gradient))) {\n            tok = read_linear_gradient(tok);\n        }\n        else if ((tok = read(tok_url))) {\n            tok = read_url();\n        }\n\n        return (cache1[orig] = tok || { type: \"none\" });\n    }\n\n    return function(input) {\n        if (hasOwnProperty(cache2, input)) {\n            return cache2[input];\n        }\n        return (cache2[input] = splitProperty(input).map(parse));\n    };\n})();\n\nvar splitProperty = (function(){\n    var cache = {};\n    return function(input, separator) {\n        if (!separator) {\n            separator = /^\\s*,\\s*/;\n        }\n\n        var cacheKey = input + separator;\n\n        if (hasOwnProperty(cache, cacheKey)) {\n            return cache[cacheKey];\n        }\n\n        var ret = [];\n        var last = 0, pos = 0;\n        var in_paren = 0;\n        var in_string = false;\n        var m;\n\n        function looking_at(rx) {\n            return (m = rx.exec(input.substr(pos)));\n        }\n\n        function trim(str) {\n            return str.replace(/^\\s+|\\s+$/g, \"\");\n        }\n\n        while (pos < input.length) {\n            if (!in_string && looking_at(/^[\\(\\[\\{]/)) {\n                in_paren++;\n                pos++;\n            }\n            else if (!in_string && looking_at(/^[\\)\\]\\}]/)) {\n                in_paren--;\n                pos++;\n            }\n            else if (!in_string && looking_at(/^[\\\"\\']/)) {\n                in_string = m[0];\n                pos++;\n            }\n            else if (in_string == \"'\" && looking_at(/^\\\\\\'/)) {\n                pos += 2;\n            }\n            else if (in_string == '\"' && looking_at(/^\\\\\\\"/)) {\n                pos += 2;\n            }\n            else if (in_string == \"'\" && looking_at(/^\\'/)) {\n                in_string = false;\n                pos++;\n            }\n            else if (in_string == '\"' && looking_at(/^\\\"/)) {\n                in_string = false;\n                pos++;\n            }\n            else if (looking_at(separator)) {\n                if (!in_string && !in_paren && pos > last) {\n                    ret.push(trim(input.substring(last, pos)));\n                    last = pos + m[0].length;\n                }\n                pos += m[0].length;\n            }\n            else {\n                pos++;\n            }\n        }\n        if (last < pos) {\n            ret.push(trim(input.substring(last, pos)));\n        }\n        return (cache[cacheKey] = ret);\n    };\n})();\n\nvar getFontURL = (function(cache){\n    return function(el){\n        // XXX: for IE we get here the whole cssText of the rule,\n        // because the computedStyle.src is empty.  Next time we need\n        // to fix these regexps we better write a CSS parser. :-\\\n        var url = cache[el];\n        if (!url) {\n            var m;\n            if ((m = /url\\((['\"]?)([^'\")]*?)\\1\\)\\s+format\\((['\"]?)truetype\\3\\)/.exec(el))) {\n                url = cache[el] = m[2];\n            } else if ((m = /url\\((['\"]?)([^'\")]*?\\.ttf)\\1\\)/.exec(el))) {\n                url = cache[el] = m[2];\n            }\n        }\n        return url;\n    };\n})(Object.create(null));\n\nvar getFontHeight = (function(cache){\n    return function(font) {\n        var height = cache[font];\n        if (height == null) {\n            height = cache[font] = measureText(\"Mapq\", { font: font }).height;\n        }\n        return height;\n    };\n})(Object.create(null));\n\nfunction getFontFaces(doc) {\n    if (doc == null) {\n        doc = document;\n    }\n    var result = {};\n    for (var i = 0; i < doc.styleSheets.length; ++i) {\n        doStylesheet(doc.styleSheets[i]);\n    }\n    return result;\n    function doStylesheet(ss) {\n        if (ss) {\n            var rules = null;\n            try {\n                rules = ss.cssRules;\n            } catch (ex) {}\n            if (rules) {\n                addRules(ss, rules);\n            }\n        }\n    }\n    function findFonts(rule) {\n        var src = getPropertyValue(rule.style, \"src\");\n        if (src) {\n            return splitProperty(src).reduce(function(a, el){\n                var font = getFontURL(el);\n                if (font) {\n                    a.push(font);\n                }\n                return a;\n            }, []);\n        } else {\n            // Internet Explorer\n            // XXX: this is gross.  should work though for valid CSS.\n            var font = getFontURL(rule.cssText);\n            return font ? [ font ] : [];\n        }\n    }\n    function addRules(styleSheet, rules) {\n        for (var i = 0; i < rules.length; ++i) {\n            var r = rules[i];\n            switch (r.type) {\n              case 3:       // CSSImportRule\n                doStylesheet(r.styleSheet);\n                break;\n              case 5:       // CSSFontFaceRule\n                var style  = r.style;\n                var family = splitProperty(getPropertyValue(style, \"font-family\"));\n                var bold   = /^([56789]00|bold)$/i.test(getPropertyValue(style, \"font-weight\"));\n                var italic = \"italic\" == getPropertyValue(style, \"font-style\");\n                var src    = findFonts(r);\n                if (src.length > 0) {\n                    addRule(styleSheet, family, bold, italic, src[0]);\n                }\n            }\n        }\n    }\n    function addRule(styleSheet, names, bold, italic, url) {\n        // We get full resolved absolute URLs in Chrome, but sadly\n        // not in Firefox.\n        if (!(/^data:/i.test(url))) {\n            if (!(/^[^\\/:]+:\\/\\//.test(url) || /^\\//.test(url))) {\n                url = String(styleSheet.href).replace(/[^\\/]*$/, \"\") + url;\n            }\n        }\n        names.forEach(function(name){\n            name = name.replace(/^(['\"]?)(.*?)\\1$/, \"$2\"); // it's quoted\n            if (bold) {\n                name += \"|bold\";\n            }\n            if (italic) {\n                name += \"|italic\";\n            }\n            result[name] = url;\n        });\n    }\n}\n\nfunction hasOwnProperty(obj, key) {\n    return Object.prototype.hasOwnProperty.call(obj, key);\n}\n\nfunction getCounter(name) {\n    name = \"_counter_\" + name;\n    return nodeInfo[name];\n}\n\nfunction getAllCounters(name) {\n    var values = [], p = nodeInfo;\n    name = \"_counter_\" + name;\n    while (p) {\n        if (hasOwnProperty(p, name)) {\n            values.push(p[name]);\n        }\n        p = Object.getPrototypeOf(p);\n    }\n    return values.reverse();\n}\n\nfunction incCounter(name, inc) {\n    var p = nodeInfo;\n    name = \"_counter_\" + name;\n    while (p && !hasOwnProperty(p, name)) {\n        p = Object.getPrototypeOf(p);\n    }\n    if (!p) {\n        p = nodeInfo._root;\n    }\n    p[name] = (p[name] || 0) + (inc == null ? 1 : inc);\n}\n\nfunction resetCounter(name, val) {\n    name = \"_counter_\" + name;\n    nodeInfo[name] = val == null ? 0 : val;\n}\n\nfunction doCounters(a, f, def) {\n    for (var i = 0; i < a.length;) {\n        var name = a[i++];\n        var val = parseFloat(a[i]);\n        if (isNaN(val)) {\n            f(name, def);\n        } else {\n            f(name, val);\n            ++i;\n        }\n    }\n}\n\nfunction updateCounters(style) {\n    var counterReset = getPropertyValue(style, \"counter-reset\");\n    if (counterReset) {\n        doCounters(splitProperty(counterReset, /^\\s+/), resetCounter, 0);\n    }\n    var counterIncrement = getPropertyValue(style, \"counter-increment\");\n    if (counterIncrement) {\n        doCounters(splitProperty(counterIncrement, /^\\s+/), incCounter, 1);\n    }\n}\n\nfunction parseColor(str, css) {\n    var color = utils_parseColor(str, true);\n    if (color) {\n        color = color.toRGB();\n        if (css) {\n            color = color.toCssRgba();\n        } else if (color.a === 0) {\n            color = null;\n        }\n    }\n    return color;\n}\n\nfunction whenImagesAreActuallyLoaded(elements, callback) {\n    var pending = 0;\n    elements.forEach(function(el){\n        var images = el.querySelectorAll(\"img\");\n        for (var i = 0; i < images.length; ++i) {\n            var img = images[i];\n            if (!img.complete) {\n                pending++;\n                img.onload = img.onerror = next;\n            }\n        }\n    });\n    if (!pending) {\n        next();\n    }\n    function next() {\n        if (--pending <= 0) {\n            callback();\n        }\n    }\n}\n\nfunction cacheImages(elements, callback) {\n    var urls = [];\n    function add(url) {\n        if (!IMAGE_CACHE[url]) {\n            IMAGE_CACHE[url] = true;\n            urls.push(url);\n        }\n    }\n\n    elements.forEach(function dive(element){\n        if (/^img$/i.test(element.tagName)) {\n            add(element.src);\n        }\n        parseBackgroundImage(\n            getPropertyValue(\n                getComputedStyle(element), \"background-image\"\n            )\n        ).forEach(function(bg){\n            if (bg.type == \"url\") {\n                add(bg.url);\n            }\n        });\n\n        if (element.children) {\n            slice(element.children).forEach(dive);\n        }\n    });\n\n    var count = urls.length;\n    function next() {\n        if (--count <= 0) {\n            // Even though we cached them, they simply won't be available immediately in the newly\n            // created DOM.  Previously we'd allow a 10ms timeout, but that's arbitrary and clearly\n            // not working in all cases (https://github.com/telerik/kendo/issues/5399), so this\n            // function will wait for their .complete attribute.\n            whenImagesAreActuallyLoaded(elements, callback);\n        }\n    }\n    if (count === 0) {\n        next();\n    }\n    urls.forEach(function(url){\n        var img = IMAGE_CACHE[url] = new window.Image();\n        if (!(/^data:/i.test(url))) {\n            img.crossOrigin = \"Anonymous\";\n        }\n        img.src = url;\n        if (img.complete) {\n            next();\n        } else {\n            img.onload = next;\n            img.onerror = function() {\n                IMAGE_CACHE[url] = null;\n                next();\n            };\n        }\n    });\n}\n\nfunction alphaNumeral(n) {\n    var result = \"\";\n    do {\n        var r = n % 26;\n        result = String.fromCharCode(97 + r) + result;\n        n = Math.floor(n / 26);\n    } while (n > 0);\n    return result;\n}\n\nfunction pushNodeInfo(element, style, group) {\n    nodeInfo = Object.create(nodeInfo);\n    nodeInfo[element.tagName.toLowerCase()] = {\n        element: element,\n        style: style\n    };\n    var decoration = getPropertyValue(style, \"text-decoration\");\n    if (decoration && decoration != \"none\") {\n        var color = getPropertyValue(style, \"color\");\n        decoration.split(/\\s+/g).forEach(function(name){\n            if (!nodeInfo[name]) {\n                nodeInfo[name] = color;\n            }\n        });\n    }\n\n    if (createsStackingContext(style)) {\n        nodeInfo._stackingContext = {\n            element: element,\n            group: group\n        };\n    }\n}\n\nfunction popNodeInfo() {\n    nodeInfo = Object.getPrototypeOf(nodeInfo);\n}\n\nfunction updateClipbox(path) {\n    if (nodeInfo._clipbox != null) {\n        var box = path.bbox(nodeInfo._matrix);\n        if (nodeInfo._clipbox) {\n            nodeInfo._clipbox = geo.Rect.intersect(nodeInfo._clipbox, box);\n        } else {\n            nodeInfo._clipbox = box;\n        }\n    }\n}\n\nfunction emptyClipbox() {\n    var cb = nodeInfo._clipbox;\n    if (cb == null) {\n        return true;\n    }\n    if (cb) {\n        return cb.width() === 0 || cb.height() === 0;\n    }\n}\n\nfunction createsStackingContext(style) {\n    function prop(name) { return getPropertyValue(style, name); }\n    if (prop(\"transform\") != \"none\" ||\n        prop(\"position\") != \"static\" ||\n        prop(\"z-index\") != \"auto\" ||\n        prop(\"opacity\") < 1) {\n        return true;\n    }\n}\n\nfunction getComputedStyle(element, pseudoElt) {\n    return window.getComputedStyle(element, pseudoElt || null);\n}\n\nfunction getPropertyValue(style, prop, defa) {\n    var val = style.getPropertyValue(prop);\n    if (val == null || val === \"\") {\n        if (browser.webkit) {\n            val = style.getPropertyValue(\"-webkit-\" + prop );\n        } else if (browser.mozilla) {\n            val = style.getPropertyValue(\"-moz-\" + prop );\n        } else if (browser.opera) {\n            val = style.getPropertyValue(\"-o-\" + prop);\n        } else if (microsoft) {\n            val = style.getPropertyValue(\"-ms-\" + prop);\n        }\n    }\n    if (arguments.length > 2 && (val == null || val === \"\")) {\n        return defa;\n    } else {\n        return val;\n    }\n}\n\nfunction pleaseSetPropertyValue(style, prop, value, important) {\n    style.setProperty(prop, value, important);\n    if (browser.webkit) {\n        style.setProperty(\"-webkit-\" + prop, value, important);\n    } else if (browser.mozilla) {\n        style.setProperty(\"-moz-\" + prop, value, important);\n    } else if (browser.opera) {\n        style.setProperty(\"-o-\" + prop, value, important);\n    } else if (microsoft) {\n        style.setProperty(\"-ms-\" + prop, value, important);\n        prop = \"ms\" + prop.replace(/(^|-)([a-z])/g, function(s, p1, p2){\n            return p1 + p2.toUpperCase();\n        });\n        style[prop] = value;\n    }\n}\n\nfunction getBorder(style, side) {\n    side = \"border-\" + side;\n    return {\n        width: parseFloat(getPropertyValue(style, side + \"-width\")),\n        style: getPropertyValue(style, side + \"-style\"),\n        color: parseColor(getPropertyValue(style, side + \"-color\"), true)\n    };\n}\n\nfunction saveStyle(element, func) {\n    var prev = element.style.cssText;\n    var result = func();\n    element.style.cssText = prev;\n    return result;\n}\n\nfunction getBorderRadius(style, side) {\n    var r = getPropertyValue(style, \"border-\" + side + \"-radius\").split(/\\s+/g).map(parseFloat);\n    if (r.length == 1) {\n        r.push(r[0]);\n    }\n    return sanitizeRadius({ x: r[0], y: r[1] });\n}\n\nfunction getContentBox(element) {\n    var box = element.getBoundingClientRect();\n    box = innerBox(box, \"border-*-width\", element);\n    box = innerBox(box, \"padding-*\", element);\n    return box;\n}\n\nfunction innerBox(box, prop, element) {\n    var style, wt, wr, wb, wl;\n    if (typeof prop == \"string\") {\n        style = getComputedStyle(element);\n        wt = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"top\")));\n        wr = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"right\")));\n        wb = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"bottom\")));\n        wl = parseFloat(getPropertyValue(style, prop.replace(\"*\", \"left\")));\n    }\n    else if (typeof prop == \"number\") {\n        wt = wr = wb = wl = prop;\n    }\n    return {\n        top    : box.top + wt,\n        right  : box.right - wr,\n        bottom : box.bottom - wb,\n        left   : box.left + wl,\n        width  : box.right - box.left - wr - wl,\n        height : box.bottom - box.top - wb - wt\n    };\n}\n\nfunction getTransform(style) {\n    var transform = getPropertyValue(style, \"transform\");\n    if (transform == \"none\") {\n        return null;\n    }\n    var matrix = /^\\s*matrix\\(\\s*(.*?)\\s*\\)\\s*$/.exec(transform);\n    if (matrix) {\n        var origin = getPropertyValue(style, \"transform-origin\");\n        matrix = matrix[1].split(/\\s*,\\s*/g).map(parseFloat);\n        origin = origin.split(/\\s+/g).map(parseFloat);\n        return {\n            matrix: matrix,\n            origin: origin\n        };\n    }\n}\n\nfunction radiansToDegrees(radians) {\n    return ((180 * radians) / Math.PI) % 360;\n}\n\nfunction parseAngle(angle) {\n    var num = parseFloat(angle);\n    if (/grad$/.test(angle)) {\n        return Math.PI * num / 200;\n    }\n    else if (/rad$/.test(angle)) {\n        return num;\n    }\n    else if (/turn$/.test(angle)) {\n        return Math.PI * num * 2;\n    }\n    else if (/deg$/.test(angle)) {\n        return Math.PI * num / 180;\n    }\n}\n\nfunction setTransform(shape, m) {\n    m = new geo.Matrix(m[0], m[1], m[2], m[3], m[4], m[5]);\n    shape.transform(m);\n    return m;\n}\n\nfunction setClipping(shape, clipPath) {\n    shape.clip(clipPath);\n}\n\nfunction addArcToPath(path, x, y, options) {\n    var points = new geo.Arc([ x, y ], options).curvePoints(), i = 1;\n    while (i < points.length) {\n        path.curveTo(points[i++], points[i++], points[i++]);\n    }\n}\n\nfunction sanitizeRadius(r) {\n    if (r.x <= 0 || r.y <= 0) {\n        r.x = r.y = 0;\n    }\n    return r;\n}\n\nfunction adjustBorderRadiusForBox(box, rTL, rTR, rBR, rBL) {\n    // adjust border radiuses such that the sum of adjacent\n    // radiuses is not bigger than the length of the side.\n    // seems the correct algorithm is variant (3) from here:\n    // http://www.w3.org/Style/CSS/Tracker/issues/29?changelog\n    var tl_x = Math.max(0, rTL.x), tl_y = Math.max(0, rTL.y);\n    var tr_x = Math.max(0, rTR.x), tr_y = Math.max(0, rTR.y);\n    var br_x = Math.max(0, rBR.x), br_y = Math.max(0, rBR.y);\n    var bl_x = Math.max(0, rBL.x), bl_y = Math.max(0, rBL.y);\n\n    var f = Math.min(\n        box.width / (tl_x + tr_x),\n        box.height / (tr_y + br_y),\n        box.width / (br_x + bl_x),\n        box.height / (bl_y + tl_y)\n    );\n\n    if (f < 1) {\n        tl_x *= f; tl_y *= f;\n        tr_x *= f; tr_y *= f;\n        br_x *= f; br_y *= f;\n        bl_x *= f; bl_y *= f;\n    }\n\n    return {\n        tl: { x: tl_x, y: tl_y },\n        tr: { x: tr_x, y: tr_y },\n        br: { x: br_x, y: br_y },\n        bl: { x: bl_x, y: bl_y }\n    };\n}\n\nfunction elementRoundBox(element, box, type) {\n    var style = getComputedStyle(element);\n\n    var rTL = getBorderRadius(style, \"top-left\");\n    var rTR = getBorderRadius(style, \"top-right\");\n    var rBL = getBorderRadius(style, \"bottom-left\");\n    var rBR = getBorderRadius(style, \"bottom-right\");\n\n    if (type == \"padding\" || type == \"content\") {\n        var bt = getBorder(style, \"top\");\n        var br = getBorder(style, \"right\");\n        var bb = getBorder(style, \"bottom\");\n        var bl = getBorder(style, \"left\");\n        rTL.x -= bl.width; rTL.y -= bt.width;\n        rTR.x -= br.width; rTR.y -= bt.width;\n        rBR.x -= br.width; rBR.y -= bb.width;\n        rBL.x -= bl.width; rBL.y -= bb.width;\n        if (type == \"content\") {\n            var pt = parseFloat(getPropertyValue(style, \"padding-top\"));\n            var pr = parseFloat(getPropertyValue(style, \"padding-right\"));\n            var pb = parseFloat(getPropertyValue(style, \"padding-bottom\"));\n            var pl = parseFloat(getPropertyValue(style, \"padding-left\"));\n            rTL.x -= pl; rTL.y -= pt;\n            rTR.x -= pr; rTR.y -= pt;\n            rBR.x -= pr; rBR.y -= pb;\n            rBL.x -= pl; rBL.y -= pb;\n        }\n    }\n\n    if (typeof type == \"number\") {\n        rTL.x -= type; rTL.y -= type;\n        rTR.x -= type; rTR.y -= type;\n        rBR.x -= type; rBR.y -= type;\n        rBL.x -= type; rBL.y -= type;\n    }\n\n    return roundBox(box, rTL, rTR, rBR, rBL);\n}\n\n// Create a drawing.Path for a rounded rectangle.  Receives the\n// bounding box and the border-radiuses in CSS order (top-left,\n// top-right, bottom-right, bottom-left).  The radiuses must be\n// objects containing x (horiz. radius) and y (vertical radius).\nfunction roundBox(box, rTL0, rTR0, rBR0, rBL0) {\n    var tmp = adjustBorderRadiusForBox(box, rTL0, rTR0, rBR0, rBL0);\n    var rTL = tmp.tl;\n    var rTR = tmp.tr;\n    var rBR = tmp.br;\n    var rBL = tmp.bl;\n    var path = new Path({ fill: null, stroke: null });\n    path.moveTo(box.left, box.top + rTL.y);\n    if (rTL.x) {\n        addArcToPath(path, box.left + rTL.x, box.top + rTL.y, {\n            startAngle: -180,\n            endAngle: -90,\n            radiusX: rTL.x,\n            radiusY: rTL.y\n        });\n    }\n    path.lineTo(box.right - rTR.x, box.top);\n    if (rTR.x) {\n        addArcToPath(path, box.right - rTR.x, box.top + rTR.y, {\n            startAngle: -90,\n            endAngle: 0,\n            radiusX: rTR.x,\n            radiusY: rTR.y\n        });\n    }\n    path.lineTo(box.right, box.bottom - rBR.y);\n    if (rBR.x) {\n        addArcToPath(path, box.right - rBR.x, box.bottom - rBR.y, {\n            startAngle: 0,\n            endAngle: 90,\n            radiusX: rBR.x,\n            radiusY: rBR.y\n        });\n    }\n    path.lineTo(box.left + rBL.x, box.bottom);\n    if (rBL.x) {\n        addArcToPath(path, box.left + rBL.x, box.bottom - rBL.y, {\n            startAngle: 90,\n            endAngle: 180,\n            radiusX: rBL.x,\n            radiusY: rBL.y\n        });\n    }\n    return path.close();\n}\n\nfunction formatCounter(val, style) {\n    var str = String(parseFloat(val));\n    switch (style) {\n      case \"decimal-leading-zero\":\n        if (str.length < 2) {\n            str = \"0\" + str;\n        }\n        return str;\n      case \"lower-roman\":\n        return arabicToRoman(val).toLowerCase();\n      case \"upper-roman\":\n        return arabicToRoman(val).toUpperCase();\n      case \"lower-latin\":\n      case \"lower-alpha\":\n        return alphaNumeral(val - 1);\n      case \"upper-latin\":\n      case \"upper-alpha\":\n        return alphaNumeral(val - 1).toUpperCase();\n      default:\n        return str;\n    }\n}\n\nfunction evalPseudoElementContent(element, content) {\n    function displayCounter(name, style, separator) {\n        if (!separator) {\n            return formatCounter(getCounter(name) || 0, style);\n        }\n        separator = separator.replace(/^\\s*([\"'])(.*)\\1\\s*$/, \"$2\");\n        return getAllCounters(name).map(function(val){\n            return formatCounter(val, style);\n        }).join(separator);\n    }\n    var a = splitProperty(content, /^\\s+/);\n    var result = [], m;\n    a.forEach(function(el){\n        var tmp;\n        if ((m = /^\\s*([\"'])(.*)\\1\\s*$/.exec(el))) {\n            result.push(m[2].replace(/\\\\([0-9a-f]{4})/gi, function(s, p){\n                return String.fromCharCode(parseInt(p, 16));\n            }));\n        }\n        else if ((m = /^\\s*counter\\((.*?)\\)\\s*$/.exec(el))) {\n            tmp = splitProperty(m[1]);\n            result.push(displayCounter(tmp[0], tmp[1]));\n        }\n        else if ((m = /^\\s*counters\\((.*?)\\)\\s*$/.exec(el))) {\n            tmp = splitProperty(m[1]);\n            result.push(displayCounter(tmp[0], tmp[2], tmp[1]));\n        }\n        else if ((m = /^\\s*attr\\((.*?)\\)\\s*$/.exec(el))) {\n            result.push(element.getAttribute(m[1]) || \"\");\n        }\n        else {\n            result.push(el);\n        }\n    });\n    return result.join(\"\");\n}\n\nfunction getCssText(style) {\n    if (style.cssText) {\n        return style.cssText;\n    }\n    // Status: NEW.  Report year: 2002.  Current year: 2014.\n    // Nice played, Mozillians.\n    // https://bugzilla.mozilla.org/show_bug.cgi?id=137687\n    var result = [];\n    for (var i = 0; i < style.length; ++i) {\n        result.push(style[i] + \": \" + getPropertyValue(style, style[i]));\n    }\n    return result.join(\";\\n\");\n}\n\nfunction _renderWithPseudoElements(element, group) {\n    if (element.tagName == KENDO_PSEUDO_ELEMENT) {\n        _renderElement(element, group);\n        return;\n    }\n    var fake = [];\n    function pseudo(kind, place) {\n        var style = getComputedStyle(element, kind), content = style.content;\n        updateCounters(style);\n        if (content && content != \"normal\" && content != \"none\" && style.width != \"0px\") {\n            var psel = element.ownerDocument.createElement(KENDO_PSEUDO_ELEMENT);\n            psel.style.cssText = getCssText(style);\n            psel.textContent = evalPseudoElementContent(element, content);\n            element.insertBefore(psel, place);\n            fake.push(psel);\n        }\n    }\n    pseudo(\":before\", element.firstChild);\n    pseudo(\":after\", null);\n    if (fake.length > 0) {\n        var saveClass = element.className;\n        element.className += \" kendo-pdf-hide-pseudo-elements\";\n        _renderElement(element, group);\n        element.className = saveClass;\n        fake.forEach(function(el){ element.removeChild(el); });\n    } else {\n        _renderElement(element, group);\n    }\n}\n\nfunction _renderElement(element, group) {\n    var style = getComputedStyle(element);\n\n    var top = getBorder(style, \"top\");\n    var right = getBorder(style, \"right\");\n    var bottom = getBorder(style, \"bottom\");\n    var left = getBorder(style, \"left\");\n\n    var rTL0 = getBorderRadius(style, \"top-left\");\n    var rTR0 = getBorderRadius(style, \"top-right\");\n    var rBL0 = getBorderRadius(style, \"bottom-left\");\n    var rBR0 = getBorderRadius(style, \"bottom-right\");\n\n    var dir = getPropertyValue(style, \"direction\");\n\n    var backgroundColor = getPropertyValue(style, \"background-color\");\n    backgroundColor = parseColor(backgroundColor);\n\n    var backgroundImage = parseBackgroundImage( getPropertyValue(style, \"background-image\") );\n    var backgroundRepeat = splitProperty( getPropertyValue(style, \"background-repeat\") );\n    var backgroundPosition = splitProperty( getPropertyValue(style, \"background-position\") );\n    var backgroundOrigin = splitProperty( getPropertyValue(style, \"background-origin\") );\n    var backgroundSize = splitProperty( getPropertyValue(style, \"background-size\") );\n\n    // IE shrinks the text with text-overflow: ellipsis,\n    // apparently because the returned bounding box for the range\n    // is limited to the visible area minus space for the dots,\n    // instead of being the full width of the text.\n    //\n    // https://github.com/telerik/kendo/issues/5232\n    // https://github.com/telerik/kendo-ui-core/issues/1868\n    //\n    // We have to test it here rather than in renderText because\n    // text-overflow: ellipsis could be set on a parent element (not\n    // necessarily the one containing the text); in this case,\n    // getComputedStyle(elementWithTheText) will return \"clip\", not\n    // \"ellipsis\" (which is probably a bug, but oh well...)\n    var textOverflow, saveTextOverflow;\n    if (microsoft) {\n        textOverflow = style.textOverflow;             // computed style\n        if (textOverflow == \"ellipsis\") {\n            saveTextOverflow = element.style.textOverflow; // own style.\n            element.style.textOverflow = \"clip\";\n        }\n    }\n\n    if (browser.msie && browser.version < 10) {\n        // IE9 hacks.  getPropertyValue won't return the correct\n        // value.  Sucks that we have to do it here, I'd prefer to\n        // move it in getPropertyValue, but we don't have the\n        // element.\n        backgroundPosition = splitProperty(element.currentStyle.backgroundPosition);\n    }\n\n    var innerbox = innerBox(element.getBoundingClientRect(), \"border-*-width\", element);\n\n    // CSS \"clip\" property - if present, replace the group with a\n    // new one which is clipped.  This must happen before drawing\n    // the borders and background.\n    (function(){\n        var clip = getPropertyValue(style, \"clip\");\n        var m = /^\\s*rect\\((.*)\\)\\s*$/.exec(clip);\n        if (m) {\n            var a = m[1].split(/[ ,]+/g);\n            var top = a[0] == \"auto\" ? innerbox.top : parseFloat(a[0]) + innerbox.top;\n            var right = a[1] == \"auto\" ? innerbox.right : parseFloat(a[1]) + innerbox.left;\n            var bottom = a[2] == \"auto\" ? innerbox.bottom : parseFloat(a[2]) + innerbox.top;\n            var left = a[3] == \"auto\" ? innerbox.left : parseFloat(a[3]) + innerbox.left;\n            var tmp = new Group();\n            var clipPath = new Path()\n                .moveTo(left, top)\n                .lineTo(right, top)\n                .lineTo(right, bottom)\n                .lineTo(left, bottom)\n                .close();\n            setClipping(tmp, clipPath);\n            group.append(tmp);\n            group = tmp;\n            updateClipbox(clipPath);\n        }\n    })();\n\n    var boxes, i, cells;\n    var display = getPropertyValue(style, \"display\");\n\n    if (display == \"table-row\") {\n        // because of rowspan/colspan, we shouldn't draw background of table row elements on the\n        // box given by its getBoundingClientRect, because if we do we risk overwritting a\n        // previously rendered cell.  https://github.com/telerik/kendo/issues/4881\n        boxes = [];\n        for (i = 0, cells = element.children; i < cells.length; ++i) {\n            boxes.push(cells[i].getBoundingClientRect());\n        }\n    } else {\n        boxes = element.getClientRects();\n        if (boxes.length == 1) {\n            // Workaround the missing borders in Chrome!  getClientRects() boxes contains values\n            // rounded to integer.  getBoundingClientRect() appears to work fine.  We still need\n            // getClientRects() to support cases where there are more boxes (continued inline\n            // elements that might have border/background).\n            boxes = [ element.getBoundingClientRect() ];\n        }\n    }\n\n    // This function workarounds another Chrome bug, where boxes returned for a table with\n    // border-collapse: collapse will overlap the table border.  Our rendering is not perfect in\n    // such case anyway, but with this is better than without it.\n    boxes = adjustBoxes(boxes);\n\n    for (i = 0; i < boxes.length; ++i) {\n        drawOneBox(boxes[i], i === 0, i == boxes.length - 1);\n    }\n\n    // Render links as separate groups.  We can't use boxes returned by element's getClientRects\n    // because if display type is \"inline\" (default for <a>), boxes will not include the height of\n    // images inside.  https://github.com/telerik/kendo-ui-core/issues/3359\n    if (element.tagName == \"A\" && element.href && !/^#?$/.test(element.getAttribute(\"href\"))) {\n        if (!nodeInfo._avoidLinks || !matches(element, nodeInfo._avoidLinks)) {\n            var r = document.createRange();\n            r.selectNodeContents(element);\n            slice(r.getClientRects()).forEach(function(box){\n                var g = new Group();\n                g._pdfLink = {\n                    url    : element.href,\n                    top    : box.top,\n                    right  : box.right,\n                    bottom : box.bottom,\n                    left   : box.left\n                };\n                group.append(g);\n            });\n        }\n    }\n\n    if (boxes.length > 0 && display == \"list-item\" && !element.getAttribute(\"kendo-no-bullet\")) {\n        drawBullet(boxes[0]);\n    }\n\n    // overflow: hidden/auto - if present, replace the group with\n    // a new one clipped by the inner box.\n    (function(){\n        function clipit() {\n            var clipPath = elementRoundBox(element, innerbox, \"padding\");\n            var tmp = new Group();\n            setClipping(tmp, clipPath);\n            group.append(tmp);\n            group = tmp;\n            updateClipbox(clipPath);\n        }\n        if (isFormField(element)) {\n            clipit();\n        } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, \"overflow\"))) {\n            clipit();\n        } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, \"overflow-x\"))) {\n            clipit();\n        } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, \"overflow-y\"))) {\n            clipit();\n        }\n    })();\n\n    if (!maybeRenderWidget(element, group)) {\n        renderContents(element, group);\n    }\n\n    if (microsoft && textOverflow == \"ellipsis\") {\n        element.style.textOverflow = saveTextOverflow;\n    }\n\n    return group; // only utility functions after this line.\n\n    function adjustBoxes(boxes) {\n        if (/^td$/i.test(element.tagName)) {\n            var table = nodeInfo.table;\n            if (table && getPropertyValue(table.style, \"border-collapse\") == \"collapse\") {\n                var tableBorderLeft = getBorder(table.style, \"left\").width;\n                var tableBorderTop = getBorder(table.style, \"top\").width;\n                // check if we need to adjust\n                if (tableBorderLeft === 0 && tableBorderTop === 0) {\n                    return boxes; // nope\n                }\n                var tableBox = table.element.getBoundingClientRect();\n                var firstCell = table.element.rows[0].cells[0];\n                var firstCellBox = firstCell.getBoundingClientRect();\n                if (firstCellBox.top == tableBox.top || firstCellBox.left == tableBox.left) {\n                    return slice(boxes).map(function(box){\n                        return {\n                            left   : box.left + tableBorderLeft,\n                            top    : box.top + tableBorderTop,\n                            right  : box.right + tableBorderLeft,\n                            bottom : box.bottom + tableBorderTop,\n                            height : box.height,\n                            width  : box.width\n                        };\n                    });\n                }\n            }\n        }\n        return boxes;\n    }\n\n    // this function will be called to draw each border.  it\n    // draws starting at origin and the resulted path must be\n    // translated/rotated to be placed in the proper position.\n    //\n    // arguments are named as if it draws the top border:\n    //\n    //    - `len` the length of the edge\n    //    - `Wtop` the width of the edge (i.e. border-top-width)\n    //    - `Wleft` the width of the left edge (border-left-width)\n    //    - `Wright` the width of the right edge\n    //    - `rl` and `rl` -- the border radius on the left and right\n    //      (objects containing x and y, for horiz/vertical radius)\n    //    - `transform` -- transformation to apply\n    //\n    function drawEdge(color, len, Wtop, Wleft, Wright, rl, rr, transform) {\n        if (Wtop <= 0) {\n            return;\n        }\n\n        var path, edge = new Group();\n        setTransform(edge, transform);\n        group.append(edge);\n\n        sanitizeRadius(rl);\n        sanitizeRadius(rr);\n\n        // draw main border.  this is the area without the rounded corners\n        path = new Path({\n            fill: { color: color },\n            stroke: null\n        });\n        edge.append(path);\n        path.moveTo(rl.x ? Math.max(rl.x, Wleft) : 0, 0)\n            .lineTo(len - (rr.x ? Math.max(rr.x, Wright) : 0), 0)\n            .lineTo(len - Math.max(rr.x, Wright), Wtop)\n            .lineTo(Math.max(rl.x, Wleft), Wtop)\n            .close();\n\n        if (rl.x) {\n            drawRoundCorner(Wleft, rl, [ -1, 0, 0, 1, rl.x, 0 ]);\n        }\n\n        if (rr.x) {\n            drawRoundCorner(Wright, rr, [ 1, 0, 0, 1, len - rr.x, 0 ]);\n        }\n\n        // draws one round corner, starting at origin (needs to be\n        // translated/rotated to be placed properly).\n        function drawRoundCorner(Wright, r, transform) {\n            var angle = Math.PI/2 * Wright / (Wright + Wtop);\n\n            // not sanitizing this one, because negative values\n            // are useful to fill the box correctly.\n            var ri = {\n                x: r.x - Wright,\n                y: r.y - Wtop\n            };\n\n            var path = new Path({\n                fill: { color: color },\n                stroke: null\n            }).moveTo(0, 0);\n\n            setTransform(path, transform);\n\n            addArcToPath(path, 0, r.y, {\n                startAngle: -90,\n                endAngle: -radiansToDegrees(angle),\n                radiusX: r.x,\n                radiusY: r.y\n            });\n\n            if (ri.x > 0 && ri.y > 0) {\n                path.lineTo(ri.x * Math.cos(angle), r.y - ri.y * Math.sin(angle));\n                addArcToPath(path, 0, r.y, {\n                    startAngle: -radiansToDegrees(angle),\n                    endAngle: -90,\n                    radiusX: ri.x,\n                    radiusY: ri.y,\n                    anticlockwise: true\n                });\n            }\n            else if (ri.x > 0) {\n                path.lineTo(ri.x, Wtop)\n                    .lineTo(0, Wtop);\n            }\n            else {\n                path.lineTo(ri.x, Wtop)\n                    .lineTo(ri.x, 0);\n            }\n\n            edge.append(path.close());\n        }\n    }\n\n    function drawBackground(box) {\n        var background = new Group();\n        setClipping(background, roundBox(box, rTL0, rTR0, rBR0, rBL0));\n        group.append(background);\n\n        if (backgroundColor) {\n            var path = new Path({\n                fill: { color: backgroundColor.toCssRgba() },\n                stroke: null\n            });\n            path.moveTo(box.left, box.top)\n                .lineTo(box.right, box.top)\n                .lineTo(box.right, box.bottom)\n                .lineTo(box.left, box.bottom)\n                .close();\n            background.append(path);\n        }\n\n        for (var i = backgroundImage.length; --i >= 0;) {\n            drawOneBackground(\n                background, box,\n                backgroundImage[i],\n                backgroundRepeat[i % backgroundRepeat.length],\n                backgroundPosition[i % backgroundPosition.length],\n                backgroundOrigin[i % backgroundOrigin.length],\n                backgroundSize[i % backgroundSize.length]\n            );\n        }\n    }\n\n    function drawOneBackground(group, box, background, backgroundRepeat, backgroundPosition, backgroundOrigin, backgroundSize) {\n        if (!background || (background == \"none\")) {\n            return;\n        }\n\n        if (background.type == \"url\") {\n            var img = IMAGE_CACHE[background.url];\n            if (img && img.width > 0 && img.height > 0) {\n                drawBackgroundImage(group, box, img.width, img.height, function(group, rect){\n                    group.append(new Image(background.url, rect));\n                });\n            }\n        } else if (background.type == \"linear\") {\n            drawBackgroundImage(group, box, box.width, box.height, gradientRenderer(background));\n        } else {\n            return;\n        }\n\n        function drawBackgroundImage(group, box, img_width, img_height, renderBG) {\n            var aspect_ratio = img_width / img_height, f;\n\n            // for background-origin: border-box the box is already appropriate\n            var orgBox = box;\n            if (backgroundOrigin == \"content-box\") {\n                orgBox = innerBox(orgBox, \"border-*-width\", element);\n                orgBox = innerBox(orgBox, \"padding-*\", element);\n            } else if (backgroundOrigin == \"padding-box\") {\n                orgBox = innerBox(orgBox, \"border-*-width\", element);\n            }\n\n            if (!/^\\s*auto(\\s+auto)?\\s*$/.test(backgroundSize)) {\n                if (backgroundSize == \"contain\") {\n                    f = Math.min(orgBox.width / img_width,\n                                 orgBox.height / img_height);\n                    img_width *= f;\n                    img_height *= f;\n                }\n                else if (backgroundSize == \"cover\") {\n                    f = Math.max(orgBox.width / img_width,\n                                 orgBox.height / img_height);\n                    img_width *= f;\n                    img_height *= f;\n                }\n                else {\n                    var size = backgroundSize.split(/\\s+/g);\n                    // compute width\n                    if (/%$/.test(size[0])) {\n                        img_width = orgBox.width * parseFloat(size[0]) / 100;\n                    } else {\n                        img_width = parseFloat(size[0]);\n                    }\n                    // compute height\n                    if (size.length == 1 || size[1] == \"auto\") {\n                        img_height = img_width / aspect_ratio;\n                    } else if (/%$/.test(size[1])) {\n                        img_height = orgBox.height * parseFloat(size[1]) / 100;\n                    } else {\n                        img_height = parseFloat(size[1]);\n                    }\n                }\n            }\n\n            var pos = String(backgroundPosition);\n\n            // IE sometimes reports single-word positions\n            // https://github.com/telerik/kendo-ui-core/issues/2786\n            //\n            // it seems to switch to percentages when the horizontal\n            // position is not \"center\", therefore we don't handle\n            // multi-word cases here.  All other browsers return\n            // percentages or pixels instead of keywords.  At least\n            // for now...\n            switch (pos) {\n              case \"bottom\" : pos = \"50% 100%\"; break;\n              case \"top\"    : pos = \"50% 0\"; break;\n              case \"left\"   : pos = \"0 50%\"; break;\n              case \"right\"  : pos = \"100% 50%\"; break;\n              case \"center\" : pos = \"50% 50%\"; break;\n            }\n\n            pos = pos.split(/\\s+/);\n            if (pos.length == 1) {\n                pos[1] = \"50%\";\n            }\n\n            if (/%$/.test(pos[0])) {\n                pos[0] = parseFloat(pos[0]) / 100 * (orgBox.width - img_width);\n            } else {\n                pos[0] = parseFloat(pos[0]);\n            }\n            if (/%$/.test(pos[1])) {\n                pos[1] = parseFloat(pos[1]) / 100 * (orgBox.height - img_height);\n            } else {\n                pos[1] = parseFloat(pos[1]);\n            }\n\n            var rect = new geo.Rect([ orgBox.left + pos[0], orgBox.top + pos[1] ], [ img_width, img_height ]);\n\n            // XXX: background-repeat could be implemented more\n            //      efficiently as a fill pattern (at least for PDF\n            //      output, probably SVG too).\n\n            function rewX() {\n                while (rect.origin.x > box.left) {\n                    rect.origin.x -= img_width;\n                }\n            }\n\n            function rewY() {\n                while (rect.origin.y > box.top) {\n                    rect.origin.y -= img_height;\n                }\n            }\n\n            function repeatX() {\n                while (rect.origin.x < box.right) {\n                    renderBG(group, rect.clone());\n                    rect.origin.x += img_width;\n                }\n            }\n\n            if (backgroundRepeat == \"no-repeat\") {\n                renderBG(group, rect);\n            }\n            else if (backgroundRepeat == \"repeat-x\") {\n                rewX();\n                repeatX();\n            }\n            else if (backgroundRepeat == \"repeat-y\") {\n                rewY();\n                while (rect.origin.y < box.bottom) {\n                    renderBG(group, rect.clone());\n                    rect.origin.y += img_height;\n                }\n            }\n            else if (backgroundRepeat == \"repeat\") {\n                rewX();\n                rewY();\n                var origin = rect.origin.clone();\n                while (rect.origin.y < box.bottom) {\n                    rect.origin.x = origin.x;\n                    repeatX();\n                    rect.origin.y += img_height;\n                }\n            }\n        }\n    }\n\n    function drawBullet() {\n        var listStyleType = getPropertyValue(style, \"list-style-type\");\n        if (listStyleType == \"none\") {\n            return;\n        }\n        var listStylePosition = getPropertyValue(style, \"list-style-position\");\n\n        function _drawBullet(f) {\n            saveStyle(element, function(){\n                element.style.position = \"relative\";\n                var bullet = element.ownerDocument.createElement(KENDO_PSEUDO_ELEMENT);\n                bullet.style.position = \"absolute\";\n                bullet.style.boxSizing = \"border-box\";\n                if (listStylePosition == \"outside\") {\n                    bullet.style.width = \"6em\";\n                    bullet.style.left = \"-6.8em\";\n                    bullet.style.textAlign = \"right\";\n                } else {\n                    bullet.style.left = \"0px\";\n                }\n                f(bullet);\n                element.insertBefore(bullet, element.firstChild);\n                renderElement(bullet, group);\n                element.removeChild(bullet);\n            });\n        }\n\n        function elementIndex(f) {\n            var a = element.parentNode.children;\n            var k = element.getAttribute(\"kendo-split-index\");\n            if (k != null) {\n                return f(k|0, a.length);\n            }\n            for (var i = 0; i < a.length; ++i) {\n                if (a[i] === element) {\n                    return f(i, a.length);\n                }\n            }\n        }\n\n        switch (listStyleType) {\n          case \"circle\":\n          case \"disc\":\n          case \"square\":\n            _drawBullet(function(bullet){\n                // XXX: the science behind these values is called \"trial and error\".\n                bullet.style.fontSize = \"60%\";\n                bullet.style.lineHeight = \"200%\";\n                bullet.style.paddingRight = \"0.5em\";\n                bullet.style.fontFamily = \"DejaVu Serif\";\n                bullet.innerHTML = {\n                    \"disc\"   : \"\\u25cf\",\n                    \"circle\" : \"\\u25ef\",\n                    \"square\" : \"\\u25a0\"\n                }[listStyleType];\n            });\n            break;\n\n          case \"decimal\":\n          case \"decimal-leading-zero\":\n            _drawBullet(function(bullet){\n                elementIndex(function(idx){\n                    ++idx;\n                    if (listStyleType == \"decimal-leading-zero\" && idx < 10) {\n                        idx = \"0\" + idx;\n                    }\n                    bullet.innerHTML = idx + \".\";\n                });\n            });\n            break;\n\n          case \"lower-roman\":\n          case \"upper-roman\":\n            _drawBullet(function(bullet){\n                elementIndex(function(idx){\n                    idx = arabicToRoman(idx + 1);\n                    if (listStyleType == \"upper-roman\") {\n                        idx = idx.toUpperCase();\n                    }\n                    bullet.innerHTML = idx + \".\";\n                });\n            });\n            break;\n\n          case \"lower-latin\":\n          case \"lower-alpha\":\n          case \"upper-latin\":\n          case \"upper-alpha\":\n            _drawBullet(function(bullet){\n                elementIndex(function(idx){\n                    idx = alphaNumeral(idx);\n                    if (/^upper/i.test(listStyleType)) {\n                        idx = idx.toUpperCase();\n                    }\n                    bullet.innerHTML = idx + \".\";\n                });\n            });\n            break;\n        }\n    }\n\n    // draws a single border box\n    function drawOneBox(box, isFirst, isLast) {\n        if (box.width === 0 || box.height === 0) {\n            return;\n        }\n\n        drawBackground(box);\n\n        var shouldDrawLeft = (left.width > 0 && ((isFirst && dir == \"ltr\") || (isLast && dir == \"rtl\")));\n        var shouldDrawRight = (right.width > 0 && ((isLast && dir == \"ltr\") || (isFirst && dir == \"rtl\")));\n\n        // The most general case is that the 4 borders have different widths and border\n        // radiuses.  The way that is handled is by drawing 3 Paths for each border: the\n        // straight line, and two round corners which represent half of the entire rounded\n        // corner.  To simplify code those shapes are drawed at origin (by the drawEdge\n        // function), then translated/rotated into the right position.\n        //\n        // However, this leads to poor results due to rounding in the simpler cases where\n        // borders are straight lines.  Therefore we handle a few such cases separately with\n        // straight lines. C^wC^wC^w -- nope, scratch that.  poor rendering was because of a bug\n        // in Chrome (getClientRects() returns rounded integer values rather than exact floats.\n        // web dev is still a ghetto.)\n\n        // first, just in case there is no border...\n        if (top.width === 0 && left.width === 0 && right.width === 0 && bottom.width === 0) {\n            return;\n        }\n\n        // START paint borders\n        // if all borders have equal colors...\n        if (top.color == right.color && top.color == bottom.color && top.color == left.color) {\n\n            // if same widths too, we can draw the whole border by stroking a single path.\n            if (top.width == right.width && top.width == bottom.width && top.width == left.width)\n            {\n                if (shouldDrawLeft && shouldDrawRight) {\n                    // reduce box by half the border width, so we can draw it by stroking.\n                    box = innerBox(box, top.width/2);\n\n                    // adjust the border radiuses, again by top.width/2, and make the path element.\n                    var path = elementRoundBox(element, box, top.width/2);\n                    path.options.stroke = {\n                        color: top.color,\n                        width: top.width\n                    };\n                    group.append(path);\n                    return;\n                }\n            }\n        }\n\n        // if border radiuses are zero and widths are at most one pixel, we can again use simple\n        // paths.\n        if (rTL0.x === 0 && rTR0.x === 0 && rBR0.x === 0 && rBL0.x === 0) {\n            // alright, 1.9px will do as well.  the difference in color blending should not be\n            // noticeable.\n            if (top.width < 2 && left.width < 2 && right.width < 2 && bottom.width < 2) {\n                // top border\n                if (top.width > 0) {\n                    group.append(\n                        new Path({\n                            stroke: { width: top.width, color: top.color }\n                        })\n                            .moveTo(box.left, box.top + top.width/2)\n                            .lineTo(box.right, box.top + top.width/2)\n                    );\n                }\n\n                // bottom border\n                if (bottom.width > 0) {\n                    group.append(\n                        new Path({\n                            stroke: { width: bottom.width, color: bottom.color }\n                        })\n                            .moveTo(box.left, box.bottom - bottom.width/2)\n                            .lineTo(box.right, box.bottom - bottom.width/2)\n                    );\n                }\n\n                // left border\n                if (shouldDrawLeft) {\n                    group.append(\n                        new Path({\n                            stroke: { width: left.width, color: left.color }\n                        })\n                            .moveTo(box.left + left.width/2, box.top)\n                            .lineTo(box.left + left.width/2, box.bottom)\n                    );\n                }\n\n                // right border\n                if (shouldDrawRight) {\n                    group.append(\n                        new Path({\n                            stroke: { width: right.width, color: right.color }\n                        })\n                            .moveTo(box.right - right.width/2, box.top)\n                            .lineTo(box.right - right.width/2, box.bottom)\n                    );\n                }\n\n                return;\n            }\n        }\n        // END paint borders\n\n        var tmp = adjustBorderRadiusForBox(box, rTL0, rTR0, rBR0, rBL0);\n        var rTL = tmp.tl;\n        var rTR = tmp.tr;\n        var rBR = tmp.br;\n        var rBL = tmp.bl;\n\n        // top border\n        drawEdge(top.color,\n                 box.width, top.width, left.width, right.width,\n                 rTL, rTR,\n                 [ 1, 0, 0, 1, box.left, box.top ]);\n\n        // bottom border\n        drawEdge(bottom.color,\n                 box.width, bottom.width, right.width, left.width,\n                 rBR, rBL,\n                 [ -1, 0, 0, -1, box.right, box.bottom ]);\n\n        // for left/right borders we need to invert the border-radiuses\n        function inv(p) {\n            return { x: p.y, y: p.x };\n        }\n\n        // left border\n        drawEdge(left.color,\n                 box.height, left.width, bottom.width, top.width,\n                 inv(rBL), inv(rTL),\n                 [ 0, -1, 1, 0, box.left, box.bottom ]);\n\n        // right border\n        drawEdge(right.color,\n                 box.height, right.width, top.width, bottom.width,\n                 inv(rTR), inv(rBR),\n                 [ 0, 1, -1, 0, box.right, box.top ]);\n    }\n}\n\nfunction gradientRenderer(gradient) {\n    return function(group, rect) {\n        var width = rect.width(), height = rect.height();\n\n        switch (gradient.type) {\n          case \"linear\":\n\n            // figure out the angle.\n            var angle = gradient.angle != null ? gradient.angle : Math.PI;\n            switch (gradient.to) {\n              case \"top\":\n                angle = 0;\n                break;\n              case \"left\":\n                angle = -Math.PI / 2;\n                break;\n              case \"bottom\":\n                angle = Math.PI;\n                break;\n              case \"right\":\n                angle = Math.PI / 2;\n                break;\n              case \"top left\": case \"left top\":\n                angle = -Math.atan2(height, width);\n                break;\n              case \"top right\": case \"right top\":\n                angle = Math.atan2(height, width);\n                break;\n              case \"bottom left\": case \"left bottom\":\n                angle = Math.PI + Math.atan2(height, width);\n                break;\n              case \"bottom right\": case \"right bottom\":\n                angle = Math.PI - Math.atan2(height, width);\n                break;\n            }\n\n            if (gradient.reverse) {\n                angle -= Math.PI;\n            }\n\n            // limit the angle between 0..2PI\n            angle %= 2 * Math.PI;\n            if (angle < 0) {\n                angle += 2 * Math.PI;\n            }\n\n            // compute gradient's start/end points.  here len is the length of the gradient line\n            // and x,y is the end point relative to the center of the rectangle in conventional\n            // (math) axis direction.\n\n            // this is the original (unscaled) length of the gradient line.  needed to deal with\n            // absolutely positioned color stops.  formula from the CSS spec:\n            // http://dev.w3.org/csswg/css-images-3/#linear-gradient-syntax\n            var pxlen = Math.abs(width * Math.sin(angle)) + Math.abs(height * Math.cos(angle));\n\n            // The math below is pretty simple, but it took a while to figure out.  We compute x\n            // and y, the *end* of the gradient line.  However, we want to transform them into\n            // element-based coordinates (SVG's gradientUnits=\"objectBoundingBox\").  That means,\n            // x=0 is the left edge, x=1 is the right edge, y=0 is the top edge and y=1 is the\n            // bottom edge.\n            //\n            // A naive approach would use the original angle for these calculations.  Say we'd\n            // like to draw a gradient angled at 45deg in a 100x400 box.  When we use\n            // objectBoundingBox, the renderer will draw it in a 1x1 *square* box, and then\n            // scale that to the desired dimensions.  The 45deg angle will look more like 70deg\n            // after scaling.  SVG (http://www.w3.org/TR/SVG/pservers.html#LinearGradients) says\n            // the following:\n            //\n            //     When gradientUnits=\"objectBoundingBox\" and 'gradientTransform' is the\n            //     identity matrix, the normal of the linear gradient is perpendicular to the\n            //     gradient vector in object bounding box space (i.e., the abstract coordinate\n            //     system where (0,0) is at the top/left of the object bounding box and (1,1) is\n            //     at the bottom/right of the object bounding box). When the object's bounding\n            //     box is not square, the gradient normal which is initially perpendicular to\n            //     the gradient vector within object bounding box space may render\n            //     non-perpendicular relative to the gradient vector in user space. If the\n            //     gradient vector is parallel to one of the axes of the bounding box, the\n            //     gradient normal will remain perpendicular. This transformation is due to\n            //     application of the non-uniform scaling transformation from bounding box space\n            //     to user space.\n            //\n            // which is an extremely long and confusing way to tell what I just said above.\n            //\n            // For this reason we need to apply the reverse scaling to the original angle, so\n            // that when it'll finally be rendered it'll actually be at the desired slope.  Now\n            // I'll let you figure out the math yourself.\n\n            var scaledAngle = Math.atan(width * Math.tan(angle) / height);\n            var sin = Math.sin(scaledAngle), cos = Math.cos(scaledAngle);\n            var len = Math.abs(sin) + Math.abs(cos);\n            var x = len/2 * sin;\n            var y = len/2 * cos;\n\n            // Because of the arctangent, our scaledAngle ends up between -PI/2..PI/2, possibly\n            // losing the intended direction of the gradient.  The following fixes it.\n            if (angle > Math.PI/2 && angle <= 3*Math.PI/2) {\n                x = -x;\n                y = -y;\n            }\n\n            // compute the color stops.\n            var implicit = [], right = 0;\n            var stops = gradient.stops.map(function(s, i){\n                var offset = s.percent;\n                if (offset) {\n                    offset = parseFloat(offset) / 100;\n                } else if (s.length) {\n                    offset = parseFloat(s.length) / pxlen;\n                } else if (i === 0) {\n                    offset = 0;\n                } else if (i == gradient.stops.length - 1) {\n                    offset = 1;\n                }\n                var stop = {\n                    color: s.color.toCssRgba(),\n                    offset: offset\n                };\n                if (offset != null) {\n                    right = offset;\n                    // fix implicit offsets\n                    implicit.forEach(function(s, i){\n                        var stop = s.stop;\n                        stop.offset = s.left + (right - s.left) * (i + 1) / (implicit.length + 1);\n                    });\n                    implicit = [];\n                } else {\n                    implicit.push({ left: right, stop: stop });\n                }\n                return stop;\n            });\n\n            var start = [ 0.5 - x, 0.5 + y ];\n            var end = [ 0.5 + x, 0.5 - y ];\n\n            // finally, draw it.\n            group.append(\n                Path.fromRect(rect)\n                    .stroke(null)\n                    .fill(new LinearGradient({\n                        start     : start,\n                        end       : end,\n                        stops     : stops,\n                        userSpace : false\n                    }))\n            );\n            break;\n          case \"radial\":\n            // XXX:\n            if (window.console && window.console.log) {\n                window.console.log(\"Radial gradients are not yet supported in HTML renderer\");\n            }\n            break;\n        }\n    };\n}\n\nfunction maybeRenderWidget(element, group) {\n    var visual;\n\n    if (element._kendoExportVisual) {\n        visual = element._kendoExportVisual();\n    } else if (window.kendo && window.kendo.jQuery && element.getAttribute(window.kendo.attr(\"role\"))) {\n        var widget = window.kendo.widgetInstance(window.kendo.jQuery(element));\n        if (widget && (widget.exportDOMVisual || widget.exportVisual)) {\n            if (widget.exportDOMVisual) {\n                visual = widget.exportDOMVisual();\n            } else {\n                visual = widget.exportVisual();\n            }\n        }\n    }\n\n    if (!visual) {\n        return false;\n    }\n\n    var wrap = new Group();\n    wrap.children.push(visual);\n\n    var bbox = element.getBoundingClientRect();\n    wrap.transform(geo.transform().translate(bbox.left, bbox.top));\n\n    group.append(wrap);\n\n    return true;\n}\n\nfunction renderImage(element, url, group) {\n    var box = getContentBox(element);\n    var rect = new geo.Rect([ box.left, box.top ], [ box.width, box.height ]);\n    var image = new Image(url, rect);\n    setClipping(image, elementRoundBox(element, box, \"content\"));\n    group.append(image);\n}\n\nfunction zIndexSort(a, b) {\n    var sa = getComputedStyle(a);\n    var sb = getComputedStyle(b);\n    var za = parseFloat(getPropertyValue(sa, \"z-index\"));\n    var zb = parseFloat(getPropertyValue(sb, \"z-index\"));\n    var pa = getPropertyValue(sa, \"position\");\n    var pb = getPropertyValue(sb, \"position\");\n    if (isNaN(za) && isNaN(zb)) {\n        if ((/static|absolute/.test(pa)) && (/static|absolute/.test(pb))) {\n            return 0;\n        }\n        if (pa == \"static\") {\n            return -1;\n        }\n        if (pb == \"static\") {\n            return 1;\n        }\n        return 0;\n    }\n    if (isNaN(za)) {\n        return zb === 0 ? 0 : zb > 0 ? -1 : 1;\n    }\n    if (isNaN(zb)) {\n        return za === 0 ? 0 : za > 0 ? 1 : -1;\n    }\n    return parseFloat(za) - parseFloat(zb);\n}\n\nfunction isFormField(element) {\n    return /^(?:textarea|select|input)$/i.test(element.tagName);\n}\n\nfunction getSelectedOption(element) {\n    if (element.selectedOptions && element.selectedOptions.length > 0) {\n        return element.selectedOptions[0];\n    }\n    return element.options[element.selectedIndex];\n}\n\nfunction renderCheckbox(element, group) {\n    var style = getComputedStyle(element);\n    var color = getPropertyValue(style, \"color\");\n    var box = element.getBoundingClientRect();\n    if (element.type == \"checkbox\") {\n        group.append(\n            Path.fromRect(\n                new geo.Rect([ box.left+1, box.top+1 ],\n                             [ box.width-2, box.height-2 ])\n            ).stroke(color, 1)\n        );\n        if (element.checked) {\n            // fill a rectangle inside?  looks kinda ugly.\n            // group.append(\n            //     Path.fromRect(\n            //         new geo.Rect([ box.left+4, box.top+4 ],\n            //                      [ box.width-8, box.height-8])\n            //     ).fill(color).stroke(null)\n            // );\n\n            // let's draw a checkmark instead.  artistic, eh?\n            group.append(\n                new Path()\n                    .stroke(color, 1.2)\n                    .moveTo(box.left + 0.22 * box.width,\n                            box.top + 0.55 * box.height)\n                    .lineTo(box.left + 0.45 * box.width,\n                            box.top + 0.75 * box.height)\n                    .lineTo(box.left + 0.78 * box.width,\n                            box.top + 0.22 * box.width)\n            );\n        }\n    } else {\n        group.append(\n            new Circle(\n                new geo.Circle([\n                    (box.left + box.right) / 2,\n                    (box.top + box.bottom) / 2\n                ], Math.min(box.width-2, box.height-2) / 2)\n            ).stroke(color, 1)\n        );\n        if (element.checked) {\n            group.append(\n                new Circle(\n                    new geo.Circle([\n                        (box.left + box.right) / 2,\n                        (box.top + box.bottom) / 2\n                    ], Math.min(box.width-8, box.height-8) / 2)\n                ).fill(color).stroke(null)\n            );\n        }\n    }\n}\n\nfunction renderFormField(element, group) {\n    var tag = element.tagName.toLowerCase();\n    if (tag == \"input\" && (element.type == \"checkbox\" || element.type == \"radio\")) {\n        return renderCheckbox(element, group);\n    }\n    var p = element.parentNode;\n    var doc = element.ownerDocument;\n    var el = doc.createElement(KENDO_PSEUDO_ELEMENT);\n    var option;\n    el.style.cssText = getCssText(getComputedStyle(element));\n    if (tag == \"input\") {\n        el.style.whiteSpace = \"pre\";\n    }\n    if (tag == \"select\" || tag == \"textarea\") {\n        el.style.overflow = \"auto\";\n    }\n    if (tag == \"select\") {\n        if (element.multiple) {\n            for (var i = 0; i < element.options.length; ++i) {\n                option = doc.createElement(KENDO_PSEUDO_ELEMENT);\n                option.style.cssText = getCssText(getComputedStyle(element.options[i]));\n                option.style.display = \"block\"; // IE9 messes up without this\n                option.textContent = element.options[i].textContent;\n                el.appendChild(option);\n            }\n        } else {\n            option = getSelectedOption(element);\n            if (option) {\n                el.textContent = option.textContent;\n            }\n        }\n    } else {\n        el.textContent = element.value;\n    }\n    p.insertBefore(el, element);\n    el.scrollLeft = element.scrollLeft;\n    el.scrollTop = element.scrollTop;\n\n    // must temporarily hide the original element, otherwise it\n    // may affect layout of the fake element we want to render.\n    element.style.display = \"none\";\n\n    renderContents(el, group);\n    element.style.display = \"\";\n    p.removeChild(el);\n}\n\nfunction renderContents(element, group) {\n    if (nodeInfo._stackingContext.element === element) {\n        // the group that was set in pushNodeInfo might have\n        // changed due to clipping/transforms, update it here.\n        nodeInfo._stackingContext.group = group;\n    }\n    switch (element.tagName.toLowerCase()) {\n      case \"img\":\n        renderImage(element, element.src, group);\n        break;\n\n      case \"svg\":\n        var xml = new window.XMLSerializer().serializeToString(element);\n        var dataURL = \"data:image/svg+xml;base64,\" + (encodeBase64(xml));\n        renderImage(element, dataURL, group);\n        break;\n\n      case \"canvas\":\n        try {\n            renderImage(element, element.toDataURL(\"image/png\"), group);\n        } catch (ex) {\n            // tainted; can't draw it, ignore.\n        }\n        break;\n\n      case \"textarea\":\n      case \"input\":\n      case \"select\":\n        renderFormField(element, group);\n        break;\n\n      default:\n        var children = [], floats = [], positioned = [];\n        for (var i = element.firstChild; i; i = i.nextSibling) {\n            switch (i.nodeType) {\n              case 3:         // Text\n                if (/\\S/.test(i.data)) {\n                    renderText(element, i, group);\n                }\n                break;\n              case 1:         // Element\n                var style = getComputedStyle(i);\n                var floating = getPropertyValue(style, \"float\");\n                var position = getPropertyValue(style, \"position\");\n                if (position != \"static\") {\n                    positioned.push(i);\n                }\n                else if (floating != \"none\") {\n                    floats.push(i);\n                } else {\n                    children.push(i);\n                }\n                break;\n            }\n        }\n\n        mergeSort(children, zIndexSort).forEach(function(el){ renderElement(el, group); });\n        mergeSort(floats, zIndexSort).forEach(function(el){ renderElement(el, group); });\n        mergeSort(positioned, zIndexSort).forEach(function(el){ renderElement(el, group); });\n    }\n}\n\nfunction renderText(element, node, group) {\n    if (emptyClipbox()) {\n        return;\n    }\n    var style = getComputedStyle(element);\n\n    if (parseFloat(getPropertyValue(style, \"text-indent\")) < -500) {\n        // assume it should not be displayed.  the slider's\n        // draggable handle displays a Drag text for some reason,\n        // having text-indent: -3333px.\n        return;\n    }\n\n    var text = node.data;\n    var start = 0;\n    var end = text.search(/\\S\\s*$/) + 1;\n\n    if (!end) {\n        return; // whitespace-only node\n    }\n\n    var fontSize = getPropertyValue(style, \"font-size\");\n    var lineHeight = getPropertyValue(style, \"line-height\");\n\n    // simply getPropertyValue(\"font\") doesn't work in Firefox :-\\\n    var font = [\n        getPropertyValue(style, \"font-style\"),\n        getPropertyValue(style, \"font-variant\"),\n        getPropertyValue(style, \"font-weight\"),\n        fontSize, // no need for line height here; it breaks layout in FF\n        getPropertyValue(style, \"font-family\")\n    ].join(\" \");\n\n    fontSize = parseFloat(fontSize);\n    lineHeight = parseFloat(lineHeight);\n\n    if (fontSize === 0) {\n        return;\n    }\n\n    var color = getPropertyValue(style, \"color\");\n    var range = element.ownerDocument.createRange();\n    var align = getPropertyValue(style, \"text-align\");\n    var isJustified = align == \"justify\";\n    var columnCount = getPropertyValue(style, \"column-count\", 1);\n    var whiteSpace = getPropertyValue(style, \"white-space\");\n    var textTransform = getPropertyValue(style, \"text-transform\");\n\n    // A line of 500px, with a font of 12px, contains an average of 80 characters, but since we\n    // err, we'd like to guess a bigger number rather than a smaller one.  Multiplying by 5\n    // seems to be a good option.\n    var estimateLineLength = element.getBoundingClientRect().width / fontSize * 5;\n    if (estimateLineLength === 0) {\n        estimateLineLength = 500;\n    }\n\n    // we'll maintain this so we can workaround bugs in Chrome's Range.getClientRects\n    // https://github.com/telerik/kendo/issues/5740\n    var prevLineBottom = null;\n\n    var underline = nodeInfo[\"underline\"];\n    var lineThrough = nodeInfo[\"line-through\"];\n    var overline = nodeInfo[\"overline\"];\n    var hasDecoration = underline || lineThrough || overline;\n\n    // doChunk returns true when all text has been rendered\n    while (!doChunk()) {}\n\n    if (hasDecoration) {\n        range.selectNode(node);\n        slice(range.getClientRects()).forEach(decorate);\n    }\n\n    return;                 // only function declarations after this line\n\n    function actuallyGetRangeBoundingRect(range) {\n        // XXX: to be revised when this Chrome bug is fixed:\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=612459\n        if (microsoft || browser.chrome) {\n            // Workaround browser bugs: IE and Chrome would sometimes\n            // return 0 or 1-width rectangles before or after the main\n            // one.  https://github.com/telerik/kendo/issues/4674\n\n            // Actually Chrome 50 got worse, since the rectangles can now have the width of a\n            // full character, making it hard to tell whether it's a bogus rectangle or valid\n            // selection location.  The workaround is to ignore rectangles that fall on the\n            // previous line.  https://github.com/telerik/kendo/issues/5740\n            var rectangles = range.getClientRects(), box = {\n                top    :  Infinity,\n                right  : -Infinity,\n                bottom : -Infinity,\n                left   :  Infinity\n            }, done = false;\n            for (var i = 0; i < rectangles.length; ++i) {\n                var b = rectangles[i];\n                if (b.width <= 1 || b.bottom === prevLineBottom) {\n                    continue;   // bogus rectangle\n                }\n                box.left   = Math.min(b.left   , box.left);\n                box.top    = Math.min(b.top    , box.top);\n                box.right  = Math.max(b.right  , box.right);\n                box.bottom = Math.max(b.bottom , box.bottom);\n                done = true;\n            }\n            if (!done) {\n                return range.getBoundingClientRect();\n            }\n            box.width = box.right - box.left;\n            box.height = box.bottom - box.top;\n            return box;\n        }\n        return range.getBoundingClientRect();\n    }\n\n    // Render a chunk of text, typically one line (but for justified text we render each word as\n    // a separate Text object, because spacing is variable).  Returns true when it finished the\n    // current node.  After each chunk it updates `start` to just after the last rendered\n    // character.\n    function doChunk() {\n        var origStart = start;\n        var box, pos = text.substr(start).search(/\\S/);\n        start += pos;\n        if (pos < 0 || start >= end) {\n            return true;\n        }\n\n        // Select a single character to determine the height of a line of text.  The box.bottom\n        // will be essential for us to figure out where the next line begins.\n        range.setStart(node, start);\n        range.setEnd(node, start + 1);\n        box = actuallyGetRangeBoundingRect(range);\n\n        // for justified text we must split at each space, because space has variable width.\n        var found = false;\n        if (isJustified || columnCount > 1) {\n            pos = text.substr(start).search(/\\s/);\n            if (pos >= 0) {\n                // we can only split there if it's on the same line, otherwise we'll fall back\n                // to the default mechanism (see findEOL below).\n                range.setEnd(node, start + pos);\n                var r = actuallyGetRangeBoundingRect(range);\n                if (r.bottom == box.bottom) {\n                    box = r;\n                    found = true;\n                    start += pos;\n                }\n            }\n        }\n\n        if (!found) {\n            // This code does three things: (1) it selects one line of text in `range`, (2) it\n            // leaves the bounding rect of that line in `box` and (3) it returns the position\n            // just after the EOL.  We know where the line starts (`start`) but we don't know\n            // where it ends.  To figure this out, we select a piece of text and look at the\n            // bottom of the bounding box.  If it changes, we have more than one line selected\n            // and should retry with a smaller selection.\n            //\n            // To speed things up, we first try to select all text in the node (`start` ->\n            // `end`).  If there's more than one line there, then select only half of it.  And\n            // so on.  When we find a value for `end` that fits in one line, we try increasing\n            // it (also in halves) until we get to the next line.  The algorithm stops when the\n            // right side of the bounding box does not change.\n            //\n            // One more thing to note is that everything happens in a single Text DOM node.\n            // There's no other tags inside it, therefore the left/top coordinates of the\n            // bounding box will not change.\n            pos = (function findEOL(min, eol, max){\n                range.setEnd(node, eol);\n                var r = actuallyGetRangeBoundingRect(range);\n                if (r.bottom != box.bottom && min < eol) {\n                    return findEOL(min, (min + eol) >> 1, eol);\n                } else if (r.right != box.right) {\n                    box = r;\n                    if (eol < max) {\n                        return findEOL(eol, (eol + max) >> 1, max);\n                    } else {\n                        return eol;\n                    }\n                } else {\n                    return eol;\n                }\n            })(start, Math.min(end, start + estimateLineLength), end);\n\n            if (pos == start) {\n                // if EOL is at the start, then no more text fits on this line.  Skip the\n                // remainder of this node entirely to avoid a stack overflow.\n                return true;\n            }\n            start = pos;\n\n            pos = range.toString().search(/\\s+$/);\n            if (pos === 0) {\n                return false; // whitespace only; we should not get here.\n            }\n            if (pos > 0) {\n                // eliminate trailing whitespace\n                range.setEnd(node, range.startOffset + pos);\n                box = actuallyGetRangeBoundingRect(range);\n            }\n        }\n\n        // another workaround for IE: if we rely on getBoundingClientRect() we'll overlap with the bullet for LI\n        // elements.  Calling getClientRects() and using the *first* rect appears to give us the correct location.\n        // Note: not to be used in Chrome as it randomly returns a zero-width rectangle from the previous line.\n        if (microsoft) {\n            box = range.getClientRects()[0];\n        }\n\n        var str = range.toString();\n        if (!/^(?:pre|pre-wrap)$/i.test(whiteSpace)) {\n            // node with non-significant space -- collapse whitespace.\n            str = str.replace(/\\s+/g, \" \");\n        }\n        else if (/\\t/.test(str)) {\n            // with significant whitespace we need to do something about literal TAB characters.\n            // There's no TAB glyph in a font so they would be rendered in PDF as an empty box,\n            // and the whole text will stretch to fill the original width.  The core PDF lib\n            // does not have sufficient context to deal with it.\n\n            // calculate the starting column here, since we initially discarded any whitespace.\n            var cc = 0;\n            for (pos = origStart; pos < range.startOffset; ++pos) {\n                var code = text.charCodeAt(pos);\n                if (code == 9) {\n                    // when we meet a TAB we must round up to the next tab stop.\n                    // in all browsers TABs seem to be 8 characters.\n                    cc += 8 - cc % 8;\n                } else if (code == 10 || code == 13) {\n                    // just in case we meet a newline we must restart.\n                    cc = 0;\n                } else {\n                    // ordinary character --> advance one column\n                    cc++;\n                }\n            }\n\n            // based on starting column, replace any TAB characters in the string we actually\n            // have to display with spaces so that they align to columns multiple of 8.\n            while ((pos = str.search(\"\\t\")) >= 0) {\n                var indent = \"        \".substr(0, 8 - (cc + pos) % 8);\n                str = str.substr(0, pos) + indent + str.substr(pos + 1);\n            }\n        }\n\n        if (!found) {\n            prevLineBottom = box.bottom;\n        }\n        drawText(str, box);\n    }\n\n    function drawText(str, box) {\n        // In IE the box height will be approximately lineHeight, while in\n        // other browsers it'll (correctly) be the height of the bounding\n        // box for the current text/font.  Which is to say, IE sucks again.\n        // The only good solution I can think of is to measure the text\n        // ourselves and center the bounding box.\n        if (microsoft && !isNaN(lineHeight)) {\n            var height = getFontHeight(font);\n            var top = (box.top + box.bottom - height) / 2;\n            box = {\n                top    : top,\n                right  : box.right,\n                bottom : top + height,\n                left   : box.left,\n                height : height,\n                width  : box.right - box.left\n            };\n        }\n\n        // var path = new Path({ stroke: { color: \"red\" }});\n        // path.moveTo(box.left, box.top)\n        //     .lineTo(box.right, box.top)\n        //     .lineTo(box.right, box.bottom)\n        //     .lineTo(box.left, box.bottom)\n        //     .close();\n        // group.append(path);\n\n        switch (textTransform) {\n          case \"uppercase\":\n            str = str.toUpperCase();\n            break;\n          case \"lowercase\":\n            str = str.toLowerCase();\n            break;\n          case \"capitalize\":\n            str = str.replace(/(?:^|\\s)\\S/g, function (l) { return l.toUpperCase(); });\n            break;\n        }\n\n        var text = new TextRect(\n            str, new geo.Rect([ box.left, box.top ],\n                              [ box.width, box.height ]),\n            {\n                font: font,\n                fill: { color: color }\n            }\n        );\n        group.append(text);\n    }\n\n    function decorate(box) {\n        line(underline, box.bottom);\n        line(lineThrough, box.bottom - box.height / 2.7);\n        line(overline, box.top);\n        function line(color, ypos) {\n            if (color) {\n                var width = fontSize / 12;\n                var path = new Path({ stroke: {\n                    width: width,\n                    color: color\n                }});\n\n                ypos -= width;\n                path.moveTo(box.left, ypos)\n                    .lineTo(box.right, ypos);\n                group.append(path);\n            }\n        }\n    }\n}\n\nfunction groupInStackingContext(element, group, zIndex) {\n    var main;\n    if (zIndex != \"auto\") {\n        // use the current stacking context\n        main = nodeInfo._stackingContext.group;\n        zIndex = parseFloat(zIndex);\n    } else {\n        // normal flow â€” use given container.  we still have to\n        // figure out where should we insert this element with the\n        // assumption that its z-index is zero, as the group might\n        // already contain elements with higher z-index.\n        main = group;\n        zIndex = 0;\n    }\n    var a = main.children;\n    for (var i = 0; i < a.length; ++i) {\n        if (a[i]._dom_zIndex != null && a[i]._dom_zIndex > zIndex) {\n            break;\n        }\n    }\n\n    var tmp = new Group();\n    main.insert(i, tmp);\n    tmp._dom_zIndex = zIndex;\n\n    if (main !== group) {\n        // console.log(\"Placing\", element, \"in\", nodeInfo._stackingContext.element, \"at position\", i, \" / \", a.length);\n        // console.log(a.slice(i+1));\n\n        // if (nodeInfo._matrix) {\n        //     tmp.transform(nodeInfo._matrix);\n        // }\n        if (nodeInfo._clipbox) {\n            var m = nodeInfo._matrix.invert();\n            var r = nodeInfo._clipbox.transformCopy(m);\n            setClipping(tmp, Path.fromRect(r));\n            // console.log(r);\n            // tmp.append(Path.fromRect(r));\n            // tmp.append(new Text(element.className || element.id, r.topLeft()));\n        }\n    }\n\n    return tmp;\n}\n\nfunction renderElement(element, container) {\n    var style = getComputedStyle(element);\n\n    updateCounters(style);\n\n    if (/^(style|script|link|meta|iframe|col|colgroup)$/i.test(element.tagName)) {\n        return;\n    }\n\n    if (nodeInfo._clipbox == null) {\n        return;\n    }\n\n    var opacity = parseFloat(getPropertyValue(style, \"opacity\"));\n    var visibility = getPropertyValue(style, \"visibility\");\n    var display = getPropertyValue(style, \"display\");\n\n    if (opacity === 0 || visibility == \"hidden\" || display == \"none\") {\n        return;\n    }\n\n    var tr = getTransform(style);\n    var group;\n\n    var zIndex = getPropertyValue(style, \"z-index\");\n    if ((tr || opacity < 1) && zIndex == \"auto\") {\n        zIndex = 0;\n    }\n    group = groupInStackingContext(element, container, zIndex);\n\n    // XXX: remove at some point\n    // group._pdfElement = element;\n    // group.options._pdfDebug = \"\";\n    // if (element.id) {\n    //     group.options._pdfDebug = \"#\" + element.id;\n    // }\n    // if (element.className) {\n    //     group.options._pdfDebug += \".\" + element.className.split(\" \").join(\".\");\n    // }\n\n    if (opacity < 1) {\n        group.opacity(opacity * group.opacity());\n    }\n\n    pushNodeInfo(element, style, group);\n\n    if (!tr) {\n        _renderWithPseudoElements(element, group);\n    }\n    else {\n        saveStyle(element, function(){\n            // must clear transform, so getBoundingClientRect returns correct values.\n            pleaseSetPropertyValue(element.style, \"transform\", \"none\", \"important\");\n\n            // must also clear transitions, so correct values are returned *immediately*\n            pleaseSetPropertyValue(element.style, \"transition\", \"none\", \"important\");\n\n            // the presence of any transform makes it behave like it had position: relative,\n            // because why not.\n            // http://meyerweb.com/eric/thoughts/2011/09/12/un-fixing-fixed-elements-with-css-transforms/\n            if (getPropertyValue(style, \"position\") == \"static\") {\n                // but only if it's not already positioned. :-/\n                pleaseSetPropertyValue(element.style, \"position\", \"relative\", \"important\");\n            }\n\n            // must translate to origin before applying the CSS\n            // transformation, then translate back.\n            var bbox = element.getBoundingClientRect();\n            var x = bbox.left + tr.origin[0];\n            var y = bbox.top + tr.origin[1];\n            var m = [ 1, 0, 0, 1, -x, -y ];\n            m = mmul(m, tr.matrix);\n            m = mmul(m, [ 1, 0, 0, 1, x, y ]);\n            m = setTransform(group, m);\n\n            nodeInfo._matrix = nodeInfo._matrix.multiplyCopy(m);\n\n            _renderWithPseudoElements(element, group);\n        });\n    }\n\n    popNodeInfo();\n\n    //drawDebugBox(element.getBoundingClientRect(), container);\n}\n\n// function drawDebugBox(box, group, color) {\n//     var path = Path.fromRect(new geo.Rect([ box.left, box.top ], [ box.width, box.height ]));\n//     if (color) {\n//         path.stroke(color);\n//     }\n//     group.append(path);\n// }\n\n// function dumpTextNode(node) {\n//     var txt = node.data.replace(/^\\s+/, \"\");\n//     if (txt.length < 100) {\n//         console.log(node.data.length + \": |\" + txt);\n//     } else {\n//         console.log(node.data.length + \": |\" + txt.substr(0, 50) + \"|...|\" + txt.substr(-50));\n//     }\n// }\n\nfunction mmul(a, b) {\n    var a1 = a[0], b1 = a[1], c1 = a[2], d1 = a[3], e1 = a[4], f1 = a[5];\n    var a2 = b[0], b2 = b[1], c2 = b[2], d2 = b[3], e2 = b[4], f2 = b[5];\n    return [\n        a1*a2 + b1*c2,          a1*b2 + b1*d2,\n        c1*a2 + d1*c2,          c1*b2 + d1*d2,\n        e1*a2 + f1*c2 + e2,     e1*b2 + f1*d2 + f2\n    ];\n}\n\nexport { drawDOM, drawText, getFontFaces };\n"]},"metadata":{},"sourceType":"module"}