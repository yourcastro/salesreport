{"ast":null,"code":"const ret = require('ret');\n\nconst DRange = require('drange');\n\nconst types = ret.types;\nmodule.exports = class RandExp {\n  /**\n   * @constructor\n   * @param {RegExp|String} regexp\n   * @param {String} m\n   */\n  constructor(regexp, m) {\n    this._setDefaults(regexp);\n\n    if (regexp instanceof RegExp) {\n      this.ignoreCase = regexp.ignoreCase;\n      this.multiline = regexp.multiline;\n      regexp = regexp.source;\n    } else if (typeof regexp === 'string') {\n      this.ignoreCase = m && m.indexOf('i') !== -1;\n      this.multiline = m && m.indexOf('m') !== -1;\n    } else {\n      throw new Error('Expected a regexp or string');\n    }\n\n    this.tokens = ret(regexp);\n  }\n  /**\n   * Checks if some custom properties have been set for this regexp.\n   *\n   * @param {RandExp} randexp\n   * @param {RegExp} regexp\n   */\n\n\n  _setDefaults(regexp) {\n    // When a repetitional token has its max set to Infinite,\n    // randexp won't actually generate a random amount between min and Infinite\n    // instead it will see Infinite as min + 100.\n    this.max = regexp.max != null ? regexp.max : RandExp.prototype.max != null ? RandExp.prototype.max : 100; // This allows expanding to include additional characters\n    // for instance: RandExp.defaultRange.add(0, 65535);\n\n    this.defaultRange = regexp.defaultRange ? regexp.defaultRange : this.defaultRange.clone();\n\n    if (regexp.randInt) {\n      this.randInt = regexp.randInt;\n    }\n  }\n  /**\n   * Generates the random string.\n   *\n   * @return {String}\n   */\n\n\n  gen() {\n    return this._gen(this.tokens, []);\n  }\n  /**\n   * Generate random string modeled after given tokens.\n   *\n   * @param {Object} token\n   * @param {Array.<String>} groups\n   * @return {String}\n   */\n\n\n  _gen(token, groups) {\n    var stack, str, n, i, l;\n\n    switch (token.type) {\n      case types.ROOT:\n      case types.GROUP:\n        // Ignore lookaheads for now.\n        if (token.followedBy || token.notFollowedBy) {\n          return '';\n        } // Insert placeholder until group string is generated.\n\n\n        if (token.remember && token.groupNumber === undefined) {\n          token.groupNumber = groups.push(null) - 1;\n        }\n\n        stack = token.options ? this._randSelect(token.options) : token.stack;\n        str = '';\n\n        for (i = 0, l = stack.length; i < l; i++) {\n          str += this._gen(stack[i], groups);\n        }\n\n        if (token.remember) {\n          groups[token.groupNumber] = str;\n        }\n\n        return str;\n\n      case types.POSITION:\n        // Do nothing for now.\n        return '';\n\n      case types.SET:\n        var expandedSet = this._expand(token);\n\n        if (!expandedSet.length) {\n          return '';\n        }\n\n        return String.fromCharCode(this._randSelect(expandedSet));\n\n      case types.REPETITION:\n        // Randomly generate number between min and max.\n        n = this.randInt(token.min, token.max === Infinity ? token.min + this.max : token.max);\n        str = '';\n\n        for (i = 0; i < n; i++) {\n          str += this._gen(token.value, groups);\n        }\n\n        return str;\n\n      case types.REFERENCE:\n        return groups[token.value - 1] || '';\n\n      case types.CHAR:\n        var code = this.ignoreCase && this._randBool() ? this._toOtherCase(token.value) : token.value;\n        return String.fromCharCode(code);\n    }\n  }\n  /**\n   * If code is alphabetic, converts to other case.\n   * If not alphabetic, returns back code.\n   *\n   * @param {Number} code\n   * @return {Number}\n   */\n\n\n  _toOtherCase(code) {\n    return code + (97 <= code && code <= 122 ? -32 : 65 <= code && code <= 90 ? 32 : 0);\n  }\n  /**\n   * Randomly returns a true or false value.\n   *\n   * @return {Boolean}\n   */\n\n\n  _randBool() {\n    return !this.randInt(0, 1);\n  }\n  /**\n   * Randomly selects and returns a value from the array.\n   *\n   * @param {Array.<Object>} arr\n   * @return {Object}\n   */\n\n\n  _randSelect(arr) {\n    if (arr instanceof DRange) {\n      return arr.index(this.randInt(0, arr.length - 1));\n    }\n\n    return arr[this.randInt(0, arr.length - 1)];\n  }\n  /**\n   * expands a token to a DiscontinuousRange of characters which has a\n   * length and an index function (for random selecting)\n   *\n   * @param {Object} token\n   * @return {DiscontinuousRange}\n   */\n\n\n  _expand(token) {\n    if (token.type === ret.types.CHAR) {\n      return new DRange(token.value);\n    } else if (token.type === ret.types.RANGE) {\n      return new DRange(token.from, token.to);\n    } else {\n      let drange = new DRange();\n\n      for (let i = 0; i < token.set.length; i++) {\n        let subrange = this._expand(token.set[i]);\n\n        drange.add(subrange);\n\n        if (this.ignoreCase) {\n          for (let j = 0; j < subrange.length; j++) {\n            let code = subrange.index(j);\n\n            let otherCaseCode = this._toOtherCase(code);\n\n            if (code !== otherCaseCode) {\n              drange.add(otherCaseCode);\n            }\n          }\n        }\n      }\n\n      if (token.not) {\n        return this.defaultRange.clone().subtract(drange);\n      } else {\n        return this.defaultRange.clone().intersect(drange);\n      }\n    }\n  }\n  /**\n   * Randomly generates and returns a number between a and b (inclusive).\n   *\n   * @param {Number} a\n   * @param {Number} b\n   * @return {Number}\n   */\n\n\n  randInt(a, b) {\n    return a + Math.floor(Math.random() * (1 + b - a));\n  }\n  /**\n   * Default range of characters to generate from.\n   */\n\n\n  get defaultRange() {\n    return this._range = this._range || new DRange(32, 126);\n  }\n\n  set defaultRange(range) {\n    this._range = range;\n  }\n  /**\n   *\n   * Enables use of randexp with a shorter call.\n   *\n   * @param {RegExp|String| regexp}\n   * @param {String} m\n   * @return {String}\n   */\n\n\n  static randexp(regexp, m) {\n    var randexp;\n\n    if (typeof regexp === 'string') {\n      regexp = new RegExp(regexp, m);\n    }\n\n    if (regexp._randexp === undefined) {\n      randexp = new RandExp(regexp, m);\n      regexp._randexp = randexp;\n    } else {\n      randexp = regexp._randexp;\n\n      randexp._setDefaults(regexp);\n    }\n\n    return randexp.gen();\n  }\n  /**\n   * Enables sugary /regexp/.gen syntax.\n   */\n\n\n  static sugar() {\n    /* eshint freeze:false */\n    RegExp.prototype.gen = function () {\n      return RandExp.randexp(this);\n    };\n  }\n\n};","map":{"version":3,"sources":["D:/Castro/Development/SalesReport/SalesReport/node_modules/randexp/lib/randexp.js"],"names":["ret","require","DRange","types","module","exports","RandExp","constructor","regexp","m","_setDefaults","RegExp","ignoreCase","multiline","source","indexOf","Error","tokens","max","prototype","defaultRange","clone","randInt","gen","_gen","token","groups","stack","str","n","i","l","type","ROOT","GROUP","followedBy","notFollowedBy","remember","groupNumber","undefined","push","options","_randSelect","length","POSITION","SET","expandedSet","_expand","String","fromCharCode","REPETITION","min","Infinity","value","REFERENCE","CHAR","code","_randBool","_toOtherCase","arr","index","RANGE","from","to","drange","set","subrange","add","j","otherCaseCode","not","subtract","intersect","a","b","Math","floor","random","_range","range","randexp","_randexp","sugar"],"mappings":"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","sourcesContent":["const ret    = require('ret');\nconst DRange = require('drange');\nconst types  = ret.types;\n\n\nmodule.exports = class RandExp {\n  /**\n   * @constructor\n   * @param {RegExp|String} regexp\n   * @param {String} m\n   */\n  constructor(regexp, m) {\n    this._setDefaults(regexp);\n    if (regexp instanceof RegExp) {\n      this.ignoreCase = regexp.ignoreCase;\n      this.multiline = regexp.multiline;\n      regexp = regexp.source;\n\n    } else if (typeof regexp === 'string') {\n      this.ignoreCase = m && m.indexOf('i') !== -1;\n      this.multiline = m && m.indexOf('m') !== -1;\n    } else {\n      throw new Error('Expected a regexp or string');\n    }\n\n    this.tokens = ret(regexp);\n  }\n\n\n  /**\n   * Checks if some custom properties have been set for this regexp.\n   *\n   * @param {RandExp} randexp\n   * @param {RegExp} regexp\n   */\n  _setDefaults(regexp) {\n    // When a repetitional token has its max set to Infinite,\n    // randexp won't actually generate a random amount between min and Infinite\n    // instead it will see Infinite as min + 100.\n    this.max = regexp.max != null ? regexp.max :\n      RandExp.prototype.max != null ? RandExp.prototype.max : 100;\n\n    // This allows expanding to include additional characters\n    // for instance: RandExp.defaultRange.add(0, 65535);\n    this.defaultRange = regexp.defaultRange ?\n      regexp.defaultRange : this.defaultRange.clone();\n\n    if (regexp.randInt) {\n      this.randInt = regexp.randInt;\n    }\n  }\n\n\n  /**\n   * Generates the random string.\n   *\n   * @return {String}\n   */\n  gen() {\n    return this._gen(this.tokens, []);\n  }\n\n\n  /**\n   * Generate random string modeled after given tokens.\n   *\n   * @param {Object} token\n   * @param {Array.<String>} groups\n   * @return {String}\n   */\n  _gen(token, groups) {\n    var stack, str, n, i, l;\n\n    switch (token.type) {\n      case types.ROOT:\n      case types.GROUP:\n        // Ignore lookaheads for now.\n        if (token.followedBy || token.notFollowedBy) { return ''; }\n\n        // Insert placeholder until group string is generated.\n        if (token.remember && token.groupNumber === undefined) {\n          token.groupNumber = groups.push(null) - 1;\n        }\n\n        stack = token.options ?\n          this._randSelect(token.options) : token.stack;\n\n        str = '';\n        for (i = 0, l = stack.length; i < l; i++) {\n          str += this._gen(stack[i], groups);\n        }\n\n        if (token.remember) {\n          groups[token.groupNumber] = str;\n        }\n        return str;\n\n      case types.POSITION:\n        // Do nothing for now.\n        return '';\n\n      case types.SET:\n        var expandedSet = this._expand(token);\n        if (!expandedSet.length) { return ''; }\n        return String.fromCharCode(this._randSelect(expandedSet));\n\n      case types.REPETITION:\n        // Randomly generate number between min and max.\n        n = this.randInt(token.min,\n          token.max === Infinity ? token.min + this.max : token.max);\n\n        str = '';\n        for (i = 0; i < n; i++) {\n          str += this._gen(token.value, groups);\n        }\n\n        return str;\n\n      case types.REFERENCE:\n        return groups[token.value - 1] || '';\n\n      case types.CHAR:\n        var code = this.ignoreCase && this._randBool() ?\n          this._toOtherCase(token.value) : token.value;\n        return String.fromCharCode(code);\n    }\n  }\n\n\n  /**\n   * If code is alphabetic, converts to other case.\n   * If not alphabetic, returns back code.\n   *\n   * @param {Number} code\n   * @return {Number}\n   */\n  _toOtherCase(code) {\n    return code + (97 <= code && code <= 122 ? -32 :\n      65 <= code && code <= 90  ?  32 : 0);\n  }\n\n\n  /**\n   * Randomly returns a true or false value.\n   *\n   * @return {Boolean}\n   */\n  _randBool() {\n    return !this.randInt(0, 1);\n  }\n\n\n  /**\n   * Randomly selects and returns a value from the array.\n   *\n   * @param {Array.<Object>} arr\n   * @return {Object}\n   */\n  _randSelect(arr) {\n    if (arr instanceof DRange) {\n      return arr.index(this.randInt(0, arr.length - 1));\n    }\n    return arr[this.randInt(0, arr.length - 1)];\n  }\n\n\n  /**\n   * expands a token to a DiscontinuousRange of characters which has a\n   * length and an index function (for random selecting)\n   *\n   * @param {Object} token\n   * @return {DiscontinuousRange}\n   */\n  _expand(token) {\n    if (token.type === ret.types.CHAR) {\n      return new DRange(token.value);\n    } else if (token.type === ret.types.RANGE) {\n      return new DRange(token.from, token.to);\n    } else {\n      let drange = new DRange();\n      for (let i = 0; i < token.set.length; i++) {\n        let subrange = this._expand(token.set[i]);\n        drange.add(subrange);\n        if (this.ignoreCase) {\n          for (let j = 0; j < subrange.length; j++) {\n            let code = subrange.index(j);\n            let otherCaseCode = this._toOtherCase(code);\n            if (code !== otherCaseCode) {\n              drange.add(otherCaseCode);\n            }\n          }\n        }\n      }\n      if (token.not) {\n        return this.defaultRange.clone().subtract(drange);\n      } else {\n        return this.defaultRange.clone().intersect(drange);\n      }\n    }\n  }\n\n\n  /**\n   * Randomly generates and returns a number between a and b (inclusive).\n   *\n   * @param {Number} a\n   * @param {Number} b\n   * @return {Number}\n   */\n  randInt(a, b) {\n    return a + Math.floor(Math.random() * (1 + b - a));\n  }\n\n\n  /**\n   * Default range of characters to generate from.\n   */\n  get defaultRange() {\n    return this._range = this._range || new DRange(32, 126);\n  }\n\n  set defaultRange(range) {\n    this._range = range;\n  }\n\n\n  /**\n   *\n   * Enables use of randexp with a shorter call.\n   *\n   * @param {RegExp|String| regexp}\n   * @param {String} m\n   * @return {String}\n   */\n  static randexp(regexp, m) {\n    var randexp;\n    if(typeof regexp === 'string') {\n      regexp = new RegExp(regexp, m);\n    }\n\n    if (regexp._randexp === undefined) {\n      randexp = new RandExp(regexp, m);\n      regexp._randexp = randexp;\n    } else {\n      randexp = regexp._randexp;\n      randexp._setDefaults(regexp);\n    }\n    return randexp.gen();\n  }\n\n\n  /**\n   * Enables sugary /regexp/.gen syntax.\n   */\n  static sugar() {\n    /* eshint freeze:false */\n    RegExp.prototype.gen = function() {\n      return RandExp.randexp(this);\n    };\n  }\n};\n"]},"metadata":{},"sourceType":"script"}