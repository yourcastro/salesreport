{"ast":null,"code":"define([\"./core\", \"./var/document\", \"./var/isFunction\", \"./var/rnothtmlwhite\", \"./ajax/var/location\", \"./ajax/var/nonce\", \"./ajax/var/rquery\", \"./core/init\", \"./core/parseXML\", \"./event/trigger\", \"./deferred\", \"./serialize\" // jQuery.param\n], function (jQuery, document, isFunction, rnothtmlwhite, location, nonce, rquery) {\n  \"use strict\";\n\n  var r20 = /%20/g,\n      rhash = /#.*$/,\n      rantiCache = /([?&])_=[^&]*/,\n      rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n      // #7653, #8125, #8152: local protocol detection\n  rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n      rnoContent = /^(?:GET|HEAD)$/,\n      rprotocol = /^\\/\\//,\n\n  /* Prefilters\n   * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n   * 2) These are called:\n   *    - BEFORE asking for a transport\n   *    - AFTER param serialization (s.data is a string if s.processData is true)\n   * 3) key is the dataType\n   * 4) the catchall symbol \"*\" can be used\n   * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n   */\n  prefilters = {},\n\n  /* Transports bindings\n   * 1) key is the dataType\n   * 2) the catchall symbol \"*\" can be used\n   * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n   */\n  transports = {},\n      // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n  allTypes = \"*/\".concat(\"*\"),\n      // Anchor tag for parsing the document origin\n  originAnchor = document.createElement(\"a\");\n  originAnchor.href = location.href; // Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\n\n  function addToPrefiltersOrTransports(structure) {\n    // dataTypeExpression is optional and defaults to \"*\"\n    return function (dataTypeExpression, func) {\n      if (typeof dataTypeExpression !== \"string\") {\n        func = dataTypeExpression;\n        dataTypeExpression = \"*\";\n      }\n\n      var dataType,\n          i = 0,\n          dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];\n\n      if (isFunction(func)) {\n        // For each dataType in the dataTypeExpression\n        while (dataType = dataTypes[i++]) {\n          // Prepend if requested\n          if (dataType[0] === \"+\") {\n            dataType = dataType.slice(1) || \"*\";\n            (structure[dataType] = structure[dataType] || []).unshift(func); // Otherwise append\n          } else {\n            (structure[dataType] = structure[dataType] || []).push(func);\n          }\n        }\n      }\n    };\n  } // Base inspection function for prefilters and transports\n\n\n  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {\n    var inspected = {},\n        seekingTransport = structure === transports;\n\n    function inspect(dataType) {\n      var selected;\n      inspected[dataType] = true;\n      jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {\n        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);\n\n        if (typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[dataTypeOrTransport]) {\n          options.dataTypes.unshift(dataTypeOrTransport);\n          inspect(dataTypeOrTransport);\n          return false;\n        } else if (seekingTransport) {\n          return !(selected = dataTypeOrTransport);\n        }\n      });\n      return selected;\n    }\n\n    return inspect(options.dataTypes[0]) || !inspected[\"*\"] && inspect(\"*\");\n  } // A special extend for ajax options\n  // that takes \"flat\" options (not to be deep extended)\n  // Fixes #9887\n\n\n  function ajaxExtend(target, src) {\n    var key,\n        deep,\n        flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n    for (key in src) {\n      if (src[key] !== undefined) {\n        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];\n      }\n    }\n\n    if (deep) {\n      jQuery.extend(true, target, deep);\n    }\n\n    return target;\n  }\n  /* Handles responses to an ajax request:\n   * - finds the right dataType (mediates between content-type and expected dataType)\n   * - returns the corresponding response\n   */\n\n\n  function ajaxHandleResponses(s, jqXHR, responses) {\n    var ct,\n        type,\n        finalDataType,\n        firstDataType,\n        contents = s.contents,\n        dataTypes = s.dataTypes; // Remove auto dataType and get content-type in the process\n\n    while (dataTypes[0] === \"*\") {\n      dataTypes.shift();\n\n      if (ct === undefined) {\n        ct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n      }\n    } // Check if we're dealing with a known content-type\n\n\n    if (ct) {\n      for (type in contents) {\n        if (contents[type] && contents[type].test(ct)) {\n          dataTypes.unshift(type);\n          break;\n        }\n      }\n    } // Check to see if we have a response for the expected dataType\n\n\n    if (dataTypes[0] in responses) {\n      finalDataType = dataTypes[0];\n    } else {\n      // Try convertible dataTypes\n      for (type in responses) {\n        if (!dataTypes[0] || s.converters[type + \" \" + dataTypes[0]]) {\n          finalDataType = type;\n          break;\n        }\n\n        if (!firstDataType) {\n          firstDataType = type;\n        }\n      } // Or just use first one\n\n\n      finalDataType = finalDataType || firstDataType;\n    } // If we found a dataType\n    // We add the dataType to the list if needed\n    // and return the corresponding response\n\n\n    if (finalDataType) {\n      if (finalDataType !== dataTypes[0]) {\n        dataTypes.unshift(finalDataType);\n      }\n\n      return responses[finalDataType];\n    }\n  }\n  /* Chain conversions given the request and the original response\n   * Also sets the responseXXX fields on the jqXHR instance\n   */\n\n\n  function ajaxConvert(s, response, jqXHR, isSuccess) {\n    var conv2,\n        current,\n        conv,\n        tmp,\n        prev,\n        converters = {},\n        // Work with a copy of dataTypes in case we need to modify it for conversion\n    dataTypes = s.dataTypes.slice(); // Create converters map with lowercased keys\n\n    if (dataTypes[1]) {\n      for (conv in s.converters) {\n        converters[conv.toLowerCase()] = s.converters[conv];\n      }\n    }\n\n    current = dataTypes.shift(); // Convert to each sequential dataType\n\n    while (current) {\n      if (s.responseFields[current]) {\n        jqXHR[s.responseFields[current]] = response;\n      } // Apply the dataFilter if provided\n\n\n      if (!prev && isSuccess && s.dataFilter) {\n        response = s.dataFilter(response, s.dataType);\n      }\n\n      prev = current;\n      current = dataTypes.shift();\n\n      if (current) {\n        // There's only work to do if current dataType is non-auto\n        if (current === \"*\") {\n          current = prev; // Convert response if prev dataType is non-auto and differs from current\n        } else if (prev !== \"*\" && prev !== current) {\n          // Seek a direct converter\n          conv = converters[prev + \" \" + current] || converters[\"* \" + current]; // If none found, seek a pair\n\n          if (!conv) {\n            for (conv2 in converters) {\n              // If conv2 outputs current\n              tmp = conv2.split(\" \");\n\n              if (tmp[1] === current) {\n                // If prev can be converted to accepted input\n                conv = converters[prev + \" \" + tmp[0]] || converters[\"* \" + tmp[0]];\n\n                if (conv) {\n                  // Condense equivalence converters\n                  if (conv === true) {\n                    conv = converters[conv2]; // Otherwise, insert the intermediate dataType\n                  } else if (converters[conv2] !== true) {\n                    current = tmp[0];\n                    dataTypes.unshift(tmp[1]);\n                  }\n\n                  break;\n                }\n              }\n            }\n          } // Apply converter (if not an equivalence)\n\n\n          if (conv !== true) {\n            // Unless errors are allowed to bubble, catch and return them\n            if (conv && s.throws) {\n              response = conv(response);\n            } else {\n              try {\n                response = conv(response);\n              } catch (e) {\n                return {\n                  state: \"parsererror\",\n                  error: conv ? e : \"No conversion from \" + prev + \" to \" + current\n                };\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return {\n      state: \"success\",\n      data: response\n    };\n  }\n\n  jQuery.extend({\n    // Counter for holding the number of active queries\n    active: 0,\n    // Last-Modified header cache for next request\n    lastModified: {},\n    etag: {},\n    ajaxSettings: {\n      url: location.href,\n      type: \"GET\",\n      isLocal: rlocalProtocol.test(location.protocol),\n      global: true,\n      processData: true,\n      async: true,\n      contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n      /*\n      timeout: 0,\n      data: null,\n      dataType: null,\n      username: null,\n      password: null,\n      cache: null,\n      throws: false,\n      traditional: false,\n      headers: {},\n      */\n      accepts: {\n        \"*\": allTypes,\n        text: \"text/plain\",\n        html: \"text/html\",\n        xml: \"application/xml, text/xml\",\n        json: \"application/json, text/javascript\"\n      },\n      contents: {\n        xml: /\\bxml\\b/,\n        html: /\\bhtml/,\n        json: /\\bjson\\b/\n      },\n      responseFields: {\n        xml: \"responseXML\",\n        text: \"responseText\",\n        json: \"responseJSON\"\n      },\n      // Data converters\n      // Keys separate source (or catchall \"*\") and destination types with a single space\n      converters: {\n        // Convert anything to text\n        \"* text\": String,\n        // Text to html (true = no transformation)\n        \"text html\": true,\n        // Evaluate text as a json expression\n        \"text json\": JSON.parse,\n        // Parse text as xml\n        \"text xml\": jQuery.parseXML\n      },\n      // For options that shouldn't be deep extended:\n      // you can add your own custom options here if\n      // and when you create one that shouldn't be\n      // deep extended (see ajaxExtend)\n      flatOptions: {\n        url: true,\n        context: true\n      }\n    },\n    // Creates a full fledged settings object into target\n    // with both ajaxSettings and settings fields.\n    // If target is omitted, writes into ajaxSettings.\n    ajaxSetup: function (target, settings) {\n      return settings ? // Building a settings object\n      ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : // Extending ajaxSettings\n      ajaxExtend(jQuery.ajaxSettings, target);\n    },\n    ajaxPrefilter: addToPrefiltersOrTransports(prefilters),\n    ajaxTransport: addToPrefiltersOrTransports(transports),\n    // Main method\n    ajax: function (url, options) {\n      // If url is an object, simulate pre-1.5 signature\n      if (typeof url === \"object\") {\n        options = url;\n        url = undefined;\n      } // Force options to be an object\n\n\n      options = options || {};\n      var transport,\n          // URL without anti-cache param\n      cacheURL,\n          // Response headers\n      responseHeadersString,\n          responseHeaders,\n          // timeout handle\n      timeoutTimer,\n          // Url cleanup var\n      urlAnchor,\n          // Request state (becomes false upon send and true upon completion)\n      completed,\n          // To know if global events are to be dispatched\n      fireGlobals,\n          // Loop variable\n      i,\n          // uncached part of the url\n      uncached,\n          // Create the final options object\n      s = jQuery.ajaxSetup({}, options),\n          // Callbacks context\n      callbackContext = s.context || s,\n          // Context for global events is callbackContext if it is a DOM node or jQuery collection\n      globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,\n          // Deferreds\n      deferred = jQuery.Deferred(),\n          completeDeferred = jQuery.Callbacks(\"once memory\"),\n          // Status-dependent callbacks\n      statusCode = s.statusCode || {},\n          // Headers (they are sent all at once)\n      requestHeaders = {},\n          requestHeadersNames = {},\n          // Default abort message\n      strAbort = \"canceled\",\n          // Fake xhr\n      jqXHR = {\n        readyState: 0,\n        // Builds headers hashtable if needed\n        getResponseHeader: function (key) {\n          var match;\n\n          if (completed) {\n            if (!responseHeaders) {\n              responseHeaders = {};\n\n              while (match = rheaders.exec(responseHeadersString)) {\n                responseHeaders[match[1].toLowerCase() + \" \"] = (responseHeaders[match[1].toLowerCase() + \" \"] || []).concat(match[2]);\n              }\n            }\n\n            match = responseHeaders[key.toLowerCase() + \" \"];\n          }\n\n          return match == null ? null : match.join(\", \");\n        },\n        // Raw string\n        getAllResponseHeaders: function () {\n          return completed ? responseHeadersString : null;\n        },\n        // Caches the header\n        setRequestHeader: function (name, value) {\n          if (completed == null) {\n            name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name;\n            requestHeaders[name] = value;\n          }\n\n          return this;\n        },\n        // Overrides response content-type header\n        overrideMimeType: function (type) {\n          if (completed == null) {\n            s.mimeType = type;\n          }\n\n          return this;\n        },\n        // Status-dependent callbacks\n        statusCode: function (map) {\n          var code;\n\n          if (map) {\n            if (completed) {\n              // Execute the appropriate callbacks\n              jqXHR.always(map[jqXHR.status]);\n            } else {\n              // Lazy-add the new callbacks in a way that preserves old ones\n              for (code in map) {\n                statusCode[code] = [statusCode[code], map[code]];\n              }\n            }\n          }\n\n          return this;\n        },\n        // Cancel the request\n        abort: function (statusText) {\n          var finalText = statusText || strAbort;\n\n          if (transport) {\n            transport.abort(finalText);\n          }\n\n          done(0, finalText);\n          return this;\n        }\n      }; // Attach deferreds\n\n      deferred.promise(jqXHR); // Add protocol if not provided (prefilters might expect it)\n      // Handle falsy url in the settings object (#10093: consistency with old signature)\n      // We also use the url parameter if available\n\n      s.url = ((url || s.url || location.href) + \"\").replace(rprotocol, location.protocol + \"//\"); // Alias method option to type as per ticket #12004\n\n      s.type = options.method || options.type || s.method || s.type; // Extract dataTypes list\n\n      s.dataTypes = (s.dataType || \"*\").toLowerCase().match(rnothtmlwhite) || [\"\"]; // A cross-domain request is in order when the origin doesn't match the current origin.\n\n      if (s.crossDomain == null) {\n        urlAnchor = document.createElement(\"a\"); // Support: IE <=8 - 11, Edge 12 - 15\n        // IE throws exception on accessing the href property if url is malformed,\n        // e.g. http://example.com:80x/\n\n        try {\n          urlAnchor.href = s.url; // Support: IE <=8 - 11 only\n          // Anchor's host property isn't correctly set when s.url is relative\n\n          urlAnchor.href = urlAnchor.href;\n          s.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !== urlAnchor.protocol + \"//\" + urlAnchor.host;\n        } catch (e) {\n          // If there is an error parsing the URL, assume it is crossDomain,\n          // it can be rejected by the transport if it is invalid\n          s.crossDomain = true;\n        }\n      } // Convert data if not already a string\n\n\n      if (s.data && s.processData && typeof s.data !== \"string\") {\n        s.data = jQuery.param(s.data, s.traditional);\n      } // Apply prefilters\n\n\n      inspectPrefiltersOrTransports(prefilters, s, options, jqXHR); // If request was aborted inside a prefilter, stop there\n\n      if (completed) {\n        return jqXHR;\n      } // We can fire global events as of now if asked to\n      // Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\n\n      fireGlobals = jQuery.event && s.global; // Watch for a new set of requests\n\n      if (fireGlobals && jQuery.active++ === 0) {\n        jQuery.event.trigger(\"ajaxStart\");\n      } // Uppercase the type\n\n\n      s.type = s.type.toUpperCase(); // Determine if request has content\n\n      s.hasContent = !rnoContent.test(s.type); // Save the URL in case we're toying with the If-Modified-Since\n      // and/or If-None-Match header later on\n      // Remove hash to simplify url manipulation\n\n      cacheURL = s.url.replace(rhash, \"\"); // More options handling for requests with no content\n\n      if (!s.hasContent) {\n        // Remember the hash so we can put it back\n        uncached = s.url.slice(cacheURL.length); // If data is available and should be processed, append data to url\n\n        if (s.data && (s.processData || typeof s.data === \"string\")) {\n          cacheURL += (rquery.test(cacheURL) ? \"&\" : \"?\") + s.data; // #9682: remove data so that it's not used in an eventual retry\n\n          delete s.data;\n        } // Add or update anti-cache param if needed\n\n\n        if (s.cache === false) {\n          cacheURL = cacheURL.replace(rantiCache, \"$1\");\n          uncached = (rquery.test(cacheURL) ? \"&\" : \"?\") + \"_=\" + nonce.guid++ + uncached;\n        } // Put hash and anti-cache on the URL that will be requested (gh-1732)\n\n\n        s.url = cacheURL + uncached; // Change '%20' to '+' if this is encoded form body content (gh-2658)\n      } else if (s.data && s.processData && (s.contentType || \"\").indexOf(\"application/x-www-form-urlencoded\") === 0) {\n        s.data = s.data.replace(r20, \"+\");\n      } // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\n\n      if (s.ifModified) {\n        if (jQuery.lastModified[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-Modified-Since\", jQuery.lastModified[cacheURL]);\n        }\n\n        if (jQuery.etag[cacheURL]) {\n          jqXHR.setRequestHeader(\"If-None-Match\", jQuery.etag[cacheURL]);\n        }\n      } // Set the correct header, if data is being sent\n\n\n      if (s.data && s.hasContent && s.contentType !== false || options.contentType) {\n        jqXHR.setRequestHeader(\"Content-Type\", s.contentType);\n      } // Set the Accepts header for the server, depending on the dataType\n\n\n      jqXHR.setRequestHeader(\"Accept\", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\") : s.accepts[\"*\"]); // Check for headers option\n\n      for (i in s.headers) {\n        jqXHR.setRequestHeader(i, s.headers[i]);\n      } // Allow custom headers/mimetypes and early abort\n\n\n      if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || completed)) {\n        // Abort if not done already and return\n        return jqXHR.abort();\n      } // Aborting is no longer a cancellation\n\n\n      strAbort = \"abort\"; // Install callbacks on deferreds\n\n      completeDeferred.add(s.complete);\n      jqXHR.done(s.success);\n      jqXHR.fail(s.error); // Get transport\n\n      transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR); // If no transport, we auto-abort\n\n      if (!transport) {\n        done(-1, \"No Transport\");\n      } else {\n        jqXHR.readyState = 1; // Send global event\n\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxSend\", [jqXHR, s]);\n        } // If request was aborted inside ajaxSend, stop there\n\n\n        if (completed) {\n          return jqXHR;\n        } // Timeout\n\n\n        if (s.async && s.timeout > 0) {\n          timeoutTimer = window.setTimeout(function () {\n            jqXHR.abort(\"timeout\");\n          }, s.timeout);\n        }\n\n        try {\n          completed = false;\n          transport.send(requestHeaders, done);\n        } catch (e) {\n          // Rethrow post-completion exceptions\n          if (completed) {\n            throw e;\n          } // Propagate others as results\n\n\n          done(-1, e);\n        }\n      } // Callback for when everything is done\n\n\n      function done(status, nativeStatusText, responses, headers) {\n        var isSuccess,\n            success,\n            error,\n            response,\n            modified,\n            statusText = nativeStatusText; // Ignore repeat invocations\n\n        if (completed) {\n          return;\n        }\n\n        completed = true; // Clear timeout if it exists\n\n        if (timeoutTimer) {\n          window.clearTimeout(timeoutTimer);\n        } // Dereference transport for early garbage collection\n        // (no matter how long the jqXHR object will be used)\n\n\n        transport = undefined; // Cache response headers\n\n        responseHeadersString = headers || \"\"; // Set readyState\n\n        jqXHR.readyState = status > 0 ? 4 : 0; // Determine if successful\n\n        isSuccess = status >= 200 && status < 300 || status === 304; // Get response data\n\n        if (responses) {\n          response = ajaxHandleResponses(s, jqXHR, responses);\n        } // Use a noop converter for missing script but not if jsonp\n\n\n        if (!isSuccess && jQuery.inArray(\"script\", s.dataTypes) > -1 && jQuery.inArray(\"json\", s.dataTypes) < 0) {\n          s.converters[\"text script\"] = function () {};\n        } // Convert no matter what (that way responseXXX fields are always set)\n\n\n        response = ajaxConvert(s, response, jqXHR, isSuccess); // If successful, handle type chaining\n\n        if (isSuccess) {\n          // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n          if (s.ifModified) {\n            modified = jqXHR.getResponseHeader(\"Last-Modified\");\n\n            if (modified) {\n              jQuery.lastModified[cacheURL] = modified;\n            }\n\n            modified = jqXHR.getResponseHeader(\"etag\");\n\n            if (modified) {\n              jQuery.etag[cacheURL] = modified;\n            }\n          } // if no content\n\n\n          if (status === 204 || s.type === \"HEAD\") {\n            statusText = \"nocontent\"; // if not modified\n          } else if (status === 304) {\n            statusText = \"notmodified\"; // If we have data, let's convert it\n          } else {\n            statusText = response.state;\n            success = response.data;\n            error = response.error;\n            isSuccess = !error;\n          }\n        } else {\n          // Extract error from statusText and normalize for non-aborts\n          error = statusText;\n\n          if (status || !statusText) {\n            statusText = \"error\";\n\n            if (status < 0) {\n              status = 0;\n            }\n          }\n        } // Set data for the fake xhr object\n\n\n        jqXHR.status = status;\n        jqXHR.statusText = (nativeStatusText || statusText) + \"\"; // Success/Error\n\n        if (isSuccess) {\n          deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);\n        } else {\n          deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);\n        } // Status-dependent callbacks\n\n\n        jqXHR.statusCode(statusCode);\n        statusCode = undefined;\n\n        if (fireGlobals) {\n          globalEventContext.trigger(isSuccess ? \"ajaxSuccess\" : \"ajaxError\", [jqXHR, s, isSuccess ? success : error]);\n        } // Complete\n\n\n        completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);\n\n        if (fireGlobals) {\n          globalEventContext.trigger(\"ajaxComplete\", [jqXHR, s]); // Handle the global AJAX counter\n\n          if (! --jQuery.active) {\n            jQuery.event.trigger(\"ajaxStop\");\n          }\n        }\n      }\n\n      return jqXHR;\n    },\n    getJSON: function (url, data, callback) {\n      return jQuery.get(url, data, callback, \"json\");\n    },\n    getScript: function (url, callback) {\n      return jQuery.get(url, undefined, callback, \"script\");\n    }\n  });\n  jQuery.each([\"get\", \"post\"], function (_i, method) {\n    jQuery[method] = function (url, data, callback, type) {\n      // Shift arguments if data argument was omitted\n      if (isFunction(data)) {\n        type = type || callback;\n        callback = data;\n        data = undefined;\n      } // The url can be an options object (which then must have .url)\n\n\n      return jQuery.ajax(jQuery.extend({\n        url: url,\n        type: method,\n        dataType: type,\n        data: data,\n        success: callback\n      }, jQuery.isPlainObject(url) && url));\n    };\n  });\n  jQuery.ajaxPrefilter(function (s) {\n    var i;\n\n    for (i in s.headers) {\n      if (i.toLowerCase() === \"content-type\") {\n        s.contentType = s.headers[i] || \"\";\n      }\n    }\n  });\n  return jQuery;\n});","map":{"version":3,"sources":["D:/Castro/Development/hr-management-portal/hr-management-portal/node_modules/jquery/src/ajax.js"],"names":["define","jQuery","document","isFunction","rnothtmlwhite","location","nonce","rquery","r20","rhash","rantiCache","rheaders","rlocalProtocol","rnoContent","rprotocol","prefilters","transports","allTypes","concat","originAnchor","createElement","href","addToPrefiltersOrTransports","structure","dataTypeExpression","func","dataType","i","dataTypes","toLowerCase","match","slice","unshift","push","inspectPrefiltersOrTransports","options","originalOptions","jqXHR","inspected","seekingTransport","inspect","selected","each","_","prefilterOrFactory","dataTypeOrTransport","ajaxExtend","target","src","key","deep","flatOptions","ajaxSettings","undefined","extend","ajaxHandleResponses","s","responses","ct","type","finalDataType","firstDataType","contents","shift","mimeType","getResponseHeader","test","converters","ajaxConvert","response","isSuccess","conv2","current","conv","tmp","prev","responseFields","dataFilter","split","throws","e","state","error","data","active","lastModified","etag","url","isLocal","protocol","global","processData","async","contentType","accepts","text","html","xml","json","String","JSON","parse","parseXML","context","ajaxSetup","settings","ajaxPrefilter","ajaxTransport","ajax","transport","cacheURL","responseHeadersString","responseHeaders","timeoutTimer","urlAnchor","completed","fireGlobals","uncached","callbackContext","globalEventContext","nodeType","jquery","event","deferred","Deferred","completeDeferred","Callbacks","statusCode","requestHeaders","requestHeadersNames","strAbort","readyState","exec","join","getAllResponseHeaders","setRequestHeader","name","value","overrideMimeType","map","code","always","status","abort","statusText","finalText","done","promise","replace","method","crossDomain","host","param","traditional","trigger","toUpperCase","hasContent","length","cache","guid","indexOf","ifModified","headers","beforeSend","call","add","complete","success","fail","timeout","window","setTimeout","send","nativeStatusText","modified","clearTimeout","inArray","resolveWith","rejectWith","fireWith","getJSON","callback","get","getScript","_i","isPlainObject"],"mappings":"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","sourcesContent":["define( [\n\t\"./core\",\n\t\"./var/document\",\n\t\"./var/isFunction\",\n\t\"./var/rnothtmlwhite\",\n\t\"./ajax/var/location\",\n\t\"./ajax/var/nonce\",\n\t\"./ajax/var/rquery\",\n\n\t\"./core/init\",\n\t\"./core/parseXML\",\n\t\"./event/trigger\",\n\t\"./deferred\",\n\t\"./serialize\" // jQuery.param\n], function( jQuery, document, isFunction, rnothtmlwhite, location, nonce, rquery ) {\n\n\"use strict\";\n\nvar\n\tr20 = /%20/g,\n\trhash = /#.*$/,\n\trantiCache = /([?&])_=[^&]*/,\n\trheaders = /^(.*?):[ \\t]*([^\\r\\n]*)$/mg,\n\n\t// #7653, #8125, #8152: local protocol detection\n\trlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n\trnoContent = /^(?:GET|HEAD)$/,\n\trprotocol = /^\\/\\//,\n\n\t/* Prefilters\n\t * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n\t * 2) These are called:\n\t *    - BEFORE asking for a transport\n\t *    - AFTER param serialization (s.data is a string if s.processData is true)\n\t * 3) key is the dataType\n\t * 4) the catchall symbol \"*\" can be used\n\t * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n\t */\n\tprefilters = {},\n\n\t/* Transports bindings\n\t * 1) key is the dataType\n\t * 2) the catchall symbol \"*\" can be used\n\t * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n\t */\n\ttransports = {},\n\n\t// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n\tallTypes = \"*/\".concat( \"*\" ),\n\n\t// Anchor tag for parsing the document origin\n\toriginAnchor = document.createElement( \"a\" );\n\noriginAnchor.href = location.href;\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n\t// dataTypeExpression is optional and defaults to \"*\"\n\treturn function( dataTypeExpression, func ) {\n\n\t\tif ( typeof dataTypeExpression !== \"string\" ) {\n\t\t\tfunc = dataTypeExpression;\n\t\t\tdataTypeExpression = \"*\";\n\t\t}\n\n\t\tvar dataType,\n\t\t\ti = 0,\n\t\t\tdataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];\n\n\t\tif ( isFunction( func ) ) {\n\n\t\t\t// For each dataType in the dataTypeExpression\n\t\t\twhile ( ( dataType = dataTypes[ i++ ] ) ) {\n\n\t\t\t\t// Prepend if requested\n\t\t\t\tif ( dataType[ 0 ] === \"+\" ) {\n\t\t\t\t\tdataType = dataType.slice( 1 ) || \"*\";\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );\n\n\t\t\t\t// Otherwise append\n\t\t\t\t} else {\n\t\t\t\t\t( structure[ dataType ] = structure[ dataType ] || [] ).push( func );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n\tvar inspected = {},\n\t\tseekingTransport = ( structure === transports );\n\n\tfunction inspect( dataType ) {\n\t\tvar selected;\n\t\tinspected[ dataType ] = true;\n\t\tjQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n\t\t\tvar dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n\t\t\tif ( typeof dataTypeOrTransport === \"string\" &&\n\t\t\t\t!seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n\n\t\t\t\toptions.dataTypes.unshift( dataTypeOrTransport );\n\t\t\t\tinspect( dataTypeOrTransport );\n\t\t\t\treturn false;\n\t\t\t} else if ( seekingTransport ) {\n\t\t\t\treturn !( selected = dataTypeOrTransport );\n\t\t\t}\n\t\t} );\n\t\treturn selected;\n\t}\n\n\treturn inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n\tvar key, deep,\n\t\tflatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n\tfor ( key in src ) {\n\t\tif ( src[ key ] !== undefined ) {\n\t\t\t( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];\n\t\t}\n\t}\n\tif ( deep ) {\n\t\tjQuery.extend( true, target, deep );\n\t}\n\n\treturn target;\n}\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n\n\tvar ct, type, finalDataType, firstDataType,\n\t\tcontents = s.contents,\n\t\tdataTypes = s.dataTypes;\n\n\t// Remove auto dataType and get content-type in the process\n\twhile ( dataTypes[ 0 ] === \"*\" ) {\n\t\tdataTypes.shift();\n\t\tif ( ct === undefined ) {\n\t\t\tct = s.mimeType || jqXHR.getResponseHeader( \"Content-Type\" );\n\t\t}\n\t}\n\n\t// Check if we're dealing with a known content-type\n\tif ( ct ) {\n\t\tfor ( type in contents ) {\n\t\t\tif ( contents[ type ] && contents[ type ].test( ct ) ) {\n\t\t\t\tdataTypes.unshift( type );\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t// Check to see if we have a response for the expected dataType\n\tif ( dataTypes[ 0 ] in responses ) {\n\t\tfinalDataType = dataTypes[ 0 ];\n\t} else {\n\n\t\t// Try convertible dataTypes\n\t\tfor ( type in responses ) {\n\t\t\tif ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[ 0 ] ] ) {\n\t\t\t\tfinalDataType = type;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif ( !firstDataType ) {\n\t\t\t\tfirstDataType = type;\n\t\t\t}\n\t\t}\n\n\t\t// Or just use first one\n\t\tfinalDataType = finalDataType || firstDataType;\n\t}\n\n\t// If we found a dataType\n\t// We add the dataType to the list if needed\n\t// and return the corresponding response\n\tif ( finalDataType ) {\n\t\tif ( finalDataType !== dataTypes[ 0 ] ) {\n\t\t\tdataTypes.unshift( finalDataType );\n\t\t}\n\t\treturn responses[ finalDataType ];\n\t}\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n\tvar conv2, current, conv, tmp, prev,\n\t\tconverters = {},\n\n\t\t// Work with a copy of dataTypes in case we need to modify it for conversion\n\t\tdataTypes = s.dataTypes.slice();\n\n\t// Create converters map with lowercased keys\n\tif ( dataTypes[ 1 ] ) {\n\t\tfor ( conv in s.converters ) {\n\t\t\tconverters[ conv.toLowerCase() ] = s.converters[ conv ];\n\t\t}\n\t}\n\n\tcurrent = dataTypes.shift();\n\n\t// Convert to each sequential dataType\n\twhile ( current ) {\n\n\t\tif ( s.responseFields[ current ] ) {\n\t\t\tjqXHR[ s.responseFields[ current ] ] = response;\n\t\t}\n\n\t\t// Apply the dataFilter if provided\n\t\tif ( !prev && isSuccess && s.dataFilter ) {\n\t\t\tresponse = s.dataFilter( response, s.dataType );\n\t\t}\n\n\t\tprev = current;\n\t\tcurrent = dataTypes.shift();\n\n\t\tif ( current ) {\n\n\t\t\t// There's only work to do if current dataType is non-auto\n\t\t\tif ( current === \"*\" ) {\n\n\t\t\t\tcurrent = prev;\n\n\t\t\t// Convert response if prev dataType is non-auto and differs from current\n\t\t\t} else if ( prev !== \"*\" && prev !== current ) {\n\n\t\t\t\t// Seek a direct converter\n\t\t\t\tconv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n\t\t\t\t// If none found, seek a pair\n\t\t\t\tif ( !conv ) {\n\t\t\t\t\tfor ( conv2 in converters ) {\n\n\t\t\t\t\t\t// If conv2 outputs current\n\t\t\t\t\t\ttmp = conv2.split( \" \" );\n\t\t\t\t\t\tif ( tmp[ 1 ] === current ) {\n\n\t\t\t\t\t\t\t// If prev can be converted to accepted input\n\t\t\t\t\t\t\tconv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n\t\t\t\t\t\t\t\tconverters[ \"* \" + tmp[ 0 ] ];\n\t\t\t\t\t\t\tif ( conv ) {\n\n\t\t\t\t\t\t\t\t// Condense equivalence converters\n\t\t\t\t\t\t\t\tif ( conv === true ) {\n\t\t\t\t\t\t\t\t\tconv = converters[ conv2 ];\n\n\t\t\t\t\t\t\t\t// Otherwise, insert the intermediate dataType\n\t\t\t\t\t\t\t\t} else if ( converters[ conv2 ] !== true ) {\n\t\t\t\t\t\t\t\t\tcurrent = tmp[ 0 ];\n\t\t\t\t\t\t\t\t\tdataTypes.unshift( tmp[ 1 ] );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Apply converter (if not an equivalence)\n\t\t\t\tif ( conv !== true ) {\n\n\t\t\t\t\t// Unless errors are allowed to bubble, catch and return them\n\t\t\t\t\tif ( conv && s.throws ) {\n\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresponse = conv( response );\n\t\t\t\t\t\t} catch ( e ) {\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\tstate: \"parsererror\",\n\t\t\t\t\t\t\t\terror: conv ? e : \"No conversion from \" + prev + \" to \" + current\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn { state: \"success\", data: response };\n}\n\njQuery.extend( {\n\n\t// Counter for holding the number of active queries\n\tactive: 0,\n\n\t// Last-Modified header cache for next request\n\tlastModified: {},\n\tetag: {},\n\n\tajaxSettings: {\n\t\turl: location.href,\n\t\ttype: \"GET\",\n\t\tisLocal: rlocalProtocol.test( location.protocol ),\n\t\tglobal: true,\n\t\tprocessData: true,\n\t\tasync: true,\n\t\tcontentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n\n\t\t/*\n\t\ttimeout: 0,\n\t\tdata: null,\n\t\tdataType: null,\n\t\tusername: null,\n\t\tpassword: null,\n\t\tcache: null,\n\t\tthrows: false,\n\t\ttraditional: false,\n\t\theaders: {},\n\t\t*/\n\n\t\taccepts: {\n\t\t\t\"*\": allTypes,\n\t\t\ttext: \"text/plain\",\n\t\t\thtml: \"text/html\",\n\t\t\txml: \"application/xml, text/xml\",\n\t\t\tjson: \"application/json, text/javascript\"\n\t\t},\n\n\t\tcontents: {\n\t\t\txml: /\\bxml\\b/,\n\t\t\thtml: /\\bhtml/,\n\t\t\tjson: /\\bjson\\b/\n\t\t},\n\n\t\tresponseFields: {\n\t\t\txml: \"responseXML\",\n\t\t\ttext: \"responseText\",\n\t\t\tjson: \"responseJSON\"\n\t\t},\n\n\t\t// Data converters\n\t\t// Keys separate source (or catchall \"*\") and destination types with a single space\n\t\tconverters: {\n\n\t\t\t// Convert anything to text\n\t\t\t\"* text\": String,\n\n\t\t\t// Text to html (true = no transformation)\n\t\t\t\"text html\": true,\n\n\t\t\t// Evaluate text as a json expression\n\t\t\t\"text json\": JSON.parse,\n\n\t\t\t// Parse text as xml\n\t\t\t\"text xml\": jQuery.parseXML\n\t\t},\n\n\t\t// For options that shouldn't be deep extended:\n\t\t// you can add your own custom options here if\n\t\t// and when you create one that shouldn't be\n\t\t// deep extended (see ajaxExtend)\n\t\tflatOptions: {\n\t\t\turl: true,\n\t\t\tcontext: true\n\t\t}\n\t},\n\n\t// Creates a full fledged settings object into target\n\t// with both ajaxSettings and settings fields.\n\t// If target is omitted, writes into ajaxSettings.\n\tajaxSetup: function( target, settings ) {\n\t\treturn settings ?\n\n\t\t\t// Building a settings object\n\t\t\tajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n\t\t\t// Extending ajaxSettings\n\t\t\tajaxExtend( jQuery.ajaxSettings, target );\n\t},\n\n\tajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n\tajaxTransport: addToPrefiltersOrTransports( transports ),\n\n\t// Main method\n\tajax: function( url, options ) {\n\n\t\t// If url is an object, simulate pre-1.5 signature\n\t\tif ( typeof url === \"object\" ) {\n\t\t\toptions = url;\n\t\t\turl = undefined;\n\t\t}\n\n\t\t// Force options to be an object\n\t\toptions = options || {};\n\n\t\tvar transport,\n\n\t\t\t// URL without anti-cache param\n\t\t\tcacheURL,\n\n\t\t\t// Response headers\n\t\t\tresponseHeadersString,\n\t\t\tresponseHeaders,\n\n\t\t\t// timeout handle\n\t\t\ttimeoutTimer,\n\n\t\t\t// Url cleanup var\n\t\t\turlAnchor,\n\n\t\t\t// Request state (becomes false upon send and true upon completion)\n\t\t\tcompleted,\n\n\t\t\t// To know if global events are to be dispatched\n\t\t\tfireGlobals,\n\n\t\t\t// Loop variable\n\t\t\ti,\n\n\t\t\t// uncached part of the url\n\t\t\tuncached,\n\n\t\t\t// Create the final options object\n\t\t\ts = jQuery.ajaxSetup( {}, options ),\n\n\t\t\t// Callbacks context\n\t\t\tcallbackContext = s.context || s,\n\n\t\t\t// Context for global events is callbackContext if it is a DOM node or jQuery collection\n\t\t\tglobalEventContext = s.context &&\n\t\t\t\t( callbackContext.nodeType || callbackContext.jquery ) ?\n\t\t\t\tjQuery( callbackContext ) :\n\t\t\t\tjQuery.event,\n\n\t\t\t// Deferreds\n\t\t\tdeferred = jQuery.Deferred(),\n\t\t\tcompleteDeferred = jQuery.Callbacks( \"once memory\" ),\n\n\t\t\t// Status-dependent callbacks\n\t\t\tstatusCode = s.statusCode || {},\n\n\t\t\t// Headers (they are sent all at once)\n\t\t\trequestHeaders = {},\n\t\t\trequestHeadersNames = {},\n\n\t\t\t// Default abort message\n\t\t\tstrAbort = \"canceled\",\n\n\t\t\t// Fake xhr\n\t\t\tjqXHR = {\n\t\t\t\treadyState: 0,\n\n\t\t\t\t// Builds headers hashtable if needed\n\t\t\t\tgetResponseHeader: function( key ) {\n\t\t\t\t\tvar match;\n\t\t\t\t\tif ( completed ) {\n\t\t\t\t\t\tif ( !responseHeaders ) {\n\t\t\t\t\t\t\tresponseHeaders = {};\n\t\t\t\t\t\t\twhile ( ( match = rheaders.exec( responseHeadersString ) ) ) {\n\t\t\t\t\t\t\t\tresponseHeaders[ match[ 1 ].toLowerCase() + \" \" ] =\n\t\t\t\t\t\t\t\t\t( responseHeaders[ match[ 1 ].toLowerCase() + \" \" ] || [] )\n\t\t\t\t\t\t\t\t\t\t.concat( match[ 2 ] );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tmatch = responseHeaders[ key.toLowerCase() + \" \" ];\n\t\t\t\t\t}\n\t\t\t\t\treturn match == null ? null : match.join( \", \" );\n\t\t\t\t},\n\n\t\t\t\t// Raw string\n\t\t\t\tgetAllResponseHeaders: function() {\n\t\t\t\t\treturn completed ? responseHeadersString : null;\n\t\t\t\t},\n\n\t\t\t\t// Caches the header\n\t\t\t\tsetRequestHeader: function( name, value ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\tname = requestHeadersNames[ name.toLowerCase() ] =\n\t\t\t\t\t\t\trequestHeadersNames[ name.toLowerCase() ] || name;\n\t\t\t\t\t\trequestHeaders[ name ] = value;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Overrides response content-type header\n\t\t\t\toverrideMimeType: function( type ) {\n\t\t\t\t\tif ( completed == null ) {\n\t\t\t\t\t\ts.mimeType = type;\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Status-dependent callbacks\n\t\t\t\tstatusCode: function( map ) {\n\t\t\t\t\tvar code;\n\t\t\t\t\tif ( map ) {\n\t\t\t\t\t\tif ( completed ) {\n\n\t\t\t\t\t\t\t// Execute the appropriate callbacks\n\t\t\t\t\t\t\tjqXHR.always( map[ jqXHR.status ] );\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// Lazy-add the new callbacks in a way that preserves old ones\n\t\t\t\t\t\t\tfor ( code in map ) {\n\t\t\t\t\t\t\t\tstatusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\n\t\t\t\t// Cancel the request\n\t\t\t\tabort: function( statusText ) {\n\t\t\t\t\tvar finalText = statusText || strAbort;\n\t\t\t\t\tif ( transport ) {\n\t\t\t\t\t\ttransport.abort( finalText );\n\t\t\t\t\t}\n\t\t\t\t\tdone( 0, finalText );\n\t\t\t\t\treturn this;\n\t\t\t\t}\n\t\t\t};\n\n\t\t// Attach deferreds\n\t\tdeferred.promise( jqXHR );\n\n\t\t// Add protocol if not provided (prefilters might expect it)\n\t\t// Handle falsy url in the settings object (#10093: consistency with old signature)\n\t\t// We also use the url parameter if available\n\t\ts.url = ( ( url || s.url || location.href ) + \"\" )\n\t\t\t.replace( rprotocol, location.protocol + \"//\" );\n\n\t\t// Alias method option to type as per ticket #12004\n\t\ts.type = options.method || options.type || s.method || s.type;\n\n\t\t// Extract dataTypes list\n\t\ts.dataTypes = ( s.dataType || \"*\" ).toLowerCase().match( rnothtmlwhite ) || [ \"\" ];\n\n\t\t// A cross-domain request is in order when the origin doesn't match the current origin.\n\t\tif ( s.crossDomain == null ) {\n\t\t\turlAnchor = document.createElement( \"a\" );\n\n\t\t\t// Support: IE <=8 - 11, Edge 12 - 15\n\t\t\t// IE throws exception on accessing the href property if url is malformed,\n\t\t\t// e.g. http://example.com:80x/\n\t\t\ttry {\n\t\t\t\turlAnchor.href = s.url;\n\n\t\t\t\t// Support: IE <=8 - 11 only\n\t\t\t\t// Anchor's host property isn't correctly set when s.url is relative\n\t\t\t\turlAnchor.href = urlAnchor.href;\n\t\t\t\ts.crossDomain = originAnchor.protocol + \"//\" + originAnchor.host !==\n\t\t\t\t\turlAnchor.protocol + \"//\" + urlAnchor.host;\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// If there is an error parsing the URL, assume it is crossDomain,\n\t\t\t\t// it can be rejected by the transport if it is invalid\n\t\t\t\ts.crossDomain = true;\n\t\t\t}\n\t\t}\n\n\t\t// Convert data if not already a string\n\t\tif ( s.data && s.processData && typeof s.data !== \"string\" ) {\n\t\t\ts.data = jQuery.param( s.data, s.traditional );\n\t\t}\n\n\t\t// Apply prefilters\n\t\tinspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n\t\t// If request was aborted inside a prefilter, stop there\n\t\tif ( completed ) {\n\t\t\treturn jqXHR;\n\t\t}\n\n\t\t// We can fire global events as of now if asked to\n\t\t// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)\n\t\tfireGlobals = jQuery.event && s.global;\n\n\t\t// Watch for a new set of requests\n\t\tif ( fireGlobals && jQuery.active++ === 0 ) {\n\t\t\tjQuery.event.trigger( \"ajaxStart\" );\n\t\t}\n\n\t\t// Uppercase the type\n\t\ts.type = s.type.toUpperCase();\n\n\t\t// Determine if request has content\n\t\ts.hasContent = !rnoContent.test( s.type );\n\n\t\t// Save the URL in case we're toying with the If-Modified-Since\n\t\t// and/or If-None-Match header later on\n\t\t// Remove hash to simplify url manipulation\n\t\tcacheURL = s.url.replace( rhash, \"\" );\n\n\t\t// More options handling for requests with no content\n\t\tif ( !s.hasContent ) {\n\n\t\t\t// Remember the hash so we can put it back\n\t\t\tuncached = s.url.slice( cacheURL.length );\n\n\t\t\t// If data is available and should be processed, append data to url\n\t\t\tif ( s.data && ( s.processData || typeof s.data === \"string\" ) ) {\n\t\t\t\tcacheURL += ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data;\n\n\t\t\t\t// #9682: remove data so that it's not used in an eventual retry\n\t\t\t\tdelete s.data;\n\t\t\t}\n\n\t\t\t// Add or update anti-cache param if needed\n\t\t\tif ( s.cache === false ) {\n\t\t\t\tcacheURL = cacheURL.replace( rantiCache, \"$1\" );\n\t\t\t\tuncached = ( rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ( nonce.guid++ ) +\n\t\t\t\t\tuncached;\n\t\t\t}\n\n\t\t\t// Put hash and anti-cache on the URL that will be requested (gh-1732)\n\t\t\ts.url = cacheURL + uncached;\n\n\t\t// Change '%20' to '+' if this is encoded form body content (gh-2658)\n\t\t} else if ( s.data && s.processData &&\n\t\t\t( s.contentType || \"\" ).indexOf( \"application/x-www-form-urlencoded\" ) === 0 ) {\n\t\t\ts.data = s.data.replace( r20, \"+\" );\n\t\t}\n\n\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\tif ( s.ifModified ) {\n\t\t\tif ( jQuery.lastModified[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n\t\t\t}\n\t\t\tif ( jQuery.etag[ cacheURL ] ) {\n\t\t\t\tjqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n\t\t\t}\n\t\t}\n\n\t\t// Set the correct header, if data is being sent\n\t\tif ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n\t\t\tjqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n\t\t}\n\n\t\t// Set the Accepts header for the server, depending on the dataType\n\t\tjqXHR.setRequestHeader(\n\t\t\t\"Accept\",\n\t\t\ts.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?\n\t\t\t\ts.accepts[ s.dataTypes[ 0 ] ] +\n\t\t\t\t\t( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n\t\t\t\ts.accepts[ \"*\" ]\n\t\t);\n\n\t\t// Check for headers option\n\t\tfor ( i in s.headers ) {\n\t\t\tjqXHR.setRequestHeader( i, s.headers[ i ] );\n\t\t}\n\n\t\t// Allow custom headers/mimetypes and early abort\n\t\tif ( s.beforeSend &&\n\t\t\t( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {\n\n\t\t\t// Abort if not done already and return\n\t\t\treturn jqXHR.abort();\n\t\t}\n\n\t\t// Aborting is no longer a cancellation\n\t\tstrAbort = \"abort\";\n\n\t\t// Install callbacks on deferreds\n\t\tcompleteDeferred.add( s.complete );\n\t\tjqXHR.done( s.success );\n\t\tjqXHR.fail( s.error );\n\n\t\t// Get transport\n\t\ttransport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n\t\t// If no transport, we auto-abort\n\t\tif ( !transport ) {\n\t\t\tdone( -1, \"No Transport\" );\n\t\t} else {\n\t\t\tjqXHR.readyState = 1;\n\n\t\t\t// Send global event\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n\t\t\t}\n\n\t\t\t// If request was aborted inside ajaxSend, stop there\n\t\t\tif ( completed ) {\n\t\t\t\treturn jqXHR;\n\t\t\t}\n\n\t\t\t// Timeout\n\t\t\tif ( s.async && s.timeout > 0 ) {\n\t\t\t\ttimeoutTimer = window.setTimeout( function() {\n\t\t\t\t\tjqXHR.abort( \"timeout\" );\n\t\t\t\t}, s.timeout );\n\t\t\t}\n\n\t\t\ttry {\n\t\t\t\tcompleted = false;\n\t\t\t\ttransport.send( requestHeaders, done );\n\t\t\t} catch ( e ) {\n\n\t\t\t\t// Rethrow post-completion exceptions\n\t\t\t\tif ( completed ) {\n\t\t\t\t\tthrow e;\n\t\t\t\t}\n\n\t\t\t\t// Propagate others as results\n\t\t\t\tdone( -1, e );\n\t\t\t}\n\t\t}\n\n\t\t// Callback for when everything is done\n\t\tfunction done( status, nativeStatusText, responses, headers ) {\n\t\t\tvar isSuccess, success, error, response, modified,\n\t\t\t\tstatusText = nativeStatusText;\n\n\t\t\t// Ignore repeat invocations\n\t\t\tif ( completed ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tcompleted = true;\n\n\t\t\t// Clear timeout if it exists\n\t\t\tif ( timeoutTimer ) {\n\t\t\t\twindow.clearTimeout( timeoutTimer );\n\t\t\t}\n\n\t\t\t// Dereference transport for early garbage collection\n\t\t\t// (no matter how long the jqXHR object will be used)\n\t\t\ttransport = undefined;\n\n\t\t\t// Cache response headers\n\t\t\tresponseHeadersString = headers || \"\";\n\n\t\t\t// Set readyState\n\t\t\tjqXHR.readyState = status > 0 ? 4 : 0;\n\n\t\t\t// Determine if successful\n\t\t\tisSuccess = status >= 200 && status < 300 || status === 304;\n\n\t\t\t// Get response data\n\t\t\tif ( responses ) {\n\t\t\t\tresponse = ajaxHandleResponses( s, jqXHR, responses );\n\t\t\t}\n\n\t\t\t// Use a noop converter for missing script but not if jsonp\n\t\t\tif ( !isSuccess &&\n\t\t\t\tjQuery.inArray( \"script\", s.dataTypes ) > -1 &&\n\t\t\t\tjQuery.inArray( \"json\", s.dataTypes ) < 0 ) {\n\t\t\t\ts.converters[ \"text script\" ] = function() {};\n\t\t\t}\n\n\t\t\t// Convert no matter what (that way responseXXX fields are always set)\n\t\t\tresponse = ajaxConvert( s, response, jqXHR, isSuccess );\n\n\t\t\t// If successful, handle type chaining\n\t\t\tif ( isSuccess ) {\n\n\t\t\t\t// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n\t\t\t\tif ( s.ifModified ) {\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"Last-Modified\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.lastModified[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t\tmodified = jqXHR.getResponseHeader( \"etag\" );\n\t\t\t\t\tif ( modified ) {\n\t\t\t\t\t\tjQuery.etag[ cacheURL ] = modified;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// if no content\n\t\t\t\tif ( status === 204 || s.type === \"HEAD\" ) {\n\t\t\t\t\tstatusText = \"nocontent\";\n\n\t\t\t\t// if not modified\n\t\t\t\t} else if ( status === 304 ) {\n\t\t\t\t\tstatusText = \"notmodified\";\n\n\t\t\t\t// If we have data, let's convert it\n\t\t\t\t} else {\n\t\t\t\t\tstatusText = response.state;\n\t\t\t\t\tsuccess = response.data;\n\t\t\t\t\terror = response.error;\n\t\t\t\t\tisSuccess = !error;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// Extract error from statusText and normalize for non-aborts\n\t\t\t\terror = statusText;\n\t\t\t\tif ( status || !statusText ) {\n\t\t\t\t\tstatusText = \"error\";\n\t\t\t\t\tif ( status < 0 ) {\n\t\t\t\t\t\tstatus = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Set data for the fake xhr object\n\t\t\tjqXHR.status = status;\n\t\t\tjqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n\t\t\t// Success/Error\n\t\t\tif ( isSuccess ) {\n\t\t\t\tdeferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n\t\t\t} else {\n\t\t\t\tdeferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n\t\t\t}\n\n\t\t\t// Status-dependent callbacks\n\t\t\tjqXHR.statusCode( statusCode );\n\t\t\tstatusCode = undefined;\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n\t\t\t\t\t[ jqXHR, s, isSuccess ? success : error ] );\n\t\t\t}\n\n\t\t\t// Complete\n\t\t\tcompleteDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n\t\t\tif ( fireGlobals ) {\n\t\t\t\tglobalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n\n\t\t\t\t// Handle the global AJAX counter\n\t\t\t\tif ( !( --jQuery.active ) ) {\n\t\t\t\t\tjQuery.event.trigger( \"ajaxStop\" );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn jqXHR;\n\t},\n\n\tgetJSON: function( url, data, callback ) {\n\t\treturn jQuery.get( url, data, callback, \"json\" );\n\t},\n\n\tgetScript: function( url, callback ) {\n\t\treturn jQuery.get( url, undefined, callback, \"script\" );\n\t}\n} );\n\njQuery.each( [ \"get\", \"post\" ], function( _i, method ) {\n\tjQuery[ method ] = function( url, data, callback, type ) {\n\n\t\t// Shift arguments if data argument was omitted\n\t\tif ( isFunction( data ) ) {\n\t\t\ttype = type || callback;\n\t\t\tcallback = data;\n\t\t\tdata = undefined;\n\t\t}\n\n\t\t// The url can be an options object (which then must have .url)\n\t\treturn jQuery.ajax( jQuery.extend( {\n\t\t\turl: url,\n\t\t\ttype: method,\n\t\t\tdataType: type,\n\t\t\tdata: data,\n\t\t\tsuccess: callback\n\t\t}, jQuery.isPlainObject( url ) && url ) );\n\t};\n} );\n\njQuery.ajaxPrefilter( function( s ) {\n\tvar i;\n\tfor ( i in s.headers ) {\n\t\tif ( i.toLowerCase() === \"content-type\" ) {\n\t\t\ts.contentType = s.headers[ i ] || \"\";\n\t\t}\n\t}\n} );\n\nreturn jQuery;\n} );\n"]},"metadata":{},"sourceType":"script"}