{"ast":null,"code":"import { extendDataItem, mapTree } from '@progress/kendo-react-common';\nvar GROUP_ID_FIELD = 'groupId';\nvar GROUP_SUBITEMS_COLLECTION = 'items';\n/**\n * @hidden\n */\n\nvar setGroupId = function (group, depth, parentValue) {\n  if (group.items) {\n    group[GROUP_ID_FIELD] = \"\" + parentValue + (parentValue && '_') + group.value + group.field;\n\n    if (depth > 1) {\n      group.items.forEach(function (item) {\n        return setGroupId(item, depth - 1, group[GROUP_ID_FIELD]);\n      });\n    }\n  }\n};\n/**\n * Add unique ids to the group items inside data.\n *\n * @param {{data: any[], group: GroupDescriptor[]}} options - The options to be processed.\n */\n\n\nexport var setGroupIds = function (options) {\n  var group = options.group;\n\n  if (group && group.length && options.data) {\n    return options.data.forEach(function (item) {\n      return setGroupId(item, group.length, '');\n    });\n  }\n};\n/**\n * Get all group ids from the data.\n *\n * @param {{data: any[]}} options - The options to be processed.\n * @returns {string[]} - Collection of all group ids from the data.\n */\n\nexport var getGroupIds = function (options) {\n  var groupIds = [];\n  mapTree(options.data, GROUP_SUBITEMS_COLLECTION, function (item) {\n    if (item[GROUP_ID_FIELD]) {\n      groupIds.push(item[GROUP_ID_FIELD]);\n    }\n  });\n  return groupIds;\n};\n/**\n * Apply the `expanded` prop to the group items in data based on the provided collection of group ids.\n *\n * @param {{data: any[], collapsedIds: string[]}} options - The options to be processed.\n * @returns {string[]} - Collection of all group ids from the data.\n */\n\nexport var setExpandedState = function (options) {\n  // TODO: no need to traverse whole tree, only group levels\n  return mapTree(options.data, GROUP_SUBITEMS_COLLECTION, function (item) {\n    return extendDataItem(item, GROUP_SUBITEMS_COLLECTION, {\n      expanded: !options.collapsedIds.some(function (groupId) {\n        return groupId === item[GROUP_ID_FIELD];\n      })\n    });\n  });\n};","map":{"version":3,"sources":["../../../src/utils/group-operations.ts"],"names":[],"mappings":"AACA,SAAS,cAAT,EAAyB,OAAzB,QAAwC,8BAAxC;AAEA,IAAM,cAAc,GAAG,SAAvB;AACA,IAAM,yBAAyB,GAAG,OAAlC;AAEA;;AAEG;;AACH,IAAM,UAAU,GAAG,UAAC,KAAD,EAAQ,KAAR,EAAe,WAAf,EAA0B;AACzC,MAAI,KAAK,CAAC,KAAV,EAAiB;AACb,IAAA,KAAK,CAAC,cAAD,CAAL,GAAwB,KAAG,WAAH,IAAiB,WAAW,IAAI,GAAhC,IAAsC,KAAK,CAAC,KAA5C,GAAoD,KAAK,CAAC,KAAlF;;AAEA,QAAI,KAAK,GAAG,CAAZ,EAAe;AACX,MAAA,KAAK,CAAC,KAAN,CAAY,OAAZ,CAAoB,UAAA,IAAA,EAAI;AAAI,eAAA,UAAU,CAAC,IAAD,EAAO,KAAK,GAAG,CAAf,EAAkB,KAAK,CAAjC,cAAiC,CAAvB,CAAV;AAAkD,OAA9E;AACH;AACJ;AACJ,CARD;AAUA;;;;AAIG;;;AACH,OAAO,IAAM,WAAW,GAAG,UAAC,OAAD,EAAqD;AACrE,MAAA,KAAA,GAAA,OAAA,CAAA,KAAA;;AAEP,MAAI,KAAK,IAAI,KAAK,CAAC,MAAf,IAAyB,OAAO,CAAC,IAArC,EAA2C;AACvC,WAAO,OAAO,CAAC,IAAR,CAAa,OAAb,CAAqB,UAAA,IAAA,EAAI;AAAI,aAAA,UAAU,CAAC,IAAD,EAAO,KAAK,CAAC,MAAb,EAAV,EAAU,CAAV;AAAkC,KAA/D,CAAP;AACH;AACJ,CANM;AAQP;;;;;AAKG;;AACH,OAAO,IAAM,WAAW,GAAG,UAAC,OAAD,EAAqB;AAC5C,MAAM,QAAQ,GAAU,EAAxB;AAEA,EAAA,OAAO,CAAC,OAAO,CAAC,IAAT,EAAe,yBAAf,EAA0C,UAAA,IAAA,EAAI;AACjD,QAAI,IAAI,CAAC,cAAD,CAAR,EAA0B;AACtB,MAAA,QAAQ,CAAC,IAAT,CAAc,IAAI,CAAC,cAAD,CAAlB;AACH;AACJ,GAJM,CAAP;AAMA,SAAO,QAAP;AACH,CAVM;AAYP;;;;;AAKG;;AACH,OAAO,IAAM,gBAAgB,GAAG,UAAC,OAAD,EAA6C;AACzE;AACA,SAAO,OAAO,CAAC,OAAO,CAAC,IAAT,EAAe,yBAAf,EAA0C,UAAA,IAAA,EAAI;AACxD,WAAA,cAAc,CAAC,IAAD,EAAO,yBAAP,EAAkC;AAC5C,MAAA,QAAQ,EAAE,CAAC,OAAO,CAAC,YAAR,CAAqB,IAArB,CAA0B,UAAA,OAAA,EAAO;AAAI,eAAA,OAAO,KAAK,IAAI,CAAhB,cAAgB,CAAhB;AAAgC,OAArE;AADiC,KAAlC,CAAd;AAEE,GAHQ,CAAd;AAKH,CAPM","sourceRoot":"","sourcesContent":["import { extendDataItem, mapTree } from '@progress/kendo-react-common';\nvar GROUP_ID_FIELD = 'groupId';\nvar GROUP_SUBITEMS_COLLECTION = 'items';\n/**\n * @hidden\n */\nvar setGroupId = function (group, depth, parentValue) {\n    if (group.items) {\n        group[GROUP_ID_FIELD] = \"\" + parentValue + (parentValue && '_') + group.value + group.field;\n        if (depth > 1) {\n            group.items.forEach(function (item) { return setGroupId(item, depth - 1, group[GROUP_ID_FIELD]); });\n        }\n    }\n};\n/**\n * Add unique ids to the group items inside data.\n *\n * @param {{data: any[], group: GroupDescriptor[]}} options - The options to be processed.\n */\nexport var setGroupIds = function (options) {\n    var group = options.group;\n    if (group && group.length && options.data) {\n        return options.data.forEach(function (item) { return setGroupId(item, group.length, ''); });\n    }\n};\n/**\n * Get all group ids from the data.\n *\n * @param {{data: any[]}} options - The options to be processed.\n * @returns {string[]} - Collection of all group ids from the data.\n */\nexport var getGroupIds = function (options) {\n    var groupIds = [];\n    mapTree(options.data, GROUP_SUBITEMS_COLLECTION, function (item) {\n        if (item[GROUP_ID_FIELD]) {\n            groupIds.push(item[GROUP_ID_FIELD]);\n        }\n    });\n    return groupIds;\n};\n/**\n * Apply the `expanded` prop to the group items in data based on the provided collection of group ids.\n *\n * @param {{data: any[], collapsedIds: string[]}} options - The options to be processed.\n * @returns {string[]} - Collection of all group ids from the data.\n */\nexport var setExpandedState = function (options) {\n    // TODO: no need to traverse whole tree, only group levels\n    return mapTree(options.data, GROUP_SUBITEMS_COLLECTION, function (item) {\n        return extendDataItem(item, GROUP_SUBITEMS_COLLECTION, {\n            expanded: !options.collapsedIds.some(function (groupId) { return groupId === item[GROUP_ID_FIELD]; })\n        });\n    });\n};\n//# sourceMappingURL=group-operations.js.map"]},"metadata":{},"sourceType":"module"}