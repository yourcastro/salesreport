{"ast":null,"code":"define([\"./core\", \"./var/isFunction\", \"./var/slice\", \"./callbacks\"], function (jQuery, isFunction, slice) {\n  \"use strict\";\n\n  function Identity(v) {\n    return v;\n  }\n\n  function Thrower(ex) {\n    throw ex;\n  }\n\n  function adoptValue(value, resolve, reject, noValue) {\n    var method;\n\n    try {\n      // Check for promise aspect first to privilege synchronous behavior\n      if (value && isFunction(method = value.promise)) {\n        method.call(value).done(resolve).fail(reject); // Other thenables\n      } else if (value && isFunction(method = value.then)) {\n        method.call(value, resolve, reject); // Other non-thenables\n      } else {\n        // Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n        // * false: [ value ].slice( 0 ) => resolve( value )\n        // * true: [ value ].slice( 1 ) => resolve()\n        resolve.apply(undefined, [value].slice(noValue));\n      } // For Promises/A+, convert exceptions into rejections\n      // Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n      // Deferred#then to conditionally suppress rejection.\n\n    } catch (value) {\n      // Support: Android 4.0 only\n      // Strict mode functions invoked without .call/.apply get global-object context\n      reject.apply(undefined, [value]);\n    }\n  }\n\n  jQuery.extend({\n    Deferred: function (func) {\n      var tuples = [// action, add listener, callbacks,\n      // ... .then handlers, argument index, [final state]\n      [\"notify\", \"progress\", jQuery.Callbacks(\"memory\"), jQuery.Callbacks(\"memory\"), 2], [\"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), jQuery.Callbacks(\"once memory\"), 0, \"resolved\"], [\"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), jQuery.Callbacks(\"once memory\"), 1, \"rejected\"]],\n          state = \"pending\",\n          promise = {\n        state: function () {\n          return state;\n        },\n        always: function () {\n          deferred.done(arguments).fail(arguments);\n          return this;\n        },\n        \"catch\": function (fn) {\n          return promise.then(null, fn);\n        },\n        // Keep pipe for back-compat\n        pipe: function ()\n        /* fnDone, fnFail, fnProgress */\n        {\n          var fns = arguments;\n          return jQuery.Deferred(function (newDefer) {\n            jQuery.each(tuples, function (_i, tuple) {\n              // Map tuples (progress, done, fail) to arguments (done, fail, progress)\n              var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]]; // deferred.progress(function() { bind to newDefer or newDefer.notify })\n              // deferred.done(function() { bind to newDefer or newDefer.resolve })\n              // deferred.fail(function() { bind to newDefer or newDefer.reject })\n\n              deferred[tuple[1]](function () {\n                var returned = fn && fn.apply(this, arguments);\n\n                if (returned && isFunction(returned.promise)) {\n                  returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject);\n                } else {\n                  newDefer[tuple[0] + \"With\"](this, fn ? [returned] : arguments);\n                }\n              });\n            });\n            fns = null;\n          }).promise();\n        },\n        then: function (onFulfilled, onRejected, onProgress) {\n          var maxDepth = 0;\n\n          function resolve(depth, deferred, handler, special) {\n            return function () {\n              var that = this,\n                  args = arguments,\n                  mightThrow = function () {\n                var returned, then; // Support: Promises/A+ section 2.3.3.3.3\n                // https://promisesaplus.com/#point-59\n                // Ignore double-resolution attempts\n\n                if (depth < maxDepth) {\n                  return;\n                }\n\n                returned = handler.apply(that, args); // Support: Promises/A+ section 2.3.1\n                // https://promisesaplus.com/#point-48\n\n                if (returned === deferred.promise()) {\n                  throw new TypeError(\"Thenable self-resolution\");\n                } // Support: Promises/A+ sections 2.3.3.1, 3.5\n                // https://promisesaplus.com/#point-54\n                // https://promisesaplus.com/#point-75\n                // Retrieve `then` only once\n\n\n                then = returned && ( // Support: Promises/A+ section 2.3.4\n                // https://promisesaplus.com/#point-64\n                // Only check objects and functions for thenability\n                typeof returned === \"object\" || typeof returned === \"function\") && returned.then; // Handle a returned thenable\n\n                if (isFunction(then)) {\n                  // Special processors (notify) just wait for resolution\n                  if (special) {\n                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)); // Normal processors (resolve) also hook into progress\n                  } else {\n                    // ...and disregard older resolution values\n                    maxDepth++;\n                    then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith));\n                  } // Handle all other returned values\n\n                } else {\n                  // Only substitute handlers pass on context\n                  // and multiple values (non-spec behavior)\n                  if (handler !== Identity) {\n                    that = undefined;\n                    args = [returned];\n                  } // Process the value(s)\n                  // Default process is resolve\n\n\n                  (special || deferred.resolveWith)(that, args);\n                }\n              },\n                  // Only normal processors (resolve) catch and reject exceptions\n              process = special ? mightThrow : function () {\n                try {\n                  mightThrow();\n                } catch (e) {\n                  if (jQuery.Deferred.exceptionHook) {\n                    jQuery.Deferred.exceptionHook(e, process.stackTrace);\n                  } // Support: Promises/A+ section 2.3.3.3.4.1\n                  // https://promisesaplus.com/#point-61\n                  // Ignore post-resolution exceptions\n\n\n                  if (depth + 1 >= maxDepth) {\n                    // Only substitute handlers pass on context\n                    // and multiple values (non-spec behavior)\n                    if (handler !== Thrower) {\n                      that = undefined;\n                      args = [e];\n                    }\n\n                    deferred.rejectWith(that, args);\n                  }\n                }\n              }; // Support: Promises/A+ section 2.3.3.3.1\n              // https://promisesaplus.com/#point-57\n              // Re-resolve promises immediately to dodge false rejection from\n              // subsequent errors\n\n\n              if (depth) {\n                process();\n              } else {\n                // Call an optional hook to record the stack, in case of exception\n                // since it's otherwise lost when execution goes async\n                if (jQuery.Deferred.getStackHook) {\n                  process.stackTrace = jQuery.Deferred.getStackHook();\n                }\n\n                window.setTimeout(process);\n              }\n            };\n          }\n\n          return jQuery.Deferred(function (newDefer) {\n            // progress_handlers.add( ... )\n            tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)); // fulfilled_handlers.add( ... )\n\n            tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)); // rejected_handlers.add( ... )\n\n            tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower));\n          }).promise();\n        },\n        // Get a promise for this deferred\n        // If obj is provided, the promise aspect is added to the object\n        promise: function (obj) {\n          return obj != null ? jQuery.extend(obj, promise) : promise;\n        }\n      },\n          deferred = {}; // Add list-specific methods\n\n      jQuery.each(tuples, function (i, tuple) {\n        var list = tuple[2],\n            stateString = tuple[5]; // promise.progress = list.add\n        // promise.done = list.add\n        // promise.fail = list.add\n\n        promise[tuple[1]] = list.add; // Handle state\n\n        if (stateString) {\n          list.add(function () {\n            // state = \"resolved\" (i.e., fulfilled)\n            // state = \"rejected\"\n            state = stateString;\n          }, // rejected_callbacks.disable\n          // fulfilled_callbacks.disable\n          tuples[3 - i][2].disable, // rejected_handlers.disable\n          // fulfilled_handlers.disable\n          tuples[3 - i][3].disable, // progress_callbacks.lock\n          tuples[0][2].lock, // progress_handlers.lock\n          tuples[0][3].lock);\n        } // progress_handlers.fire\n        // fulfilled_handlers.fire\n        // rejected_handlers.fire\n\n\n        list.add(tuple[3].fire); // deferred.notify = function() { deferred.notifyWith(...) }\n        // deferred.resolve = function() { deferred.resolveWith(...) }\n        // deferred.reject = function() { deferred.rejectWith(...) }\n\n        deferred[tuple[0]] = function () {\n          deferred[tuple[0] + \"With\"](this === deferred ? undefined : this, arguments);\n          return this;\n        }; // deferred.notifyWith = list.fireWith\n        // deferred.resolveWith = list.fireWith\n        // deferred.rejectWith = list.fireWith\n\n\n        deferred[tuple[0] + \"With\"] = list.fireWith;\n      }); // Make the deferred a promise\n\n      promise.promise(deferred); // Call given func if any\n\n      if (func) {\n        func.call(deferred, deferred);\n      } // All done!\n\n\n      return deferred;\n    },\n    // Deferred helper\n    when: function (singleValue) {\n      var // count of uncompleted subordinates\n      remaining = arguments.length,\n          // count of unprocessed arguments\n      i = remaining,\n          // subordinate fulfillment data\n      resolveContexts = Array(i),\n          resolveValues = slice.call(arguments),\n          // the primary Deferred\n      primary = jQuery.Deferred(),\n          // subordinate callback factory\n      updateFunc = function (i) {\n        return function (value) {\n          resolveContexts[i] = this;\n          resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value;\n\n          if (! --remaining) {\n            primary.resolveWith(resolveContexts, resolveValues);\n          }\n        };\n      }; // Single- and empty arguments are adopted like Promise.resolve\n\n\n      if (remaining <= 1) {\n        adoptValue(singleValue, primary.done(updateFunc(i)).resolve, primary.reject, !remaining); // Use .then() to unwrap secondary thenables (cf. gh-3000)\n\n        if (primary.state() === \"pending\" || isFunction(resolveValues[i] && resolveValues[i].then)) {\n          return primary.then();\n        }\n      } // Multiple arguments are aggregated like Promise.all array elements\n\n\n      while (i--) {\n        adoptValue(resolveValues[i], updateFunc(i), primary.reject);\n      }\n\n      return primary.promise();\n    }\n  });\n  return jQuery;\n});","map":{"version":3,"sources":["D:/Castro/Development/hr-management-portal/hr-management-portal/node_modules/jquery/src/deferred.js"],"names":["define","jQuery","isFunction","slice","Identity","v","Thrower","ex","adoptValue","value","resolve","reject","noValue","method","promise","call","done","fail","then","apply","undefined","extend","Deferred","func","tuples","Callbacks","state","always","deferred","arguments","fn","pipe","fns","newDefer","each","_i","tuple","returned","progress","notify","onFulfilled","onRejected","onProgress","maxDepth","depth","handler","special","that","args","mightThrow","TypeError","notifyWith","resolveWith","process","e","exceptionHook","stackTrace","rejectWith","getStackHook","window","setTimeout","add","obj","i","list","stateString","disable","lock","fire","fireWith","when","singleValue","remaining","length","resolveContexts","Array","resolveValues","primary","updateFunc"],"mappings":"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","sourcesContent":["define( [\n\t\"./core\",\n\t\"./var/isFunction\",\n\t\"./var/slice\",\n\t\"./callbacks\"\n], function( jQuery, isFunction, slice ) {\n\n\"use strict\";\n\nfunction Identity( v ) {\n\treturn v;\n}\nfunction Thrower( ex ) {\n\tthrow ex;\n}\n\nfunction adoptValue( value, resolve, reject, noValue ) {\n\tvar method;\n\n\ttry {\n\n\t\t// Check for promise aspect first to privilege synchronous behavior\n\t\tif ( value && isFunction( ( method = value.promise ) ) ) {\n\t\t\tmethod.call( value ).done( resolve ).fail( reject );\n\n\t\t// Other thenables\n\t\t} else if ( value && isFunction( ( method = value.then ) ) ) {\n\t\t\tmethod.call( value, resolve, reject );\n\n\t\t// Other non-thenables\n\t\t} else {\n\n\t\t\t// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:\n\t\t\t// * false: [ value ].slice( 0 ) => resolve( value )\n\t\t\t// * true: [ value ].slice( 1 ) => resolve()\n\t\t\tresolve.apply( undefined, [ value ].slice( noValue ) );\n\t\t}\n\n\t// For Promises/A+, convert exceptions into rejections\n\t// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in\n\t// Deferred#then to conditionally suppress rejection.\n\t} catch ( value ) {\n\n\t\t// Support: Android 4.0 only\n\t\t// Strict mode functions invoked without .call/.apply get global-object context\n\t\treject.apply( undefined, [ value ] );\n\t}\n}\n\njQuery.extend( {\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\n\t\t\t\t// action, add listener, callbacks,\n\t\t\t\t// ... .then handlers, argument index, [final state]\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks( \"memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"memory\" ), 2 ],\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 0, \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks( \"once memory\" ),\n\t\t\t\t\tjQuery.Callbacks( \"once memory\" ), 1, \"rejected\" ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\t\"catch\": function( fn ) {\n\t\t\t\t\treturn promise.then( null, fn );\n\t\t\t\t},\n\n\t\t\t\t// Keep pipe for back-compat\n\t\t\t\tpipe: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( _i, tuple ) {\n\n\t\t\t\t\t\t\t// Map tuples (progress, done, fail) to arguments (done, fail, progress)\n\t\t\t\t\t\t\tvar fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];\n\n\t\t\t\t\t\t\t// deferred.progress(function() { bind to newDefer or newDefer.notify })\n\t\t\t\t\t\t\t// deferred.done(function() { bind to newDefer or newDefer.resolve })\n\t\t\t\t\t\t\t// deferred.fail(function() { bind to newDefer or newDefer.reject })\n\t\t\t\t\t\t\tdeferred[ tuple[ 1 ] ]( function() {\n\t\t\t\t\t\t\t\tvar returned = fn && fn.apply( this, arguments );\n\t\t\t\t\t\t\t\tif ( returned && isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify )\n\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject );\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tnewDefer[ tuple[ 0 ] + \"With\" ](\n\t\t\t\t\t\t\t\t\t\tthis,\n\t\t\t\t\t\t\t\t\t\tfn ? [ returned ] : arguments\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} );\n\t\t\t\t\t\t} );\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\t\t\t\tthen: function( onFulfilled, onRejected, onProgress ) {\n\t\t\t\t\tvar maxDepth = 0;\n\t\t\t\t\tfunction resolve( depth, deferred, handler, special ) {\n\t\t\t\t\t\treturn function() {\n\t\t\t\t\t\t\tvar that = this,\n\t\t\t\t\t\t\t\targs = arguments,\n\t\t\t\t\t\t\t\tmightThrow = function() {\n\t\t\t\t\t\t\t\t\tvar returned, then;\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.3\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-59\n\t\t\t\t\t\t\t\t\t// Ignore double-resolution attempts\n\t\t\t\t\t\t\t\t\tif ( depth < maxDepth ) {\n\t\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\treturned = handler.apply( that, args );\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.1\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-48\n\t\t\t\t\t\t\t\t\tif ( returned === deferred.promise() ) {\n\t\t\t\t\t\t\t\t\t\tthrow new TypeError( \"Thenable self-resolution\" );\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Support: Promises/A+ sections 2.3.3.1, 3.5\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-54\n\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-75\n\t\t\t\t\t\t\t\t\t// Retrieve `then` only once\n\t\t\t\t\t\t\t\t\tthen = returned &&\n\n\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.4\n\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-64\n\t\t\t\t\t\t\t\t\t\t// Only check objects and functions for thenability\n\t\t\t\t\t\t\t\t\t\t( typeof returned === \"object\" ||\n\t\t\t\t\t\t\t\t\t\t\ttypeof returned === \"function\" ) &&\n\t\t\t\t\t\t\t\t\t\treturned.then;\n\n\t\t\t\t\t\t\t\t\t// Handle a returned thenable\n\t\t\t\t\t\t\t\t\tif ( isFunction( then ) ) {\n\n\t\t\t\t\t\t\t\t\t\t// Special processors (notify) just wait for resolution\n\t\t\t\t\t\t\t\t\t\tif ( special ) {\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special )\n\t\t\t\t\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\t\t\t\t// Normal processors (resolve) also hook into progress\n\t\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t\t// ...and disregard older resolution values\n\t\t\t\t\t\t\t\t\t\t\tmaxDepth++;\n\n\t\t\t\t\t\t\t\t\t\t\tthen.call(\n\t\t\t\t\t\t\t\t\t\t\t\treturned,\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Thrower, special ),\n\t\t\t\t\t\t\t\t\t\t\t\tresolve( maxDepth, deferred, Identity,\n\t\t\t\t\t\t\t\t\t\t\t\t\tdeferred.notifyWith )\n\t\t\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// Handle all other returned values\n\t\t\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\tif ( handler !== Identity ) {\n\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\targs = [ returned ];\n\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// Process the value(s)\n\t\t\t\t\t\t\t\t\t\t// Default process is resolve\n\t\t\t\t\t\t\t\t\t\t( special || deferred.resolveWith )( that, args );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t},\n\n\t\t\t\t\t\t\t\t// Only normal processors (resolve) catch and reject exceptions\n\t\t\t\t\t\t\t\tprocess = special ?\n\t\t\t\t\t\t\t\t\tmightThrow :\n\t\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\t\t\t\tmightThrow();\n\t\t\t\t\t\t\t\t\t\t} catch ( e ) {\n\n\t\t\t\t\t\t\t\t\t\t\tif ( jQuery.Deferred.exceptionHook ) {\n\t\t\t\t\t\t\t\t\t\t\t\tjQuery.Deferred.exceptionHook( e,\n\t\t\t\t\t\t\t\t\t\t\t\t\tprocess.stackTrace );\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.4.1\n\t\t\t\t\t\t\t\t\t\t\t// https://promisesaplus.com/#point-61\n\t\t\t\t\t\t\t\t\t\t\t// Ignore post-resolution exceptions\n\t\t\t\t\t\t\t\t\t\t\tif ( depth + 1 >= maxDepth ) {\n\n\t\t\t\t\t\t\t\t\t\t\t\t// Only substitute handlers pass on context\n\t\t\t\t\t\t\t\t\t\t\t\t// and multiple values (non-spec behavior)\n\t\t\t\t\t\t\t\t\t\t\t\tif ( handler !== Thrower ) {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthat = undefined;\n\t\t\t\t\t\t\t\t\t\t\t\t\targs = [ e ];\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\tdeferred.rejectWith( that, args );\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t// Support: Promises/A+ section 2.3.3.3.1\n\t\t\t\t\t\t\t// https://promisesaplus.com/#point-57\n\t\t\t\t\t\t\t// Re-resolve promises immediately to dodge false rejection from\n\t\t\t\t\t\t\t// subsequent errors\n\t\t\t\t\t\t\tif ( depth ) {\n\t\t\t\t\t\t\t\tprocess();\n\t\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t\t// Call an optional hook to record the stack, in case of exception\n\t\t\t\t\t\t\t\t// since it's otherwise lost when execution goes async\n\t\t\t\t\t\t\t\tif ( jQuery.Deferred.getStackHook ) {\n\t\t\t\t\t\t\t\t\tprocess.stackTrace = jQuery.Deferred.getStackHook();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\twindow.setTimeout( process );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\treturn jQuery.Deferred( function( newDefer ) {\n\n\t\t\t\t\t\t// progress_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 0 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onProgress ) ?\n\t\t\t\t\t\t\t\t\tonProgress :\n\t\t\t\t\t\t\t\t\tIdentity,\n\t\t\t\t\t\t\t\tnewDefer.notifyWith\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// fulfilled_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 1 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onFulfilled ) ?\n\t\t\t\t\t\t\t\t\tonFulfilled :\n\t\t\t\t\t\t\t\t\tIdentity\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\t// rejected_handlers.add( ... )\n\t\t\t\t\t\ttuples[ 2 ][ 3 ].add(\n\t\t\t\t\t\t\tresolve(\n\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\tnewDefer,\n\t\t\t\t\t\t\t\tisFunction( onRejected ) ?\n\t\t\t\t\t\t\t\t\tonRejected :\n\t\t\t\t\t\t\t\t\tThrower\n\t\t\t\t\t\t\t)\n\t\t\t\t\t\t);\n\t\t\t\t\t} ).promise();\n\t\t\t\t},\n\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 5 ];\n\n\t\t\t// promise.progress = list.add\n\t\t\t// promise.done = list.add\n\t\t\t// promise.fail = list.add\n\t\t\tpromise[ tuple[ 1 ] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(\n\t\t\t\t\tfunction() {\n\n\t\t\t\t\t\t// state = \"resolved\" (i.e., fulfilled)\n\t\t\t\t\t\t// state = \"rejected\"\n\t\t\t\t\t\tstate = stateString;\n\t\t\t\t\t},\n\n\t\t\t\t\t// rejected_callbacks.disable\n\t\t\t\t\t// fulfilled_callbacks.disable\n\t\t\t\t\ttuples[ 3 - i ][ 2 ].disable,\n\n\t\t\t\t\t// rejected_handlers.disable\n\t\t\t\t\t// fulfilled_handlers.disable\n\t\t\t\t\ttuples[ 3 - i ][ 3 ].disable,\n\n\t\t\t\t\t// progress_callbacks.lock\n\t\t\t\t\ttuples[ 0 ][ 2 ].lock,\n\n\t\t\t\t\t// progress_handlers.lock\n\t\t\t\t\ttuples[ 0 ][ 3 ].lock\n\t\t\t\t);\n\t\t\t}\n\n\t\t\t// progress_handlers.fire\n\t\t\t// fulfilled_handlers.fire\n\t\t\t// rejected_handlers.fire\n\t\t\tlist.add( tuple[ 3 ].fire );\n\n\t\t\t// deferred.notify = function() { deferred.notifyWith(...) }\n\t\t\t// deferred.resolve = function() { deferred.resolveWith(...) }\n\t\t\t// deferred.reject = function() { deferred.rejectWith(...) }\n\t\t\tdeferred[ tuple[ 0 ] ] = function() {\n\t\t\t\tdeferred[ tuple[ 0 ] + \"With\" ]( this === deferred ? undefined : this, arguments );\n\t\t\t\treturn this;\n\t\t\t};\n\n\t\t\t// deferred.notifyWith = list.fireWith\n\t\t\t// deferred.resolveWith = list.fireWith\n\t\t\t// deferred.rejectWith = list.fireWith\n\t\t\tdeferred[ tuple[ 0 ] + \"With\" ] = list.fireWith;\n\t\t} );\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( singleValue ) {\n\t\tvar\n\n\t\t\t// count of uncompleted subordinates\n\t\t\tremaining = arguments.length,\n\n\t\t\t// count of unprocessed arguments\n\t\t\ti = remaining,\n\n\t\t\t// subordinate fulfillment data\n\t\t\tresolveContexts = Array( i ),\n\t\t\tresolveValues = slice.call( arguments ),\n\n\t\t\t// the primary Deferred\n\t\t\tprimary = jQuery.Deferred(),\n\n\t\t\t// subordinate callback factory\n\t\t\tupdateFunc = function( i ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tresolveContexts[ i ] = this;\n\t\t\t\t\tresolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;\n\t\t\t\t\tif ( !( --remaining ) ) {\n\t\t\t\t\t\tprimary.resolveWith( resolveContexts, resolveValues );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t// Single- and empty arguments are adopted like Promise.resolve\n\t\tif ( remaining <= 1 ) {\n\t\t\tadoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,\n\t\t\t\t!remaining );\n\n\t\t\t// Use .then() to unwrap secondary thenables (cf. gh-3000)\n\t\t\tif ( primary.state() === \"pending\" ||\n\t\t\t\tisFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {\n\n\t\t\t\treturn primary.then();\n\t\t\t}\n\t\t}\n\n\t\t// Multiple arguments are aggregated like Promise.all array elements\n\t\twhile ( i-- ) {\n\t\t\tadoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );\n\t\t}\n\n\t\treturn primary.promise();\n\t}\n} );\n\nreturn jQuery;\n} );\n"]},"metadata":{},"sourceType":"script"}