{"version":3,"file":"fetch-hoc.min.js","sources":["../src/index.js"],"sourcesContent":["// @flow\nimport React from 'react';\n\nexport default (\n  resource: string | Function,\n  options?: RequestOptions,\n): Function => Component =>\n  class FetchHOC extends React.Component {\n    _isMounted: boolean;\n\n    getUrl = () => {\n      let url = resource;\n      if (typeof resource === 'function') {\n        url = resource(this.props);\n      }\n\n      return url;\n    };\n\n    state = {\n      // Ensure only truthy URLs start off as loading (#3)\n      loading: !!this.getUrl(),\n      success: undefined,\n      error: undefined,\n    };\n\n    prevUrl = this.getUrl();\n\n    componentDidMount = () => {\n      this._isMounted = true;\n      this.fetchData(this.getUrl());\n    };\n\n    componentDidUpdate() {\n      if (typeof resource === 'function' && this.urlHasChanged()) {\n        this.fetchData(this.getUrl());\n      }\n    }\n\n    componentWillUnmount() {\n      this._isMounted = false;\n    }\n\n    fetchData = url => {\n      if (!url) return;\n\n      // About to start fetching, set loading state\n      this.setState(() => ({\n        loading: true,\n        success: undefined,\n        error: undefined,\n        response: undefined,\n      }));\n\n      const init = {\n        credentials: 'same-origin',\n        ...options,\n      };\n\n      let response;\n      fetch(url, init)\n        .then(result => {\n          response = result.clone();\n          return result.text();\n        })\n        .then(data => {\n          try {\n            data = JSON.parse(data);\n          } catch (e) {\n            // Not JSON\n          }\n\n          if (!this._isMounted) return;\n\n          if (response.status >= 400 && response.status <= 599) {\n            this.setState(() => ({\n              data,\n              error: new Error(response.statusText),\n              loading: false,\n              success: false,\n              response,\n            }));\n            return;\n          }\n\n          this.setState(() => ({\n            data,\n            loading: false,\n            success: true,\n            response,\n          }));\n        })\n        .catch(error => {\n          if (!this._isMounted) return;\n\n          this.setState(() => ({\n            error,\n            loading: false,\n            success: false,\n            response,\n          }));\n        });\n    };\n\n    urlHasChanged = () => {\n      if (typeof resource !== 'function') {\n        return this.prevUrl !== resource;\n      }\n\n      const currentUrl = resource(this.props);\n      if (this.prevUrl !== currentUrl) {\n        this.prevUrl = currentUrl;\n        return true;\n      }\n\n      return false;\n    };\n\n    render() {\n      return <Component {...this.props} {...this.state} />;\n    }\n  };\n"],"names":["resource","options","getUrl","url","_this","props","state","undefined","prevUrl","componentDidMount","_isMounted","fetchData","setState","init","response","then","result","clone","text","JSON","parse","data","e","status","Error","statusText","catch","urlHasChanged","currentUrl","componentDidUpdate","this","componentWillUnmount","render","React","Component"],"mappings":"0/BAIEA,EACAC,UACa,0LAIXC,OAAS,eACHC,EAAMH,QACc,mBAAbA,MACHA,EAASI,EAAKC,QAGfF,KAGTG,iBAEaF,EAAKF,sBACPK,aACFA,KAGTC,QAAUJ,EAAKF,WAEfO,kBAAoB,aACbC,YAAa,IACbC,UAAUP,EAAKF,aAatBS,UAAY,eACLR,KAGAS,SAAS,2BACH,eACAL,aACFA,gBACGA,SAGNM,iBACS,eACVZ,GAGDa,eACEX,EAAKU,GACRE,KAAK,qBACOC,EAAOC,QACXD,EAAOE,SAEfH,KAAK,kBAEKI,KAAKC,MAAMC,GAClB,MAAOC,IAIJlB,EAAKM,cAaLE,SAXkB,IAAnBE,EAASS,QAAiBT,EAASS,OAAU,IAWnC,kCAEH,WACA,eAbK,+BAEDC,MAAMV,EAASW,qBACjB,WACA,kBAadC,MAAM,YACAtB,EAAKM,cAELE,SAAS,mCAEH,WACA,sBAMjBe,cAAgB,cACU,mBAAb3B,SACFI,EAAKI,UAAYR,MAGpB4B,EAAa5B,EAASI,EAAKC,cAC7BD,EAAKI,UAAYoB,MACdpB,QAAUoB,GACR,yCA/EXC,8BAC0B,mBAAb7B,GAA2B8B,KAAKH,sBACpChB,UAAUmB,KAAK5B,uBAIxB6B,qCACOrB,YAAa,eA8EpBsB,yBACSC,gBAACC,OAAcJ,KAAKzB,MAAWyB,KAAKxB,YAhHxB2B,EAAMC"}