var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
import * as React from 'react';
import * as PropTypes from 'prop-types';
import { Keys, classNames, guid, useDir, getTabIndex, dispatchEvent } from '@progress/kendo-react-common';
import { validatePackage } from '@progress/kendo-licensing';
import { packageMetadata } from '../package-metadata';
import { useLocalization } from '@progress/kendo-react-intl';
import { messages, checkboxValidation, checkboxOptionalText } from './../messages';
/**
 * Represents the [KendoReact Checkbox component]({% slug overview_checkbox %}).
 *
 * @example
 * ```jsx
 * class App extends React.Component {
 *     render() {
 *         return <Checkbox />;
 *     }
 * }
 * ReactDOM.render(<App />, document.querySelector('my-app'));
 * ```
 */
export var Checkbox = React.forwardRef(function (props, target) {
    validatePackage(packageMetadata);
    var _a = props, ariaDescribedBy = _a.ariaDescribedBy, ariaLabelledBy = _a.ariaLabelledBy, checked = _a.checked, className = _a.className, children = _a.children, defaultChecked = _a.defaultChecked, disabled = _a.disabled, defaultValue = _a.defaultValue, id = _a.id, label = _a.label, labelPlacement = _a.labelPlacement, name = _a.name, labelOptional = _a.labelOptional, onChange = _a.onChange, onFocus = _a.onFocus, onBlur = _a.onBlur, tabIndex = _a.tabIndex, value = _a.value, required = _a.required, valid = _a.valid, validationMessage = _a.validationMessage, validityStyles = _a.validityStyles, 
    // Removed to support direct use in Form Field component
    visited = _a.visited, touched = _a.touched, modified = _a.modified, others = __rest(_a, ["ariaDescribedBy", "ariaLabelledBy", "checked", "className", "children", "defaultChecked", "disabled", "defaultValue", "id", "label", "labelPlacement", "name", "labelOptional", "onChange", "onFocus", "onBlur", "tabIndex", "value", "required", "valid", "validationMessage", "validityStyles", "visited", "touched", "modified"]);
    var elementRef = React.useRef(null);
    var focusElement = React.useCallback(function () {
        if (elementRef.current) {
            elementRef.current.focus();
        }
    }, []);
    var getImperativeHandle = React.useCallback(function () { return ({
        element: elementRef.current,
        focus: focusElement
    }); }, [focusElement]);
    React.useImperativeHandle(target, getImperativeHandle);
    var _b = React.useState(defaultChecked), stateChecked = _b[0], setStateChecked = _b[1];
    var _c = React.useState(defaultValue), stateValue = _c[0], setStateValue = _c[1];
    var valueIsBoolean = (typeof value === 'boolean' || value === null);
    var isCheckedControlled = checked !== undefined;
    var isValueControlled = value !== undefined && valueIsBoolean;
    var currentValue = isValueControlled ? value : stateValue;
    var currentChecked = isCheckedControlled ? checked : stateChecked;
    var useValueAsChecked = currentChecked === undefined && currentValue;
    var checkedProp = useValueAsChecked ? currentValue : currentChecked;
    var valueProp = (useValueAsChecked || isValueControlled) ? (value === null ? value : undefined) : value || currentValue;
    var indeterminateProp = checkedProp === null || valueProp === null;
    var calculatedId = React.useMemo(function () { return guid(); }, []);
    var localizationService = useLocalization();
    var localizeMessage = function (message) {
        return localizationService.toLanguageString(message, messages[message]);
    };
    var defaultValidationMessage = localizeMessage(checkboxValidation);
    var optionalMessage = localizeMessage(checkboxOptionalText);
    var isValid = valid !== undefined ?
        valid :
        !required ?
            true :
            currentChecked ? true : false;
    React.useEffect(function () {
        if (elementRef.current && elementRef.current.setCustomValidity) {
            elementRef.current.setCustomValidity(isValid
                ? ''
                : (validationMessage || defaultValidationMessage));
        }
    }, [isValid, validationMessage, defaultValidationMessage]);
    var setValue = React.useCallback(function (e, val) {
        if (!isValueControlled && !disabled) {
            setStateValue(val);
            if (!isCheckedControlled && !disabled) {
                setStateChecked(val);
            }
        }
        if (onChange && !disabled) {
            dispatchEvent(onChange, e, getImperativeHandle(), { value: val });
        }
    }, [isCheckedControlled, disabled, onChange, isValueControlled, getImperativeHandle]);
    var handleChange = React.useCallback(function (e) {
        var newValue = e.target.checked;
        setValue(e, newValue);
    }, [setValue, value]);
    var handleKeyDown = React.useCallback(function (e) {
        if (disabled) {
            return;
        }
        var keyCode = e.keyCode;
        var currentVal = e.currentTarget.checked;
        if (keyCode === Keys.space) {
            e.preventDefault();
            e.stopPropagation();
            setValue(e, !currentVal);
        }
    }, [disabled, setValue]);
    var handleKeyUp = React.useCallback(function (e) {
        if (disabled) {
            return;
        }
        var keyCode = e.keyCode;
        if (keyCode === Keys.space) {
            e.preventDefault();
        }
    }, [disabled]);
    var handleFocus = React.useCallback(function (e) {
        if (onFocus && !disabled) {
            dispatchEvent(onFocus, e, getImperativeHandle(), undefined);
        }
    }, [onFocus, disabled, getImperativeHandle]);
    var handleBlur = React.useCallback(function (e) {
        if (onBlur && !disabled) {
            dispatchEvent(onBlur, e, getImperativeHandle(), undefined);
        }
    }, [onBlur, disabled, getImperativeHandle]);
    var dir = useDir(elementRef, props.dir);
    var checkboxClasses = classNames({ 'k-state-disabled': disabled }, className);
    var inputProps = __assign({ type: 'checkbox', className: classNames({
            'k-checkbox': true,
            'k-state-indeterminate': indeterminateProp,
            'k-state-invalid k-invalid': !(isValid || validityStyles !== undefined || validityStyles === true)
        }), ref: elementRef, name: name, id: id || calculatedId, 'aria-labelledby': ariaLabelledBy, 'aria-describedby': ariaDescribedBy, checked: Boolean(checkedProp), disabled: disabled, tabIndex: getTabIndex(tabIndex, disabled), role: 'checkbox', required: required !== undefined ? required : false, 'aria-checked': currentChecked || checkedProp ?
            true :
            indeterminateProp ?
                'mixed' :
                false, 'aria-disabled': disabled || undefined }, others, { onChange: handleChange, onKeyDown: handleKeyDown, onKeyUp: handleKeyUp, onFocus: handleFocus, onBlur: handleBlur });
    var checkboxInput = (React.createElement(React.Fragment, null, 
    // removing value prop is required due to bug in react where
    // value set to undefined override default submit value
    valueProp === undefined ? (React.createElement("input", __assign({}, inputProps))) : (React.createElement("input", __assign({}, inputProps, { value: valueIsBoolean ? undefined : valueProp === null ? '' : valueProp })))));
    var checkboxLabel = (React.createElement(React.Fragment, null, label !== undefined ? (React.createElement("label", { className: 'k-checkbox-label', htmlFor: id || calculatedId, style: { userSelect: 'none' } },
        label,
        labelOptional && React.createElement("span", { className: "k-label-optional" }, optionalMessage))) : null));
    return (React.createElement(React.Fragment, null, (labelPlacement === 'before') ? (React.createElement("span", { className: checkboxClasses, dir: 'rtl' },
        checkboxInput,
        checkboxLabel,
        children)) : (React.createElement("span", { className: checkboxClasses, dir: dir },
        checkboxInput,
        checkboxLabel,
        children))));
});
Checkbox.propTypes = {
    checked: PropTypes.bool,
    className: PropTypes.string,
    defaultChecked: PropTypes.bool,
    defaultValue: PropTypes.any,
    dir: PropTypes.string,
    disabled: PropTypes.bool,
    id: PropTypes.string,
    ariaLabelledBy: PropTypes.string,
    ariaDescribedBy: PropTypes.string,
    label: PropTypes.any,
    labelPlacement: PropTypes.string,
    labelOptional: PropTypes.bool,
    name: PropTypes.string,
    tabIndex: PropTypes.number,
    value: PropTypes.any,
    validationMessage: PropTypes.string,
    required: PropTypes.bool,
    validate: PropTypes.bool,
    valid: PropTypes.bool,
    onChange: PropTypes.func,
    onFocus: PropTypes.func,
    onBlur: PropTypes.func
};
Checkbox.displayName = 'KendoCheckbox';
//# sourceMappingURL=Checkbox.js.map